/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/web-streams-polyfill";
exports.ids = ["vendor-chunks/web-streams-polyfill"];
exports.modules = {

/***/ "(rsc)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js":
/*!*******************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * @license\n * web-streams-polyfill v3.3.2\n * Copyright 2024 Mattias Buelens, Diwank Singh Tomer and other contributors.\n * This code is released under the MIT license.\n * SPDX-License-Identifier: MIT\n */ (function(global1, factory) {\n     true ? factory(exports) : 0;\n})(this, function(exports1) {\n    \"use strict\";\n    /// <reference lib=\"es2015.symbol\" />\n    const SymbolPolyfill = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? Symbol : (description)=>`Symbol(${description})`;\n    function noop() {\n        return undefined;\n    }\n    function typeIsObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    const rethrowAssertionErrorRejection = noop;\n    function setFunctionName(fn, name) {\n        try {\n            Object.defineProperty(fn, \"name\", {\n                value: name,\n                configurable: true\n            });\n        } catch (_a) {\n        // This property is non-configurable in older browsers, so ignore if this throws.\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility\n        }\n    }\n    const originalPromise = Promise;\n    const originalPromiseThen = Promise.prototype.then;\n    const originalPromiseReject = Promise.reject.bind(originalPromise);\n    // https://webidl.spec.whatwg.org/#a-new-promise\n    function newPromise(executor) {\n        return new originalPromise(executor);\n    }\n    // https://webidl.spec.whatwg.org/#a-promise-resolved-with\n    function promiseResolvedWith(value) {\n        return newPromise((resolve)=>resolve(value));\n    }\n    // https://webidl.spec.whatwg.org/#a-promise-rejected-with\n    function promiseRejectedWith(reason) {\n        return originalPromiseReject(reason);\n    }\n    function PerformPromiseThen(promise, onFulfilled, onRejected) {\n        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n        // approximation.\n        return originalPromiseThen.call(promise, onFulfilled, onRejected);\n    }\n    // Bluebird logs a warning when a promise is created within a fulfillment handler, but then isn't returned\n    // from that handler. To prevent this, return null instead of void from all handlers.\n    // http://bluebirdjs.com/docs/warning-explanations.html#warning-a-promise-was-created-in-a-handler-but-was-not-returned-from-it\n    function uponPromise(promise, onFulfilled, onRejected) {\n        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n    }\n    function uponFulfillment(promise, onFulfilled) {\n        uponPromise(promise, onFulfilled);\n    }\n    function uponRejection(promise, onRejected) {\n        uponPromise(promise, undefined, onRejected);\n    }\n    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n    }\n    function setPromiseIsHandledToTrue(promise) {\n        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n    }\n    let _queueMicrotask = (callback)=>{\n        if (typeof queueMicrotask === \"function\") {\n            _queueMicrotask = queueMicrotask;\n        } else {\n            const resolvedPromise = promiseResolvedWith(undefined);\n            _queueMicrotask = (cb)=>PerformPromiseThen(resolvedPromise, cb);\n        }\n        return _queueMicrotask(callback);\n    };\n    function reflectCall(F, V, args) {\n        if (typeof F !== \"function\") {\n            throw new TypeError(\"Argument is not a function\");\n        }\n        return Function.prototype.apply.call(F, V, args);\n    }\n    function promiseCall(F, V, args) {\n        try {\n            return promiseResolvedWith(reflectCall(F, V, args));\n        } catch (value) {\n            return promiseRejectedWith(value);\n        }\n    }\n    // Original from Chromium\n    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\n    const QUEUE_MAX_ARRAY_SIZE = 16384;\n    /**\n     * Simple queue structure.\n     *\n     * Avoids scalability issues with using a packed array directly by using\n     * multiple arrays in a linked list and keeping the array size bounded.\n     */ class SimpleQueue {\n        constructor(){\n            this._cursor = 0;\n            this._size = 0;\n            // _front and _back are always defined.\n            this._front = {\n                _elements: [],\n                _next: undefined\n            };\n            this._back = this._front;\n            // The cursor is used to avoid calling Array.shift().\n            // It contains the index of the front element of the array inside the\n            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n            this._cursor = 0;\n            // When there is only one node, size === elements.length - cursor.\n            this._size = 0;\n        }\n        get length() {\n            return this._size;\n        }\n        // For exception safety, this method is structured in order:\n        // 1. Read state\n        // 2. Calculate required state mutations\n        // 3. Perform state mutations\n        push(element) {\n            const oldBack = this._back;\n            let newBack = oldBack;\n            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n                newBack = {\n                    _elements: [],\n                    _next: undefined\n                };\n            }\n            // push() is the mutation most likely to throw an exception, so it\n            // goes first.\n            oldBack._elements.push(element);\n            if (newBack !== oldBack) {\n                this._back = newBack;\n                oldBack._next = newBack;\n            }\n            ++this._size;\n        }\n        // Like push(), shift() follows the read -> calculate -> mutate pattern for\n        // exception safety.\n        shift() {\n            const oldFront = this._front;\n            let newFront = oldFront;\n            const oldCursor = this._cursor;\n            let newCursor = oldCursor + 1;\n            const elements = oldFront._elements;\n            const element = elements[oldCursor];\n            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n                newFront = oldFront._next;\n                newCursor = 0;\n            }\n            // No mutations before this point.\n            --this._size;\n            this._cursor = newCursor;\n            if (oldFront !== newFront) {\n                this._front = newFront;\n            }\n            // Permit shifted element to be garbage collected.\n            elements[oldCursor] = undefined;\n            return element;\n        }\n        // The tricky thing about forEach() is that it can be called\n        // re-entrantly. The queue may be mutated inside the callback. It is easy to\n        // see that push() within the callback has no negative effects since the end\n        // of the queue is checked for on every iteration. If shift() is called\n        // repeatedly within the callback then the next iteration may return an\n        // element that has been removed. In this case the callback will be called\n        // with undefined values until we either \"catch up\" with elements that still\n        // exist or reach the back of the queue.\n        forEach(callback) {\n            let i = this._cursor;\n            let node = this._front;\n            let elements = node._elements;\n            while(i !== elements.length || node._next !== undefined){\n                if (i === elements.length) {\n                    node = node._next;\n                    elements = node._elements;\n                    i = 0;\n                    if (elements.length === 0) {\n                        break;\n                    }\n                }\n                callback(elements[i]);\n                ++i;\n            }\n        }\n        // Return the element that would be returned if shift() was called now,\n        // without modifying the queue.\n        peek() {\n            const front = this._front;\n            const cursor = this._cursor;\n            return front._elements[cursor];\n        }\n    }\n    const AbortSteps = SymbolPolyfill(\"[[AbortSteps]]\");\n    const ErrorSteps = SymbolPolyfill(\"[[ErrorSteps]]\");\n    const CancelSteps = SymbolPolyfill(\"[[CancelSteps]]\");\n    const PullSteps = SymbolPolyfill(\"[[PullSteps]]\");\n    const ReleaseSteps = SymbolPolyfill(\"[[ReleaseSteps]]\");\n    function ReadableStreamReaderGenericInitialize(reader, stream) {\n        reader._ownerReadableStream = stream;\n        stream._reader = reader;\n        if (stream._state === \"readable\") {\n            defaultReaderClosedPromiseInitialize(reader);\n        } else if (stream._state === \"closed\") {\n            defaultReaderClosedPromiseInitializeAsResolved(reader);\n        } else {\n            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n        }\n    }\n    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n    // check.\n    function ReadableStreamReaderGenericCancel(reader, reason) {\n        const stream = reader._ownerReadableStream;\n        return ReadableStreamCancel(stream, reason);\n    }\n    function ReadableStreamReaderGenericRelease(reader) {\n        const stream = reader._ownerReadableStream;\n        if (stream._state === \"readable\") {\n            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        } else {\n            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n        }\n        stream._readableStreamController[ReleaseSteps]();\n        stream._reader = undefined;\n        reader._ownerReadableStream = undefined;\n    }\n    // Helper functions for the readers.\n    function readerLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released reader\");\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderClosedPromiseInitialize(reader) {\n        reader._closedPromise = newPromise((resolve, reject)=>{\n            reader._closedPromise_resolve = resolve;\n            reader._closedPromise_reject = reject;\n        });\n    }\n    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseReject(reader, reason);\n    }\n    function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n        defaultReaderClosedPromiseInitialize(reader);\n        defaultReaderClosedPromiseResolve(reader);\n    }\n    function defaultReaderClosedPromiseReject(reader, reason) {\n        if (reader._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(reader._closedPromise);\n        reader._closedPromise_reject(reason);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n    }\n    function defaultReaderClosedPromiseResolve(reader) {\n        if (reader._closedPromise_resolve === undefined) {\n            return;\n        }\n        reader._closedPromise_resolve(undefined);\n        reader._closedPromise_resolve = undefined;\n        reader._closedPromise_reject = undefined;\n    }\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\n    const NumberIsFinite = Number.isFinite || function(x) {\n        return typeof x === \"number\" && isFinite(x);\n    };\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\n    const MathTrunc = Math.trunc || function(v) {\n        return v < 0 ? Math.ceil(v) : Math.floor(v);\n    };\n    // https://heycam.github.io/webidl/#idl-dictionaries\n    function isDictionary(x) {\n        return typeof x === \"object\" || typeof x === \"function\";\n    }\n    function assertDictionary(obj, context) {\n        if (obj !== undefined && !isDictionary(obj)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-callback-functions\n    function assertFunction(x, context) {\n        if (typeof x !== \"function\") {\n            throw new TypeError(`${context} is not a function.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-object\n    function isObject(x) {\n        return typeof x === \"object\" && x !== null || typeof x === \"function\";\n    }\n    function assertObject(x, context) {\n        if (!isObject(x)) {\n            throw new TypeError(`${context} is not an object.`);\n        }\n    }\n    function assertRequiredArgument(x, position, context) {\n        if (x === undefined) {\n            throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n        }\n    }\n    function assertRequiredField(x, field, context) {\n        if (x === undefined) {\n            throw new TypeError(`${field} is required in '${context}'.`);\n        }\n    }\n    // https://heycam.github.io/webidl/#idl-unrestricted-double\n    function convertUnrestrictedDouble(value) {\n        return Number(value);\n    }\n    function censorNegativeZero(x) {\n        return x === 0 ? 0 : x;\n    }\n    function integerPart(x) {\n        return censorNegativeZero(MathTrunc(x));\n    }\n    // https://heycam.github.io/webidl/#idl-unsigned-long-long\n    function convertUnsignedLongLongWithEnforceRange(value, context) {\n        const lowerBound = 0;\n        const upperBound = Number.MAX_SAFE_INTEGER;\n        let x = Number(value);\n        x = censorNegativeZero(x);\n        if (!NumberIsFinite(x)) {\n            throw new TypeError(`${context} is not a finite number`);\n        }\n        x = integerPart(x);\n        if (x < lowerBound || x > upperBound) {\n            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n        }\n        if (!NumberIsFinite(x) || x === 0) {\n            return 0;\n        }\n        // TODO Use BigInt if supported?\n        // let xBigInt = BigInt(integerPart(x));\n        // xBigInt = BigInt.asUintN(64, xBigInt);\n        // return Number(xBigInt);\n        return x;\n    }\n    function assertReadableStream(x, context) {\n        if (!IsReadableStream(x)) {\n            throw new TypeError(`${context} is not a ReadableStream.`);\n        }\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamDefaultReader(stream) {\n        return new ReadableStreamDefaultReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadRequest(stream, readRequest) {\n        stream._reader._readRequests.push(readRequest);\n    }\n    function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readRequest = reader._readRequests.shift();\n        if (done) {\n            readRequest._closeSteps();\n        } else {\n            readRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadRequests(stream) {\n        return stream._reader._readRequests.length;\n    }\n    function ReadableStreamHasDefaultReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamDefaultReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A default reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamDefaultReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamDefaultReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed,\n         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        /**\n         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n         *\n         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n         */ read() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                return promiseRejectedWith(defaultReaderBrandCheckException(\"read\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: ()=>resolvePromise({\n                        value: undefined,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamDefaultReaderRead(this, readRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamDefaultReader(this)) {\n                throw defaultReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            ReadableStreamDefaultReaderRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, \"cancel\");\n    setFunctionName(ReadableStreamDefaultReader.prototype.read, \"read\");\n    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, \"releaseLock\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamDefaultReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultReader;\n    }\n    function ReadableStreamDefaultReaderRead(reader, readRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            readRequest._closeSteps();\n        } else if (stream._state === \"errored\") {\n            readRequest._errorSteps(stream._storedError);\n        } else {\n            stream._readableStreamController[PullSteps](readRequest);\n        }\n    }\n    function ReadableStreamDefaultReaderRelease(reader) {\n        ReadableStreamReaderGenericRelease(reader);\n        const e = new TypeError(\"Reader was released\");\n        ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n    }\n    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {\n        const readRequests = reader._readRequests;\n        reader._readRequests = new SimpleQueue();\n        readRequests.forEach((readRequest)=>{\n            readRequest._errorSteps(e);\n        });\n    }\n    // Helper functions for the ReadableStreamDefaultReader.\n    function defaultReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n    }\n    /// <reference lib=\"es2018.asynciterable\" />\n    /* eslint-disable @typescript-eslint/no-empty-function */ const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);\n    /// <reference lib=\"es2018.asynciterable\" />\n    class ReadableStreamAsyncIteratorImpl {\n        constructor(reader, preventCancel){\n            this._ongoingPromise = undefined;\n            this._isFinished = false;\n            this._reader = reader;\n            this._preventCancel = preventCancel;\n        }\n        next() {\n            const nextSteps = ()=>this._nextSteps();\n            this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();\n            return this._ongoingPromise;\n        }\n        return(value) {\n            const returnSteps = ()=>this._returnSteps(value);\n            return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();\n        }\n        _nextSteps() {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value: undefined,\n                    done: true\n                });\n            }\n            const reader = this._reader;\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    this._ongoingPromise = undefined;\n                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                    // FIXME Is this a bug in the specification, or in the test?\n                    _queueMicrotask(()=>resolvePromise({\n                            value: chunk,\n                            done: false\n                        }));\n                },\n                _closeSteps: ()=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    resolvePromise({\n                        value: undefined,\n                        done: true\n                    });\n                },\n                _errorSteps: (reason)=>{\n                    this._ongoingPromise = undefined;\n                    this._isFinished = true;\n                    ReadableStreamReaderGenericRelease(reader);\n                    rejectPromise(reason);\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promise;\n        }\n        _returnSteps(value) {\n            if (this._isFinished) {\n                return Promise.resolve({\n                    value,\n                    done: true\n                });\n            }\n            this._isFinished = true;\n            const reader = this._reader;\n            if (!this._preventCancel) {\n                const result = ReadableStreamReaderGenericCancel(reader, value);\n                ReadableStreamReaderGenericRelease(reader);\n                return transformPromiseWith(result, ()=>({\n                        value,\n                        done: true\n                    }));\n            }\n            ReadableStreamReaderGenericRelease(reader);\n            return promiseResolvedWith({\n                value,\n                done: true\n            });\n        }\n    }\n    const ReadableStreamAsyncIteratorPrototype = {\n        next () {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"next\"));\n            }\n            return this._asyncIteratorImpl.next();\n        },\n        return (value) {\n            if (!IsReadableStreamAsyncIterator(this)) {\n                return promiseRejectedWith(streamAsyncIteratorBrandCheckException(\"return\"));\n            }\n            return this._asyncIteratorImpl.return(value);\n        }\n    };\n    if (AsyncIteratorPrototype !== undefined) {\n        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n        iterator._asyncIteratorImpl = impl;\n        return iterator;\n    }\n    function IsReadableStreamAsyncIterator(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_asyncIteratorImpl\")) {\n            return false;\n        }\n        try {\n            // noinspection SuspiciousTypeOfGuard\n            return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;\n        } catch (_a) {\n            return false;\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamAsyncIteratorBrandCheckException(name) {\n        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n    }\n    /// <reference lib=\"es2015.core\" />\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\n    const NumberIsNaN = Number.isNaN || function(x) {\n        // eslint-disable-next-line no-self-compare\n        return x !== x;\n    };\n    function CreateArrayFromList(elements) {\n        // We use arrays to represent lists, so this is basically a no-op.\n        // Do a slice though just in case we happen to depend on the unique-ness.\n        return elements.slice();\n    }\n    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n    }\n    let TransferArrayBuffer = (O)=>{\n        if (typeof O.transfer === \"function\") {\n            TransferArrayBuffer = (buffer)=>buffer.transfer();\n        } else if (typeof structuredClone === \"function\") {\n            TransferArrayBuffer = (buffer)=>structuredClone(buffer, {\n                    transfer: [\n                        buffer\n                    ]\n                });\n        } else {\n            // Not implemented correctly\n            TransferArrayBuffer = (buffer)=>buffer;\n        }\n        return TransferArrayBuffer(O);\n    };\n    let IsDetachedBuffer = (O)=>{\n        if (typeof O.detached === \"boolean\") {\n            IsDetachedBuffer = (buffer)=>buffer.detached;\n        } else {\n            // Not implemented correctly\n            IsDetachedBuffer = (buffer)=>buffer.byteLength === 0;\n        }\n        return IsDetachedBuffer(O);\n    };\n    function ArrayBufferSlice(buffer, begin, end) {\n        // ArrayBuffer.prototype.slice is not available on IE10\n        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice\n        if (buffer.slice) {\n            return buffer.slice(begin, end);\n        }\n        const length = end - begin;\n        const slice = new ArrayBuffer(length);\n        CopyDataBlockBytes(slice, 0, buffer, begin, length);\n        return slice;\n    }\n    function GetMethod(receiver, prop) {\n        const func = receiver[prop];\n        if (func === undefined || func === null) {\n            return undefined;\n        }\n        if (typeof func !== \"function\") {\n            throw new TypeError(`${String(prop)} is not a function`);\n        }\n        return func;\n    }\n    function CreateAsyncFromSyncIterator(syncIteratorRecord) {\n        // Instead of re-implementing CreateAsyncFromSyncIterator and %AsyncFromSyncIteratorPrototype%,\n        // we use yield* inside an async generator function to achieve the same result.\n        // Wrap the sync iterator inside a sync iterable, so we can use it with yield*.\n        const syncIterable = {\n            [SymbolPolyfill.iterator]: ()=>syncIteratorRecord.iterator\n        };\n        // Create an async generator function and immediately invoke it.\n        const asyncIterator = async function*() {\n            return yield* syncIterable;\n        }();\n        // Return as an async iterator record.\n        const nextMethod = asyncIterator.next;\n        return {\n            iterator: asyncIterator,\n            nextMethod,\n            done: false\n        };\n    }\n    function GetIterator(obj, hint = \"sync\", method) {\n        if (method === undefined) {\n            if (hint === \"async\") {\n                method = GetMethod(obj, SymbolPolyfill.asyncIterator);\n                if (method === undefined) {\n                    const syncMethod = GetMethod(obj, SymbolPolyfill.iterator);\n                    const syncIteratorRecord = GetIterator(obj, \"sync\", syncMethod);\n                    return CreateAsyncFromSyncIterator(syncIteratorRecord);\n                }\n            } else {\n                method = GetMethod(obj, SymbolPolyfill.iterator);\n            }\n        }\n        if (method === undefined) {\n            throw new TypeError(\"The object is not iterable\");\n        }\n        const iterator = reflectCall(method, obj, []);\n        if (!typeIsObject(iterator)) {\n            throw new TypeError(\"The iterator method must return an object\");\n        }\n        const nextMethod = iterator.next;\n        return {\n            iterator,\n            nextMethod,\n            done: false\n        };\n    }\n    function IteratorNext(iteratorRecord) {\n        const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);\n        if (!typeIsObject(result)) {\n            throw new TypeError(\"The iterator.next() method must return an object\");\n        }\n        return result;\n    }\n    function IteratorComplete(iterResult) {\n        return Boolean(iterResult.done);\n    }\n    function IteratorValue(iterResult) {\n        return iterResult.value;\n    }\n    function IsNonNegativeNumber(v) {\n        if (typeof v !== \"number\") {\n            return false;\n        }\n        if (NumberIsNaN(v)) {\n            return false;\n        }\n        if (v < 0) {\n            return false;\n        }\n        return true;\n    }\n    function CloneAsUint8Array(O) {\n        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);\n        return new Uint8Array(buffer);\n    }\n    function DequeueValue(container) {\n        const pair = container._queue.shift();\n        container._queueTotalSize -= pair.size;\n        if (container._queueTotalSize < 0) {\n            container._queueTotalSize = 0;\n        }\n        return pair.value;\n    }\n    function EnqueueValueWithSize(container, value, size) {\n        if (!IsNonNegativeNumber(size) || size === Infinity) {\n            throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n        }\n        container._queue.push({\n            value,\n            size\n        });\n        container._queueTotalSize += size;\n    }\n    function PeekQueueValue(container) {\n        const pair = container._queue.peek();\n        return pair.value;\n    }\n    function ResetQueue(container) {\n        container._queue = new SimpleQueue();\n        container._queueTotalSize = 0;\n    }\n    function isDataViewConstructor(ctor) {\n        return ctor === DataView;\n    }\n    function isDataView(view) {\n        return isDataViewConstructor(view.constructor);\n    }\n    function arrayBufferViewElementSize(ctor) {\n        if (isDataViewConstructor(ctor)) {\n            return 1;\n        }\n        return ctor.BYTES_PER_ELEMENT;\n    }\n    /**\n     * A pull-into request in a {@link ReadableByteStreamController}.\n     *\n     * @public\n     */ class ReadableStreamBYOBRequest {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n         */ get view() {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"view\");\n            }\n            return this._view;\n        }\n        respond(bytesWritten) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respond\");\n            }\n            assertRequiredArgument(bytesWritten, 1, \"respond\");\n            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, \"First parameter\");\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(this._view.buffer)) {\n                throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);\n            }\n            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n        }\n        respondWithNewView(view) {\n            if (!IsReadableStreamBYOBRequest(this)) {\n                throw byobRequestBrandCheckException(\"respondWithNewView\");\n            }\n            assertRequiredArgument(view, 1, \"respondWithNewView\");\n            if (!ArrayBuffer.isView(view)) {\n                throw new TypeError(\"You can only respond with array buffer views\");\n            }\n            if (this._associatedReadableByteStreamController === undefined) {\n                throw new TypeError(\"This BYOB request has been invalidated\");\n            }\n            if (IsDetachedBuffer(view.buffer)) {\n                throw new TypeError(\"The given view's buffer has been detached and so cannot be used as a response\");\n            }\n            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {\n        respond: {\n            enumerable: true\n        },\n        respondWithNewView: {\n            enumerable: true\n        },\n        view: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, \"respond\");\n    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, \"respondWithNewView\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBRequest\",\n            configurable: true\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableByteStreamController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the current BYOB pull request, or `null` if there isn't one.\n         */ get byobRequest() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"byobRequest\");\n            }\n            return ReadableByteStreamControllerGetBYOBRequest(this);\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"desiredSize\");\n            }\n            return ReadableByteStreamControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"close\");\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"The stream has already been closed; do not close it again!\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n            }\n            ReadableByteStreamControllerClose(this);\n        }\n        enqueue(chunk) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"enqueue\");\n            }\n            assertRequiredArgument(chunk, 1, \"enqueue\");\n            if (!ArrayBuffer.isView(chunk)) {\n                throw new TypeError(\"chunk must be an array buffer view\");\n            }\n            if (chunk.byteLength === 0) {\n                throw new TypeError(\"chunk must have non-zero byteLength\");\n            }\n            if (chunk.buffer.byteLength === 0) {\n                throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n            }\n            if (this._closeRequested) {\n                throw new TypeError(\"stream is closed or draining\");\n            }\n            const state = this._controlledReadableByteStream._state;\n            if (state !== \"readable\") {\n                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n            }\n            ReadableByteStreamControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableByteStreamController(this)) {\n                throw byteStreamControllerBrandCheckException(\"error\");\n            }\n            ReadableByteStreamControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ReadableByteStreamControllerClearPendingPullIntos(this);\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableByteStreamControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableByteStream;\n            if (this._queueTotalSize > 0) {\n                ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);\n                return;\n            }\n            const autoAllocateChunkSize = this._autoAllocateChunkSize;\n            if (autoAllocateChunkSize !== undefined) {\n                let buffer;\n                try {\n                    buffer = new ArrayBuffer(autoAllocateChunkSize);\n                } catch (bufferE) {\n                    readRequest._errorSteps(bufferE);\n                    return;\n                }\n                const pullIntoDescriptor = {\n                    buffer,\n                    bufferByteLength: autoAllocateChunkSize,\n                    byteOffset: 0,\n                    byteLength: autoAllocateChunkSize,\n                    bytesFilled: 0,\n                    minimumFill: 1,\n                    elementSize: 1,\n                    viewConstructor: Uint8Array,\n                    readerType: \"default\"\n                };\n                this._pendingPullIntos.push(pullIntoDescriptor);\n            }\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableByteStreamControllerCallPullIfNeeded(this);\n        }\n        /** @internal */ [ReleaseSteps]() {\n            if (this._pendingPullIntos.length > 0) {\n                const firstPullInto = this._pendingPullIntos.peek();\n                firstPullInto.readerType = \"none\";\n                this._pendingPullIntos = new SimpleQueue();\n                this._pendingPullIntos.push(firstPullInto);\n            }\n        }\n    }\n    Object.defineProperties(ReadableByteStreamController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        byobRequest: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableByteStreamController.prototype.close, \"close\");\n    setFunctionName(ReadableByteStreamController.prototype.enqueue, \"enqueue\");\n    setFunctionName(ReadableByteStreamController.prototype.error, \"error\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableByteStreamController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableByteStreamController.\n    function IsReadableByteStreamController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableByteStream\")) {\n            return false;\n        }\n        return x instanceof ReadableByteStreamController;\n    }\n    function IsReadableStreamBYOBRequest(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_associatedReadableByteStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBRequest;\n    }\n    function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        // TODO: Test controller argument\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableByteStreamControllerCallPullIfNeeded(controller);\n            }\n            return null;\n        }, (e)=>{\n            ReadableByteStreamControllerError(controller, e);\n            return null;\n        });\n    }\n    function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        controller._pendingPullIntos = new SimpleQueue();\n    }\n    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n        let done = false;\n        if (stream._state === \"closed\") {\n            done = true;\n        }\n        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"default\") {\n            ReadableStreamFulfillReadRequest(stream, filledView, done);\n        } else {\n            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n        }\n    }\n    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n        const bytesFilled = pullIntoDescriptor.bytesFilled;\n        const elementSize = pullIntoDescriptor.elementSize;\n        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n    }\n    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        controller._queue.push({\n            buffer,\n            byteOffset,\n            byteLength\n        });\n        controller._queueTotalSize += byteLength;\n    }\n    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {\n        let clonedChunk;\n        try {\n            clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);\n        } catch (cloneE) {\n            ReadableByteStreamControllerError(controller, cloneE);\n            throw cloneE;\n        }\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);\n    }\n    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {\n        if (firstDescriptor.bytesFilled > 0) {\n            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n    }\n    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n        let totalBytesToCopyRemaining = maxBytesToCopy;\n        let ready = false;\n        const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;\n        const maxAlignedBytes = maxBytesFilled - remainderBytes;\n        // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n        // of the queue, so the underlying source can keep filling it.\n        if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {\n            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n            ready = true;\n        }\n        const queue = controller._queue;\n        while(totalBytesToCopyRemaining > 0){\n            const headOfQueue = queue.peek();\n            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n            if (headOfQueue.byteLength === bytesToCopy) {\n                queue.shift();\n            } else {\n                headOfQueue.byteOffset += bytesToCopy;\n                headOfQueue.byteLength -= bytesToCopy;\n            }\n            controller._queueTotalSize -= bytesToCopy;\n            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n            totalBytesToCopyRemaining -= bytesToCopy;\n        }\n        return ready;\n    }\n    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n        pullIntoDescriptor.bytesFilled += size;\n    }\n    function ReadableByteStreamControllerHandleQueueDrain(controller) {\n        if (controller._queueTotalSize === 0 && controller._closeRequested) {\n            ReadableByteStreamControllerClearAlgorithms(controller);\n            ReadableStreamClose(controller._controlledReadableByteStream);\n        } else {\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }\n    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n        if (controller._byobRequest === null) {\n            return;\n        }\n        controller._byobRequest._associatedReadableByteStreamController = undefined;\n        controller._byobRequest._view = null;\n        controller._byobRequest = null;\n    }\n    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n        while(controller._pendingPullIntos.length > 0){\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const pullIntoDescriptor = controller._pendingPullIntos.peek();\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {\n        const reader = controller._controlledReadableByteStream._reader;\n        while(reader._readRequests.length > 0){\n            if (controller._queueTotalSize === 0) {\n                return;\n            }\n            const readRequest = reader._readRequests.shift();\n            ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);\n        }\n    }\n    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {\n        const stream = controller._controlledReadableByteStream;\n        const ctor = view.constructor;\n        const elementSize = arrayBufferViewElementSize(ctor);\n        const { byteOffset, byteLength } = view;\n        const minimumFill = min * elementSize;\n        let buffer;\n        try {\n            buffer = TransferArrayBuffer(view.buffer);\n        } catch (e) {\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n        const pullIntoDescriptor = {\n            buffer,\n            bufferByteLength: buffer.byteLength,\n            byteOffset,\n            byteLength,\n            bytesFilled: 0,\n            minimumFill,\n            elementSize,\n            viewConstructor: ctor,\n            readerType: \"byob\"\n        };\n        if (controller._pendingPullIntos.length > 0) {\n            controller._pendingPullIntos.push(pullIntoDescriptor);\n            // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n            // - No change happens on desiredSize\n            // - The source has already been notified of that there's at least 1 pending read(view)\n            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n            return;\n        }\n        if (stream._state === \"closed\") {\n            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n            readIntoRequest._closeSteps(emptyView);\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n                ReadableByteStreamControllerHandleQueueDrain(controller);\n                readIntoRequest._chunkSteps(filledView);\n                return;\n            }\n            if (controller._closeRequested) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                readIntoRequest._errorSteps(e);\n                return;\n            }\n        }\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n        if (firstDescriptor.readerType === \"none\") {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n        }\n        const stream = controller._controlledReadableByteStream;\n        if (ReadableStreamHasBYOBReader(stream)) {\n            while(ReadableStreamGetNumReadIntoRequests(stream) > 0){\n                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n            }\n        }\n    }\n    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n        if (pullIntoDescriptor.readerType === \"none\") {\n            ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n            return;\n        }\n        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {\n            // A descriptor for a read() request that is not yet filled up to its minimum length will stay at the head\n            // of the queue, so the underlying source can keep filling it.\n            return;\n        }\n        ReadableByteStreamControllerShiftPendingPullInto(controller);\n        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n        if (remainderSize > 0) {\n            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n            ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);\n        }\n        pullIntoDescriptor.bytesFilled -= remainderSize;\n        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n        } else {\n            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n        const descriptor = controller._pendingPullIntos.shift();\n        return descriptor;\n    }\n    function ReadableByteStreamControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return false;\n        }\n        if (controller._closeRequested) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableByteStreamControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    // A client of ReadableByteStreamController may use these functions directly to bypass state check.\n    function ReadableByteStreamControllerClose(controller) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        if (controller._queueTotalSize > 0) {\n            controller._closeRequested = true;\n            return;\n        }\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {\n                const e = new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n                ReadableByteStreamControllerError(controller, e);\n                throw e;\n            }\n        }\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n    function ReadableByteStreamControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledReadableByteStream;\n        if (controller._closeRequested || stream._state !== \"readable\") {\n            return;\n        }\n        const { buffer, byteOffset, byteLength } = chunk;\n        if (IsDetachedBuffer(buffer)) {\n            throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n        }\n        const transferredBuffer = TransferArrayBuffer(buffer);\n        if (controller._pendingPullIntos.length > 0) {\n            const firstPendingPullInto = controller._pendingPullIntos.peek();\n            if (IsDetachedBuffer(firstPendingPullInto.buffer)) {\n                throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk\");\n            }\n            ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);\n            if (firstPendingPullInto.readerType === \"none\") {\n                ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);\n            }\n        }\n        if (ReadableStreamHasDefaultReader(stream)) {\n            ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);\n            if (ReadableStreamGetNumReadRequests(stream) === 0) {\n                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            } else {\n                if (controller._pendingPullIntos.length > 0) {\n                    ReadableByteStreamControllerShiftPendingPullInto(controller);\n                }\n                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n                ReadableStreamFulfillReadRequest(stream, transferredView, false);\n            }\n        } else if (ReadableStreamHasBYOBReader(stream)) {\n            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n        } else {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n    function ReadableByteStreamControllerError(controller, e) {\n        const stream = controller._controlledReadableByteStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ReadableByteStreamControllerClearPendingPullIntos(controller);\n        ResetQueue(controller);\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {\n        const entry = controller._queue.shift();\n        controller._queueTotalSize -= entry.byteLength;\n        ReadableByteStreamControllerHandleQueueDrain(controller);\n        const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n        readRequest._chunkSteps(view);\n    }\n    function ReadableByteStreamControllerGetBYOBRequest(controller) {\n        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {\n            const firstDescriptor = controller._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);\n            controller._byobRequest = byobRequest;\n        }\n        return controller._byobRequest;\n    }\n    function ReadableByteStreamControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (bytesWritten !== 0) {\n                throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n            }\n        } else {\n            if (bytesWritten === 0) {\n                throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n            }\n            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {\n                throw new RangeError(\"bytesWritten out of range\");\n            }\n        }\n        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n    }\n    function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n        const firstDescriptor = controller._pendingPullIntos.peek();\n        const state = controller._controlledReadableByteStream._state;\n        if (state === \"closed\") {\n            if (view.byteLength !== 0) {\n                throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n            }\n        } else {\n            if (view.byteLength === 0) {\n                throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n            }\n        }\n        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n            throw new RangeError(\"The region specified by view does not match byobRequest\");\n        }\n        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {\n            throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n        }\n        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {\n            throw new RangeError(\"The region specified by view is larger than byobRequest\");\n        }\n        const viewByteLength = view.byteLength;\n        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);\n        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);\n    }\n    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n        controller._controlledReadableByteStream = stream;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._byobRequest = null;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._closeRequested = false;\n        controller._started = false;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._autoAllocateChunkSize = autoAllocateChunkSize;\n        controller._pendingPullIntos = new SimpleQueue();\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n            return null;\n        }, (r)=>{\n            ReadableByteStreamControllerError(controller, r);\n            return null;\n        });\n    }\n    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        let startAlgorithm;\n        let pullAlgorithm;\n        let cancelAlgorithm;\n        if (underlyingByteSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingByteSource.start(controller);\n        } else {\n            startAlgorithm = ()=>undefined;\n        }\n        if (underlyingByteSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingByteSource.pull(controller);\n        } else {\n            pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingByteSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingByteSource.cancel(reason);\n        } else {\n            cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n        if (autoAllocateChunkSize === 0) {\n            throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        }\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n    }\n    function SetUpReadableStreamBYOBRequest(request, controller, view) {\n        request._associatedReadableByteStreamController = controller;\n        request._view = view;\n    }\n    // Helper functions for the ReadableStreamBYOBRequest.\n    function byobRequestBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n    }\n    // Helper functions for the ReadableByteStreamController.\n    function byteStreamControllerBrandCheckException(name) {\n        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n    }\n    function convertReaderOptions(options, context) {\n        assertDictionary(options, context);\n        const mode = options === null || options === void 0 ? void 0 : options.mode;\n        return {\n            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n        };\n    }\n    function convertReadableStreamReaderMode(mode, context) {\n        mode = `${mode}`;\n        if (mode !== \"byob\") {\n            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n        }\n        return mode;\n    }\n    function convertByobReadOptions(options, context) {\n        var _a;\n        assertDictionary(options, context);\n        const min = (_a = options === null || options === void 0 ? void 0 : options.min) !== null && _a !== void 0 ? _a : 1;\n        return {\n            min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)\n        };\n    }\n    // Abstract operations for the ReadableStream.\n    function AcquireReadableStreamBYOBReader(stream) {\n        return new ReadableStreamBYOBReader(stream);\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n        stream._reader._readIntoRequests.push(readIntoRequest);\n    }\n    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n        const reader = stream._reader;\n        const readIntoRequest = reader._readIntoRequests.shift();\n        if (done) {\n            readIntoRequest._closeSteps(chunk);\n        } else {\n            readIntoRequest._chunkSteps(chunk);\n        }\n    }\n    function ReadableStreamGetNumReadIntoRequests(stream) {\n        return stream._reader._readIntoRequests.length;\n    }\n    function ReadableStreamHasBYOBReader(stream) {\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return false;\n        }\n        if (!IsReadableStreamBYOBReader(reader)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A BYOB reader vended by a {@link ReadableStream}.\n     *\n     * @public\n     */ class ReadableStreamBYOBReader {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"ReadableStreamBYOBReader\");\n            assertReadableStream(stream, \"First parameter\");\n            if (IsReadableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n            }\n            if (!IsReadableByteStreamController(stream._readableStreamController)) {\n                throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte \" + \"source\");\n            }\n            ReadableStreamReaderGenericInitialize(this, stream);\n            this._readIntoRequests = new SimpleQueue();\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the reader's lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"cancel\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"cancel\"));\n            }\n            return ReadableStreamReaderGenericCancel(this, reason);\n        }\n        read(view, rawOptions = {}) {\n            if (!IsReadableStreamBYOBReader(this)) {\n                return promiseRejectedWith(byobReaderBrandCheckException(\"read\"));\n            }\n            if (!ArrayBuffer.isView(view)) {\n                return promiseRejectedWith(new TypeError(\"view must be an array buffer view\"));\n            }\n            if (view.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(\"view must have non-zero byteLength\"));\n            }\n            if (view.buffer.byteLength === 0) {\n                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n            }\n            if (IsDetachedBuffer(view.buffer)) {\n                return promiseRejectedWith(new TypeError(\"view's buffer has been detached\"));\n            }\n            let options;\n            try {\n                options = convertByobReadOptions(rawOptions, \"options\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            const min = options.min;\n            if (min === 0) {\n                return promiseRejectedWith(new TypeError(\"options.min must be greater than 0\"));\n            }\n            if (!isDataView(view)) {\n                if (min > view.length) {\n                    return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's length\"));\n                }\n            } else if (min > view.byteLength) {\n                return promiseRejectedWith(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n            }\n            if (this._ownerReadableStream === undefined) {\n                return promiseRejectedWith(readerLockException(\"read from\"));\n            }\n            let resolvePromise;\n            let rejectPromise;\n            const promise = newPromise((resolve, reject)=>{\n                resolvePromise = resolve;\n                rejectPromise = reject;\n            });\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: false\n                    }),\n                _closeSteps: (chunk)=>resolvePromise({\n                        value: chunk,\n                        done: true\n                    }),\n                _errorSteps: (e)=>rejectPromise(e)\n            };\n            ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);\n            return promise;\n        }\n        /**\n         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n         * from now on; otherwise, the reader will appear closed.\n         *\n         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n         * do so will throw a `TypeError` and leave the reader locked to the stream.\n         */ releaseLock() {\n            if (!IsReadableStreamBYOBReader(this)) {\n                throw byobReaderBrandCheckException(\"releaseLock\");\n            }\n            if (this._ownerReadableStream === undefined) {\n                return;\n            }\n            ReadableStreamBYOBReaderRelease(this);\n        }\n    }\n    Object.defineProperties(ReadableStreamBYOBReader.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        read: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, \"cancel\");\n    setFunctionName(ReadableStreamBYOBReader.prototype.read, \"read\");\n    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, \"releaseLock\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamBYOBReader\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the readers.\n    function IsReadableStreamBYOBReader(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readIntoRequests\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamBYOBReader;\n    }\n    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {\n        const stream = reader._ownerReadableStream;\n        stream._disturbed = true;\n        if (stream._state === \"errored\") {\n            readIntoRequest._errorSteps(stream._storedError);\n        } else {\n            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);\n        }\n    }\n    function ReadableStreamBYOBReaderRelease(reader) {\n        ReadableStreamReaderGenericRelease(reader);\n        const e = new TypeError(\"Reader was released\");\n        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n    }\n    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {\n        const readIntoRequests = reader._readIntoRequests;\n        reader._readIntoRequests = new SimpleQueue();\n        readIntoRequests.forEach((readIntoRequest)=>{\n            readIntoRequest._errorSteps(e);\n        });\n    }\n    // Helper functions for the ReadableStreamBYOBReader.\n    function byobReaderBrandCheckException(name) {\n        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n    }\n    function ExtractHighWaterMark(strategy, defaultHWM) {\n        const { highWaterMark } = strategy;\n        if (highWaterMark === undefined) {\n            return defaultHWM;\n        }\n        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n            throw new RangeError(\"Invalid highWaterMark\");\n        }\n        return highWaterMark;\n    }\n    function ExtractSizeAlgorithm(strategy) {\n        const { size } = strategy;\n        if (!size) {\n            return ()=>1;\n        }\n        return size;\n    }\n    function convertQueuingStrategy(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        const size = init === null || init === void 0 ? void 0 : init.size;\n        return {\n            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n        };\n    }\n    function convertQueuingStrategySize(fn, context) {\n        assertFunction(fn, context);\n        return (chunk)=>convertUnrestrictedDouble(fn(chunk));\n    }\n    function convertUnderlyingSink(original, context) {\n        assertDictionary(original, context);\n        const abort = original === null || original === void 0 ? void 0 : original.abort;\n        const close = original === null || original === void 0 ? void 0 : original.close;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        const write = original === null || original === void 0 ? void 0 : original.write;\n        return {\n            abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n            close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n            start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n            write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n            type\n        };\n    }\n    function convertUnderlyingSinkAbortCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSinkCloseCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return ()=>promiseCall(fn, original, []);\n    }\n    function convertUnderlyingSinkStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSinkWriteCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    function assertWritableStream(x, context) {\n        if (!IsWritableStream(x)) {\n            throw new TypeError(`${context} is not a WritableStream.`);\n        }\n    }\n    function isAbortSignal(value) {\n        if (typeof value !== \"object\" || value === null) {\n            return false;\n        }\n        try {\n            return typeof value.aborted === \"boolean\";\n        } catch (_a) {\n            // AbortSignal.prototype.aborted throws if its brand check fails\n            return false;\n        }\n    }\n    const supportsAbortController = typeof AbortController === \"function\";\n    /**\n     * Construct a new AbortController, if supported by the platform.\n     *\n     * @internal\n     */ function createAbortController() {\n        if (supportsAbortController) {\n            return new AbortController();\n        }\n        return undefined;\n    }\n    /**\n     * A writable stream represents a destination for data, into which you can write.\n     *\n     * @public\n     */ class WritableStream {\n        constructor(rawUnderlyingSink = {}, rawStrategy = {}){\n            if (rawUnderlyingSink === undefined) {\n                rawUnderlyingSink = null;\n            } else {\n                assertObject(rawUnderlyingSink, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, \"First parameter\");\n            InitializeWritableStream(this);\n            const type = underlyingSink.type;\n            if (type !== undefined) {\n                throw new RangeError(\"Invalid type is specified\");\n            }\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n        }\n        /**\n         * Returns whether or not the writable stream is locked to a writer.\n         */ get locked() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"locked\");\n            }\n            return IsWritableStreamLocked(this);\n        }\n        /**\n         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n         * mechanism of the underlying sink.\n         *\n         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n         * the stream) if the stream is currently locked.\n         */ abort(reason = undefined) {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"abort\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot abort a stream that already has a writer\"));\n            }\n            return WritableStreamAbort(this, reason);\n        }\n        /**\n         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n         * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n         *\n         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n         */ close() {\n            if (!IsWritableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$2(\"close\"));\n            }\n            if (IsWritableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close a stream that already has a writer\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamClose(this);\n        }\n        /**\n         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n         * is locked, no other writer can be acquired until this one is released.\n         *\n         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n         * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n         */ getWriter() {\n            if (!IsWritableStream(this)) {\n                throw streamBrandCheckException$2(\"getWriter\");\n            }\n            return AcquireWritableStreamDefaultWriter(this);\n        }\n    }\n    Object.defineProperties(WritableStream.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        getWriter: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    setFunctionName(WritableStream.prototype.abort, \"abort\");\n    setFunctionName(WritableStream.prototype.close, \"close\");\n    setFunctionName(WritableStream.prototype.getWriter, \"getWriter\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStream\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStream.\n    function AcquireWritableStreamDefaultWriter(stream) {\n        return new WritableStreamDefaultWriter(stream);\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(WritableStream.prototype);\n        InitializeWritableStream(stream);\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    function InitializeWritableStream(stream) {\n        stream._state = \"writable\";\n        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n        // 'erroring' or 'errored'. May be set to an undefined value.\n        stream._storedError = undefined;\n        stream._writer = undefined;\n        // Initialize to undefined first because the constructor of the controller checks this\n        // variable to validate the caller.\n        stream._writableStreamController = undefined;\n        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n        // producer without waiting for the queued writes to finish.\n        stream._writeRequests = new SimpleQueue();\n        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n        stream._inFlightWriteRequest = undefined;\n        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n        // has been detached.\n        stream._closeRequest = undefined;\n        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n        stream._inFlightCloseRequest = undefined;\n        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n        stream._pendingAbortRequest = undefined;\n        // The backpressure signal set by the controller.\n        stream._backpressure = false;\n    }\n    function IsWritableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_writableStreamController\")) {\n            return false;\n        }\n        return x instanceof WritableStream;\n    }\n    function IsWritableStreamLocked(stream) {\n        if (stream._writer === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamAbort(stream, reason) {\n        var _a;\n        if (stream._state === \"closed\" || stream._state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        stream._writableStreamController._abortReason = reason;\n        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(reason);\n        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',\n        // but it doesn't know that signaling abort runs author code that might have changed the state.\n        // Widen the type again by casting to WritableStreamState.\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._pendingAbortRequest !== undefined) {\n            return stream._pendingAbortRequest._promise;\n        }\n        let wasAlreadyErroring = false;\n        if (state === \"erroring\") {\n            wasAlreadyErroring = true;\n            // reason will not be used, so don't keep a reference to it.\n            reason = undefined;\n        }\n        const promise = newPromise((resolve, reject)=>{\n            stream._pendingAbortRequest = {\n                _promise: undefined,\n                _resolve: resolve,\n                _reject: reject,\n                _reason: reason,\n                _wasAlreadyErroring: wasAlreadyErroring\n            };\n        });\n        stream._pendingAbortRequest._promise = promise;\n        if (!wasAlreadyErroring) {\n            WritableStreamStartErroring(stream, reason);\n        }\n        return promise;\n    }\n    function WritableStreamClose(stream) {\n        const state = stream._state;\n        if (state === \"closed\" || state === \"errored\") {\n            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n        }\n        const promise = newPromise((resolve, reject)=>{\n            const closeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._closeRequest = closeRequest;\n        });\n        const writer = stream._writer;\n        if (writer !== undefined && stream._backpressure && state === \"writable\") {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n        WritableStreamDefaultControllerClose(stream._writableStreamController);\n        return promise;\n    }\n    // WritableStream API exposed for controllers.\n    function WritableStreamAddWriteRequest(stream) {\n        const promise = newPromise((resolve, reject)=>{\n            const writeRequest = {\n                _resolve: resolve,\n                _reject: reject\n            };\n            stream._writeRequests.push(writeRequest);\n        });\n        return promise;\n    }\n    function WritableStreamDealWithRejection(stream, error) {\n        const state = stream._state;\n        if (state === \"writable\") {\n            WritableStreamStartErroring(stream, error);\n            return;\n        }\n        WritableStreamFinishErroring(stream);\n    }\n    function WritableStreamStartErroring(stream, reason) {\n        const controller = stream._writableStreamController;\n        stream._state = \"erroring\";\n        stream._storedError = reason;\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n        }\n        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n            WritableStreamFinishErroring(stream);\n        }\n    }\n    function WritableStreamFinishErroring(stream) {\n        stream._state = \"errored\";\n        stream._writableStreamController[ErrorSteps]();\n        const storedError = stream._storedError;\n        stream._writeRequests.forEach((writeRequest)=>{\n            writeRequest._reject(storedError);\n        });\n        stream._writeRequests = new SimpleQueue();\n        if (stream._pendingAbortRequest === undefined) {\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const abortRequest = stream._pendingAbortRequest;\n        stream._pendingAbortRequest = undefined;\n        if (abortRequest._wasAlreadyErroring) {\n            abortRequest._reject(storedError);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return;\n        }\n        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n        uponPromise(promise, ()=>{\n            abortRequest._resolve();\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return null;\n        }, (reason)=>{\n            abortRequest._reject(reason);\n            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n            return null;\n        });\n    }\n    function WritableStreamFinishInFlightWrite(stream) {\n        stream._inFlightWriteRequest._resolve(undefined);\n        stream._inFlightWriteRequest = undefined;\n    }\n    function WritableStreamFinishInFlightWriteWithError(stream, error) {\n        stream._inFlightWriteRequest._reject(error);\n        stream._inFlightWriteRequest = undefined;\n        WritableStreamDealWithRejection(stream, error);\n    }\n    function WritableStreamFinishInFlightClose(stream) {\n        stream._inFlightCloseRequest._resolve(undefined);\n        stream._inFlightCloseRequest = undefined;\n        const state = stream._state;\n        if (state === \"erroring\") {\n            // The error was too late to do anything, so it is ignored.\n            stream._storedError = undefined;\n            if (stream._pendingAbortRequest !== undefined) {\n                stream._pendingAbortRequest._resolve();\n                stream._pendingAbortRequest = undefined;\n            }\n        }\n        stream._state = \"closed\";\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseResolve(writer);\n        }\n    }\n    function WritableStreamFinishInFlightCloseWithError(stream, error) {\n        stream._inFlightCloseRequest._reject(error);\n        stream._inFlightCloseRequest = undefined;\n        // Never execute sink abort() after sink close().\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._reject(error);\n            stream._pendingAbortRequest = undefined;\n        }\n        WritableStreamDealWithRejection(stream, error);\n    }\n    // TODO(ricea): Fix alphabetical order.\n    function WritableStreamCloseQueuedOrInFlight(stream) {\n        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamHasOperationMarkedInFlight(stream) {\n        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n            return false;\n        }\n        return true;\n    }\n    function WritableStreamMarkCloseRequestInFlight(stream) {\n        stream._inFlightCloseRequest = stream._closeRequest;\n        stream._closeRequest = undefined;\n    }\n    function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n        stream._inFlightWriteRequest = stream._writeRequests.shift();\n    }\n    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n        if (stream._closeRequest !== undefined) {\n            stream._closeRequest._reject(stream._storedError);\n            stream._closeRequest = undefined;\n        }\n        const writer = stream._writer;\n        if (writer !== undefined) {\n            defaultWriterClosedPromiseReject(writer, stream._storedError);\n        }\n    }\n    function WritableStreamUpdateBackpressure(stream, backpressure) {\n        const writer = stream._writer;\n        if (writer !== undefined && backpressure !== stream._backpressure) {\n            if (backpressure) {\n                defaultWriterReadyPromiseReset(writer);\n            } else {\n                defaultWriterReadyPromiseResolve(writer);\n            }\n        }\n        stream._backpressure = backpressure;\n    }\n    /**\n     * A default writer vended by a {@link WritableStream}.\n     *\n     * @public\n     */ class WritableStreamDefaultWriter {\n        constructor(stream){\n            assertRequiredArgument(stream, 1, \"WritableStreamDefaultWriter\");\n            assertWritableStream(stream, \"First parameter\");\n            if (IsWritableStreamLocked(stream)) {\n                throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n            }\n            this._ownerWritableStream = stream;\n            stream._writer = this;\n            const state = stream._state;\n            if (state === \"writable\") {\n                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                    defaultWriterReadyPromiseInitialize(this);\n                } else {\n                    defaultWriterReadyPromiseInitializeAsResolved(this);\n                }\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"erroring\") {\n                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n                defaultWriterClosedPromiseInitialize(this);\n            } else if (state === \"closed\") {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n                defaultWriterClosedPromiseInitializeAsResolved(this);\n            } else {\n                const storedError = stream._storedError;\n                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n            }\n        }\n        /**\n         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n         * the writer’s lock is released before the stream finishes closing.\n         */ get closed() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"closed\"));\n            }\n            return this._closedPromise;\n        }\n        /**\n         * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n         * A producer can use this information to determine the right amount of data to write.\n         *\n         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n         * the writer’s lock is released.\n         */ get desiredSize() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"desiredSize\");\n            }\n            if (this._ownerWritableStream === undefined) {\n                throw defaultWriterLockException(\"desiredSize\");\n            }\n            return WritableStreamDefaultWriterGetDesiredSize(this);\n        }\n        /**\n         * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n         * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n         *\n         * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n         * rejected.\n         */ get ready() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"ready\"));\n            }\n            return this._readyPromise;\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n         */ abort(reason = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"abort\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"abort\"));\n            }\n            return WritableStreamDefaultWriterAbort(this, reason);\n        }\n        /**\n         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n         */ close() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"close\"));\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"close\"));\n            }\n            if (WritableStreamCloseQueuedOrInFlight(stream)) {\n                return promiseRejectedWith(new TypeError(\"Cannot close an already-closing stream\"));\n            }\n            return WritableStreamDefaultWriterClose(this);\n        }\n        /**\n         * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n         * now on; otherwise, the writer will appear closed.\n         *\n         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n         * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n         * other producers from writing in an interleaved manner.\n         */ releaseLock() {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                throw defaultWriterBrandCheckException(\"releaseLock\");\n            }\n            const stream = this._ownerWritableStream;\n            if (stream === undefined) {\n                return;\n            }\n            WritableStreamDefaultWriterRelease(this);\n        }\n        write(chunk = undefined) {\n            if (!IsWritableStreamDefaultWriter(this)) {\n                return promiseRejectedWith(defaultWriterBrandCheckException(\"write\"));\n            }\n            if (this._ownerWritableStream === undefined) {\n                return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n            }\n            return WritableStreamDefaultWriterWrite(this, chunk);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultWriter.prototype, {\n        abort: {\n            enumerable: true\n        },\n        close: {\n            enumerable: true\n        },\n        releaseLock: {\n            enumerable: true\n        },\n        write: {\n            enumerable: true\n        },\n        closed: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        },\n        ready: {\n            enumerable: true\n        }\n    });\n    setFunctionName(WritableStreamDefaultWriter.prototype.abort, \"abort\");\n    setFunctionName(WritableStreamDefaultWriter.prototype.close, \"close\");\n    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, \"releaseLock\");\n    setFunctionName(WritableStreamDefaultWriter.prototype.write, \"write\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultWriter\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the WritableStreamDefaultWriter.\n    function IsWritableStreamDefaultWriter(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_ownerWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultWriter;\n    }\n    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\n    function WritableStreamDefaultWriterAbort(writer, reason) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamAbort(stream, reason);\n    }\n    function WritableStreamDefaultWriterClose(writer) {\n        const stream = writer._ownerWritableStream;\n        return WritableStreamClose(stream);\n    }\n    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        return WritableStreamDefaultWriterClose(writer);\n    }\n    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n        if (writer._closedPromiseState === \"pending\") {\n            defaultWriterClosedPromiseReject(writer, error);\n        } else {\n            defaultWriterClosedPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n        if (writer._readyPromiseState === \"pending\") {\n            defaultWriterReadyPromiseReject(writer, error);\n        } else {\n            defaultWriterReadyPromiseResetToRejected(writer, error);\n        }\n    }\n    function WritableStreamDefaultWriterGetDesiredSize(writer) {\n        const stream = writer._ownerWritableStream;\n        const state = stream._state;\n        if (state === \"errored\" || state === \"erroring\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n    }\n    function WritableStreamDefaultWriterRelease(writer) {\n        const stream = writer._ownerWritableStream;\n        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n        // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n        // rejected until afterwards. This means that simply testing state will not work.\n        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n        stream._writer = undefined;\n        writer._ownerWritableStream = undefined;\n    }\n    function WritableStreamDefaultWriterWrite(writer, chunk) {\n        const stream = writer._ownerWritableStream;\n        const controller = stream._writableStreamController;\n        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n        if (stream !== writer._ownerWritableStream) {\n            return promiseRejectedWith(defaultWriterLockException(\"write to\"));\n        }\n        const state = stream._state;\n        if (state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream) || state === \"closed\") {\n            return promiseRejectedWith(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n        }\n        if (state === \"erroring\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        const promise = WritableStreamAddWriteRequest(stream);\n        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n        return promise;\n    }\n    const closeSentinel = {};\n    /**\n     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n     *\n     * @public\n     */ class WritableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.\n         *\n         * @deprecated\n         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.\n         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.\n         */ get abortReason() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"abortReason\");\n            }\n            return this._abortReason;\n        }\n        /**\n         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.\n         */ get signal() {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"signal\");\n            }\n            if (this._abortController === undefined) {\n                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.\n                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,\n                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.\n                throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n            }\n            return this._abortController.signal;\n        }\n        /**\n         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n         *\n         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n         * normal lifecycle of interactions with the underlying sink.\n         */ error(e = undefined) {\n            if (!IsWritableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$2(\"error\");\n            }\n            const state = this._controlledWritableStream._state;\n            if (state !== \"writable\") {\n                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n                // just treat it as a no-op.\n                return;\n            }\n            WritableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [AbortSteps](reason) {\n            const result = this._abortAlgorithm(reason);\n            WritableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [ErrorSteps]() {\n            ResetQueue(this);\n        }\n    }\n    Object.defineProperties(WritableStreamDefaultController.prototype, {\n        abortReason: {\n            enumerable: true\n        },\n        signal: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"WritableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations implementing interface required by the WritableStream.\n    function IsWritableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledWritableStream\")) {\n            return false;\n        }\n        return x instanceof WritableStreamDefaultController;\n    }\n    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledWritableStream = stream;\n        stream._writableStreamController = controller;\n        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._abortReason = undefined;\n        controller._abortController = createAbortController();\n        controller._started = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._writeAlgorithm = writeAlgorithm;\n        controller._closeAlgorithm = closeAlgorithm;\n        controller._abortAlgorithm = abortAlgorithm;\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n        const startResult = startAlgorithm();\n        const startPromise = promiseResolvedWith(startResult);\n        uponPromise(startPromise, ()=>{\n            controller._started = true;\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            return null;\n        }, (r)=>{\n            controller._started = true;\n            WritableStreamDealWithRejection(stream, r);\n            return null;\n        });\n    }\n    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(WritableStreamDefaultController.prototype);\n        let startAlgorithm;\n        let writeAlgorithm;\n        let closeAlgorithm;\n        let abortAlgorithm;\n        if (underlyingSink.start !== undefined) {\n            startAlgorithm = ()=>underlyingSink.start(controller);\n        } else {\n            startAlgorithm = ()=>undefined;\n        }\n        if (underlyingSink.write !== undefined) {\n            writeAlgorithm = (chunk)=>underlyingSink.write(chunk, controller);\n        } else {\n            writeAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingSink.close !== undefined) {\n            closeAlgorithm = ()=>underlyingSink.close();\n        } else {\n            closeAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingSink.abort !== undefined) {\n            abortAlgorithm = (reason)=>underlyingSink.abort(reason);\n        } else {\n            abortAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\n    function WritableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._writeAlgorithm = undefined;\n        controller._closeAlgorithm = undefined;\n        controller._abortAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    function WritableStreamDefaultControllerClose(controller) {\n        EnqueueValueWithSize(controller, closeSentinel, 0);\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n        try {\n            return controller._strategySizeAlgorithm(chunk);\n        } catch (chunkSizeE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n            return 1;\n        }\n    }\n    function WritableStreamDefaultControllerGetDesiredSize(controller) {\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        } catch (enqueueE) {\n            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n            return;\n        }\n        const stream = controller._controlledWritableStream;\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === \"writable\") {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }\n    // Abstract operations for the WritableStreamDefaultController.\n    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n        const stream = controller._controlledWritableStream;\n        if (!controller._started) {\n            return;\n        }\n        if (stream._inFlightWriteRequest !== undefined) {\n            return;\n        }\n        const state = stream._state;\n        if (state === \"erroring\") {\n            WritableStreamFinishErroring(stream);\n            return;\n        }\n        if (controller._queue.length === 0) {\n            return;\n        }\n        const value = PeekQueueValue(controller);\n        if (value === closeSentinel) {\n            WritableStreamDefaultControllerProcessClose(controller);\n        } else {\n            WritableStreamDefaultControllerProcessWrite(controller, value);\n        }\n    }\n    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n        if (controller._controlledWritableStream._state === \"writable\") {\n            WritableStreamDefaultControllerError(controller, error);\n        }\n    }\n    function WritableStreamDefaultControllerProcessClose(controller) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkCloseRequestInFlight(stream);\n        DequeueValue(controller);\n        const sinkClosePromise = controller._closeAlgorithm();\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(sinkClosePromise, ()=>{\n            WritableStreamFinishInFlightClose(stream);\n            return null;\n        }, (reason)=>{\n            WritableStreamFinishInFlightCloseWithError(stream, reason);\n            return null;\n        });\n    }\n    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamMarkFirstWriteRequestInFlight(stream);\n        const sinkWritePromise = controller._writeAlgorithm(chunk);\n        uponPromise(sinkWritePromise, ()=>{\n            WritableStreamFinishInFlightWrite(stream);\n            const state = stream._state;\n            DequeueValue(controller);\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === \"writable\") {\n                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n                WritableStreamUpdateBackpressure(stream, backpressure);\n            }\n            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n            return null;\n        }, (reason)=>{\n            if (stream._state === \"writable\") {\n                WritableStreamDefaultControllerClearAlgorithms(controller);\n            }\n            WritableStreamFinishInFlightWriteWithError(stream, reason);\n            return null;\n        });\n    }\n    function WritableStreamDefaultControllerGetBackpressure(controller) {\n        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n        return desiredSize <= 0;\n    }\n    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.\n    function WritableStreamDefaultControllerError(controller, error) {\n        const stream = controller._controlledWritableStream;\n        WritableStreamDefaultControllerClearAlgorithms(controller);\n        WritableStreamStartErroring(stream, error);\n    }\n    // Helper functions for the WritableStream.\n    function streamBrandCheckException$2(name) {\n        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n    }\n    // Helper functions for the WritableStreamDefaultController.\n    function defaultControllerBrandCheckException$2(name) {\n        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);\n    }\n    // Helper functions for the WritableStreamDefaultWriter.\n    function defaultWriterBrandCheckException(name) {\n        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n    }\n    function defaultWriterLockException(name) {\n        return new TypeError(\"Cannot \" + name + \" a stream using a released writer\");\n    }\n    function defaultWriterClosedPromiseInitialize(writer) {\n        writer._closedPromise = newPromise((resolve, reject)=>{\n            writer._closedPromise_resolve = resolve;\n            writer._closedPromise_reject = reject;\n            writer._closedPromiseState = \"pending\";\n        });\n    }\n    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseReject(writer, reason);\n    }\n    function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n        defaultWriterClosedPromiseInitialize(writer);\n        defaultWriterClosedPromiseResolve(writer);\n    }\n    function defaultWriterClosedPromiseReject(writer, reason) {\n        if (writer._closedPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._closedPromise);\n        writer._closedPromise_reject(reason);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"rejected\";\n    }\n    function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterClosedPromiseResolve(writer) {\n        if (writer._closedPromise_resolve === undefined) {\n            return;\n        }\n        writer._closedPromise_resolve(undefined);\n        writer._closedPromise_resolve = undefined;\n        writer._closedPromise_reject = undefined;\n        writer._closedPromiseState = \"resolved\";\n    }\n    function defaultWriterReadyPromiseInitialize(writer) {\n        writer._readyPromise = newPromise((resolve, reject)=>{\n            writer._readyPromise_resolve = resolve;\n            writer._readyPromise_reject = reject;\n        });\n        writer._readyPromiseState = \"pending\";\n    }\n    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseReject(writer, reason);\n    }\n    function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    function defaultWriterReadyPromiseReject(writer, reason) {\n        if (writer._readyPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(writer._readyPromise);\n        writer._readyPromise_reject(reason);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"rejected\";\n    }\n    function defaultWriterReadyPromiseReset(writer) {\n        defaultWriterReadyPromiseInitialize(writer);\n    }\n    function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n    }\n    function defaultWriterReadyPromiseResolve(writer) {\n        if (writer._readyPromise_resolve === undefined) {\n            return;\n        }\n        writer._readyPromise_resolve(undefined);\n        writer._readyPromise_resolve = undefined;\n        writer._readyPromise_reject = undefined;\n        writer._readyPromiseState = \"fulfilled\";\n    }\n    /// <reference lib=\"dom\" />\n    function getGlobals() {\n        if (typeof globalThis !== \"undefined\") {\n            return globalThis;\n        } else if (typeof self !== \"undefined\") {\n            return self;\n        } else if (typeof global !== \"undefined\") {\n            return global;\n        }\n        return undefined;\n    }\n    const globals = getGlobals();\n    /// <reference types=\"node\" />\n    function isDOMExceptionConstructor(ctor) {\n        if (!(typeof ctor === \"function\" || typeof ctor === \"object\")) {\n            return false;\n        }\n        if (ctor.name !== \"DOMException\") {\n            return false;\n        }\n        try {\n            new ctor();\n            return true;\n        } catch (_a) {\n            return false;\n        }\n    }\n    /**\n     * Support:\n     * - Web browsers\n     * - Node 18 and higher (https://github.com/nodejs/node/commit/e4b1fb5e6422c1ff151234bb9de792d45dd88d87)\n     */ function getFromGlobal() {\n        const ctor = globals === null || globals === void 0 ? void 0 : globals.DOMException;\n        return isDOMExceptionConstructor(ctor) ? ctor : undefined;\n    }\n    /**\n     * Support:\n     * - All platforms\n     */ function createPolyfill() {\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        const ctor = function DOMException(message, name) {\n            this.message = message || \"\";\n            this.name = name || \"Error\";\n            if (Error.captureStackTrace) {\n                Error.captureStackTrace(this, this.constructor);\n            }\n        };\n        setFunctionName(ctor, \"DOMException\");\n        ctor.prototype = Object.create(Error.prototype);\n        Object.defineProperty(ctor.prototype, \"constructor\", {\n            value: ctor,\n            writable: true,\n            configurable: true\n        });\n        return ctor;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-redeclare\n    const DOMException = getFromGlobal() || createPolyfill();\n    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n        const reader = AcquireReadableStreamDefaultReader(source);\n        const writer = AcquireWritableStreamDefaultWriter(dest);\n        source._disturbed = true;\n        let shuttingDown = false;\n        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n        let currentWrite = promiseResolvedWith(undefined);\n        return newPromise((resolve, reject)=>{\n            let abortAlgorithm;\n            if (signal !== undefined) {\n                abortAlgorithm = ()=>{\n                    const error = signal.reason !== undefined ? signal.reason : new DOMException(\"Aborted\", \"AbortError\");\n                    const actions = [];\n                    if (!preventAbort) {\n                        actions.push(()=>{\n                            if (dest._state === \"writable\") {\n                                return WritableStreamAbort(dest, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    if (!preventCancel) {\n                        actions.push(()=>{\n                            if (source._state === \"readable\") {\n                                return ReadableStreamCancel(source, error);\n                            }\n                            return promiseResolvedWith(undefined);\n                        });\n                    }\n                    shutdownWithAction(()=>Promise.all(actions.map((action)=>action())), true, error);\n                };\n                if (signal.aborted) {\n                    abortAlgorithm();\n                    return;\n                }\n                signal.addEventListener(\"abort\", abortAlgorithm);\n            }\n            // Using reader and writer, read all chunks from this and write them to dest\n            // - Backpressure must be enforced\n            // - Shutdown must stop all activity\n            function pipeLoop() {\n                return newPromise((resolveLoop, rejectLoop)=>{\n                    function next(done) {\n                        if (done) {\n                            resolveLoop();\n                        } else {\n                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                            PerformPromiseThen(pipeStep(), next, rejectLoop);\n                        }\n                    }\n                    next(false);\n                });\n            }\n            function pipeStep() {\n                if (shuttingDown) {\n                    return promiseResolvedWith(true);\n                }\n                return PerformPromiseThen(writer._readyPromise, ()=>{\n                    return newPromise((resolveRead, rejectRead)=>{\n                        ReadableStreamDefaultReaderRead(reader, {\n                            _chunkSteps: (chunk)=>{\n                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                                resolveRead(false);\n                            },\n                            _closeSteps: ()=>resolveRead(true),\n                            _errorSteps: rejectRead\n                        });\n                    });\n                });\n            }\n            // Errors must be propagated forward\n            isOrBecomesErrored(source, reader._closedPromise, (storedError)=>{\n                if (!preventAbort) {\n                    shutdownWithAction(()=>WritableStreamAbort(dest, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n                return null;\n            });\n            // Errors must be propagated backward\n            isOrBecomesErrored(dest, writer._closedPromise, (storedError)=>{\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, storedError), true, storedError);\n                } else {\n                    shutdown(true, storedError);\n                }\n                return null;\n            });\n            // Closing must be propagated forward\n            isOrBecomesClosed(source, reader._closedPromise, ()=>{\n                if (!preventClose) {\n                    shutdownWithAction(()=>WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n                } else {\n                    shutdown();\n                }\n                return null;\n            });\n            // Closing must be propagated backward\n            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === \"closed\") {\n                const destClosed = new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n                if (!preventCancel) {\n                    shutdownWithAction(()=>ReadableStreamCancel(source, destClosed), true, destClosed);\n                } else {\n                    shutdown(true, destClosed);\n                }\n            }\n            setPromiseIsHandledToTrue(pipeLoop());\n            function waitForWritesToFinish() {\n                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n                // for that too.\n                const oldCurrentWrite = currentWrite;\n                return PerformPromiseThen(currentWrite, ()=>oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n            }\n            function isOrBecomesErrored(stream, promise, action) {\n                if (stream._state === \"errored\") {\n                    action(stream._storedError);\n                } else {\n                    uponRejection(promise, action);\n                }\n            }\n            function isOrBecomesClosed(stream, promise, action) {\n                if (stream._state === \"closed\") {\n                    action();\n                } else {\n                    uponFulfillment(promise, action);\n                }\n            }\n            function shutdownWithAction(action, originalIsError, originalError) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), doTheRest);\n                } else {\n                    doTheRest();\n                }\n                function doTheRest() {\n                    uponPromise(action(), ()=>finalize(originalIsError, originalError), (newError)=>finalize(true, newError));\n                    return null;\n                }\n            }\n            function shutdown(isError, error) {\n                if (shuttingDown) {\n                    return;\n                }\n                shuttingDown = true;\n                if (dest._state === \"writable\" && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                    uponFulfillment(waitForWritesToFinish(), ()=>finalize(isError, error));\n                } else {\n                    finalize(isError, error);\n                }\n            }\n            function finalize(isError, error) {\n                WritableStreamDefaultWriterRelease(writer);\n                ReadableStreamReaderGenericRelease(reader);\n                if (signal !== undefined) {\n                    signal.removeEventListener(\"abort\", abortAlgorithm);\n                }\n                if (isError) {\n                    reject(error);\n                } else {\n                    resolve(undefined);\n                }\n                return null;\n            }\n        });\n    }\n    /**\n     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n     *\n     * @public\n     */ class ReadableStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n         */ get desiredSize() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"desiredSize\");\n            }\n            return ReadableStreamDefaultControllerGetDesiredSize(this);\n        }\n        /**\n         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n         * the stream, but once those are read, the stream will become closed.\n         */ close() {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"close\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits close\");\n            }\n            ReadableStreamDefaultControllerClose(this);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"enqueue\");\n            }\n            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n                throw new TypeError(\"The stream is not in a state that permits enqueue\");\n            }\n            return ReadableStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n         */ error(e = undefined) {\n            if (!IsReadableStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException$1(\"error\");\n            }\n            ReadableStreamDefaultControllerError(this, e);\n        }\n        /** @internal */ [CancelSteps](reason) {\n            ResetQueue(this);\n            const result = this._cancelAlgorithm(reason);\n            ReadableStreamDefaultControllerClearAlgorithms(this);\n            return result;\n        }\n        /** @internal */ [PullSteps](readRequest) {\n            const stream = this._controlledReadableStream;\n            if (this._queue.length > 0) {\n                const chunk = DequeueValue(this);\n                if (this._closeRequested && this._queue.length === 0) {\n                    ReadableStreamDefaultControllerClearAlgorithms(this);\n                    ReadableStreamClose(stream);\n                } else {\n                    ReadableStreamDefaultControllerCallPullIfNeeded(this);\n                }\n                readRequest._chunkSteps(chunk);\n            } else {\n                ReadableStreamAddReadRequest(stream, readRequest);\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n        }\n        /** @internal */ [ReleaseSteps]() {\n        // Do nothing.\n        }\n    }\n    Object.defineProperties(ReadableStreamDefaultController.prototype, {\n        close: {\n            enumerable: true\n        },\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStreamDefaultController.prototype.close, \"close\");\n    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, \"enqueue\");\n    setFunctionName(ReadableStreamDefaultController.prototype.error, \"error\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStreamDefaultController.\n    function IsReadableStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledReadableStream\")) {\n            return false;\n        }\n        return x instanceof ReadableStreamDefaultController;\n    }\n    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n        if (!shouldPull) {\n            return;\n        }\n        if (controller._pulling) {\n            controller._pullAgain = true;\n            return;\n        }\n        controller._pulling = true;\n        const pullPromise = controller._pullAlgorithm();\n        uponPromise(pullPromise, ()=>{\n            controller._pulling = false;\n            if (controller._pullAgain) {\n                controller._pullAgain = false;\n                ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            }\n            return null;\n        }, (e)=>{\n            ReadableStreamDefaultControllerError(controller, e);\n            return null;\n        });\n    }\n    function ReadableStreamDefaultControllerShouldCallPull(controller) {\n        const stream = controller._controlledReadableStream;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return false;\n        }\n        if (!controller._started) {\n            return false;\n        }\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            return true;\n        }\n        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n        if (desiredSize > 0) {\n            return true;\n        }\n        return false;\n    }\n    function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n        controller._pullAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n        controller._strategySizeAlgorithm = undefined;\n    }\n    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\n    function ReadableStreamDefaultControllerClose(controller) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        controller._closeRequested = true;\n        if (controller._queue.length === 0) {\n            ReadableStreamDefaultControllerClearAlgorithms(controller);\n            ReadableStreamClose(stream);\n        }\n    }\n    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n            return;\n        }\n        const stream = controller._controlledReadableStream;\n        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n            ReadableStreamFulfillReadRequest(stream, chunk, false);\n        } else {\n            let chunkSize;\n            try {\n                chunkSize = controller._strategySizeAlgorithm(chunk);\n            } catch (chunkSizeE) {\n                ReadableStreamDefaultControllerError(controller, chunkSizeE);\n                throw chunkSizeE;\n            }\n            try {\n                EnqueueValueWithSize(controller, chunk, chunkSize);\n            } catch (enqueueE) {\n                ReadableStreamDefaultControllerError(controller, enqueueE);\n                throw enqueueE;\n            }\n        }\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }\n    function ReadableStreamDefaultControllerError(controller, e) {\n        const stream = controller._controlledReadableStream;\n        if (stream._state !== \"readable\") {\n            return;\n        }\n        ResetQueue(controller);\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamError(stream, e);\n    }\n    function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (state === \"errored\") {\n            return null;\n        }\n        if (state === \"closed\") {\n            return 0;\n        }\n        return controller._strategyHWM - controller._queueTotalSize;\n    }\n    // This is used in the implementation of TransformStream.\n    function ReadableStreamDefaultControllerHasBackpressure(controller) {\n        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n            return false;\n        }\n        return true;\n    }\n    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n        const state = controller._controlledReadableStream._state;\n        if (!controller._closeRequested && state === \"readable\") {\n            return true;\n        }\n        return false;\n    }\n    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n        controller._controlledReadableStream = stream;\n        controller._queue = undefined;\n        controller._queueTotalSize = undefined;\n        ResetQueue(controller);\n        controller._started = false;\n        controller._closeRequested = false;\n        controller._pullAgain = false;\n        controller._pulling = false;\n        controller._strategySizeAlgorithm = sizeAlgorithm;\n        controller._strategyHWM = highWaterMark;\n        controller._pullAlgorithm = pullAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        stream._readableStreamController = controller;\n        const startResult = startAlgorithm();\n        uponPromise(promiseResolvedWith(startResult), ()=>{\n            controller._started = true;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n            return null;\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(controller, r);\n            return null;\n        });\n    }\n    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        let startAlgorithm;\n        let pullAlgorithm;\n        let cancelAlgorithm;\n        if (underlyingSource.start !== undefined) {\n            startAlgorithm = ()=>underlyingSource.start(controller);\n        } else {\n            startAlgorithm = ()=>undefined;\n        }\n        if (underlyingSource.pull !== undefined) {\n            pullAlgorithm = ()=>underlyingSource.pull(controller);\n        } else {\n            pullAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (underlyingSource.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>underlyingSource.cancel(reason);\n        } else {\n            cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    }\n    // Helper functions for the ReadableStreamDefaultController.\n    function defaultControllerBrandCheckException$1(name) {\n        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n    }\n    function ReadableStreamTee(stream, cloneForBranch2) {\n        if (IsReadableByteStreamController(stream._readableStreamController)) {\n            return ReadableByteStreamTee(stream);\n        }\n        return ReadableStreamDefaultTee(stream);\n    }\n    function ReadableStreamDefaultTee(stream, cloneForBranch2) {\n        const reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgain = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function pullAlgorithm() {\n            if (reading) {\n                readAgain = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    _queueMicrotask(()=>{\n                        readAgain = false;\n                        const chunk1 = chunk;\n                        const chunk2 = chunk;\n                        // There is no way to access the cloning code right now in the reference implementation.\n                        // If we add one then we'll need an implementation for serializable objects.\n                        // if (!canceled2 && cloneForBranch2) {\n                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));\n                        // }\n                        if (!canceled1) {\n                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgain) {\n                            pullAlgorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n        // do nothing\n        }\n        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n        uponRejection(reader._closedPromise, (r)=>{\n            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n            if (!canceled1 || !canceled2) {\n                resolveCancelPromise(undefined);\n            }\n            return null;\n        });\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function ReadableByteStreamTee(stream) {\n        let reader = AcquireReadableStreamDefaultReader(stream);\n        let reading = false;\n        let readAgainForBranch1 = false;\n        let readAgainForBranch2 = false;\n        let canceled1 = false;\n        let canceled2 = false;\n        let reason1;\n        let reason2;\n        let branch1;\n        let branch2;\n        let resolveCancelPromise;\n        const cancelPromise = newPromise((resolve)=>{\n            resolveCancelPromise = resolve;\n        });\n        function forwardReaderError(thisReader) {\n            uponRejection(thisReader._closedPromise, (r)=>{\n                if (thisReader !== reader) {\n                    return null;\n                }\n                ReadableByteStreamControllerError(branch1._readableStreamController, r);\n                ReadableByteStreamControllerError(branch2._readableStreamController, r);\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n                return null;\n            });\n        }\n        function pullWithDefaultReader() {\n            if (IsReadableStreamBYOBReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamDefaultReader(stream);\n                forwardReaderError(reader);\n            }\n            const readRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    _queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const chunk1 = chunk;\n                        let chunk2 = chunk;\n                        if (!canceled1 && !canceled2) {\n                            try {\n                                chunk2 = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                        }\n                        if (!canceled1) {\n                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);\n                        }\n                        if (!canceled2) {\n                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: ()=>{\n                    reading = false;\n                    if (!canceled1) {\n                        ReadableByteStreamControllerClose(branch1._readableStreamController);\n                    }\n                    if (!canceled2) {\n                        ReadableByteStreamControllerClose(branch2._readableStreamController);\n                    }\n                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);\n                    }\n                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {\n                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);\n                    }\n                    if (!canceled1 || !canceled2) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamDefaultReaderRead(reader, readRequest);\n        }\n        function pullWithBYOBReader(view, forBranch2) {\n            if (IsReadableStreamDefaultReader(reader)) {\n                ReadableStreamReaderGenericRelease(reader);\n                reader = AcquireReadableStreamBYOBReader(stream);\n                forwardReaderError(reader);\n            }\n            const byobBranch = forBranch2 ? branch2 : branch1;\n            const otherBranch = forBranch2 ? branch1 : branch2;\n            const readIntoRequest = {\n                _chunkSteps: (chunk)=>{\n                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                    // successful synchronously-available reads get ahead of asynchronously-available errors.\n                    _queueMicrotask(()=>{\n                        readAgainForBranch1 = false;\n                        readAgainForBranch2 = false;\n                        const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                        const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                        if (!otherCanceled) {\n                            let clonedChunk;\n                            try {\n                                clonedChunk = CloneAsUint8Array(chunk);\n                            } catch (cloneE) {\n                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);\n                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);\n                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));\n                                return;\n                            }\n                            if (!byobCanceled) {\n                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                            }\n                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);\n                        } else if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        reading = false;\n                        if (readAgainForBranch1) {\n                            pull1Algorithm();\n                        } else if (readAgainForBranch2) {\n                            pull2Algorithm();\n                        }\n                    });\n                },\n                _closeSteps: (chunk)=>{\n                    reading = false;\n                    const byobCanceled = forBranch2 ? canceled2 : canceled1;\n                    const otherCanceled = forBranch2 ? canceled1 : canceled2;\n                    if (!byobCanceled) {\n                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);\n                    }\n                    if (!otherCanceled) {\n                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);\n                    }\n                    if (chunk !== undefined) {\n                        if (!byobCanceled) {\n                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);\n                        }\n                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {\n                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);\n                        }\n                    }\n                    if (!byobCanceled || !otherCanceled) {\n                        resolveCancelPromise(undefined);\n                    }\n                },\n                _errorSteps: ()=>{\n                    reading = false;\n                }\n            };\n            ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);\n        }\n        function pull1Algorithm() {\n            if (reading) {\n                readAgainForBranch1 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, false);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function pull2Algorithm() {\n            if (reading) {\n                readAgainForBranch2 = true;\n                return promiseResolvedWith(undefined);\n            }\n            reading = true;\n            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);\n            if (byobRequest === null) {\n                pullWithDefaultReader();\n            } else {\n                pullWithBYOBReader(byobRequest._view, true);\n            }\n            return promiseResolvedWith(undefined);\n        }\n        function cancel1Algorithm(reason) {\n            canceled1 = true;\n            reason1 = reason;\n            if (canceled2) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function cancel2Algorithm(reason) {\n            canceled2 = true;\n            reason2 = reason;\n            if (canceled1) {\n                const compositeReason = CreateArrayFromList([\n                    reason1,\n                    reason2\n                ]);\n                const cancelResult = ReadableStreamCancel(stream, compositeReason);\n                resolveCancelPromise(cancelResult);\n            }\n            return cancelPromise;\n        }\n        function startAlgorithm() {\n            return;\n        }\n        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);\n        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);\n        forwardReaderError(reader);\n        return [\n            branch1,\n            branch2\n        ];\n    }\n    function isReadableStreamLike(stream) {\n        return typeIsObject(stream) && typeof stream.getReader !== \"undefined\";\n    }\n    function ReadableStreamFrom(source) {\n        if (isReadableStreamLike(source)) {\n            return ReadableStreamFromDefaultReader(source.getReader());\n        }\n        return ReadableStreamFromIterable(source);\n    }\n    function ReadableStreamFromIterable(asyncIterable) {\n        let stream;\n        const iteratorRecord = GetIterator(asyncIterable, \"async\");\n        const startAlgorithm = noop;\n        function pullAlgorithm() {\n            let nextResult;\n            try {\n                nextResult = IteratorNext(iteratorRecord);\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            const nextPromise = promiseResolvedWith(nextResult);\n            return transformPromiseWith(nextPromise, (iterResult)=>{\n                if (!typeIsObject(iterResult)) {\n                    throw new TypeError(\"The promise returned by the iterator.next() method must fulfill with an object\");\n                }\n                const done = IteratorComplete(iterResult);\n                if (done) {\n                    ReadableStreamDefaultControllerClose(stream._readableStreamController);\n                } else {\n                    const value = IteratorValue(iterResult);\n                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n                }\n            });\n        }\n        function cancelAlgorithm(reason) {\n            const iterator = iteratorRecord.iterator;\n            let returnMethod;\n            try {\n                returnMethod = GetMethod(iterator, \"return\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (returnMethod === undefined) {\n                return promiseResolvedWith(undefined);\n            }\n            let returnResult;\n            try {\n                returnResult = reflectCall(returnMethod, iterator, [\n                    reason\n                ]);\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            const returnPromise = promiseResolvedWith(returnResult);\n            return transformPromiseWith(returnPromise, (iterResult)=>{\n                if (!typeIsObject(iterResult)) {\n                    throw new TypeError(\"The promise returned by the iterator.return() method must fulfill with an object\");\n                }\n                return undefined;\n            });\n        }\n        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n        return stream;\n    }\n    function ReadableStreamFromDefaultReader(reader) {\n        let stream;\n        const startAlgorithm = noop;\n        function pullAlgorithm() {\n            let readPromise;\n            try {\n                readPromise = reader.read();\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            return transformPromiseWith(readPromise, (readResult)=>{\n                if (!typeIsObject(readResult)) {\n                    throw new TypeError(\"The promise returned by the reader.read() method must fulfill with an object\");\n                }\n                if (readResult.done) {\n                    ReadableStreamDefaultControllerClose(stream._readableStreamController);\n                } else {\n                    const value = readResult.value;\n                    ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value);\n                }\n            });\n        }\n        function cancelAlgorithm(reason) {\n            try {\n                return promiseResolvedWith(reader.cancel(reason));\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n        }\n        stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);\n        return stream;\n    }\n    function convertUnderlyingDefaultOrByteSource(source, context) {\n        assertDictionary(source, context);\n        const original = source;\n        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const pull = original === null || original === void 0 ? void 0 : original.pull;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const type = original === null || original === void 0 ? void 0 : original.type;\n        return {\n            autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n            cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n            start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n        };\n    }\n    function convertUnderlyingSourceCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    function convertUnderlyingSourcePullCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertUnderlyingSourceStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertReadableStreamType(type, context) {\n        type = `${type}`;\n        if (type !== \"bytes\") {\n            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n        }\n        return type;\n    }\n    function convertIteratorOptions(options, context) {\n        assertDictionary(options, context);\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        return {\n            preventCancel: Boolean(preventCancel)\n        };\n    }\n    function convertPipeOptions(options, context) {\n        assertDictionary(options, context);\n        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n        const signal = options === null || options === void 0 ? void 0 : options.signal;\n        if (signal !== undefined) {\n            assertAbortSignal(signal, `${context} has member 'signal' that`);\n        }\n        return {\n            preventAbort: Boolean(preventAbort),\n            preventCancel: Boolean(preventCancel),\n            preventClose: Boolean(preventClose),\n            signal\n        };\n    }\n    function assertAbortSignal(signal, context) {\n        if (!isAbortSignal(signal)) {\n            throw new TypeError(`${context} is not an AbortSignal.`);\n        }\n    }\n    function convertReadableWritablePair(pair, context) {\n        assertDictionary(pair, context);\n        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n        assertRequiredField(readable, \"readable\", \"ReadableWritablePair\");\n        assertReadableStream(readable, `${context} has member 'readable' that`);\n        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n        assertRequiredField(writable, \"writable\", \"ReadableWritablePair\");\n        assertWritableStream(writable, `${context} has member 'writable' that`);\n        return {\n            readable,\n            writable\n        };\n    }\n    /**\n     * A readable stream represents a source of data, from which you can read.\n     *\n     * @public\n     */ class ReadableStream {\n        constructor(rawUnderlyingSource = {}, rawStrategy = {}){\n            if (rawUnderlyingSource === undefined) {\n                rawUnderlyingSource = null;\n            } else {\n                assertObject(rawUnderlyingSource, \"First parameter\");\n            }\n            const strategy = convertQueuingStrategy(rawStrategy, \"Second parameter\");\n            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, \"First parameter\");\n            InitializeReadableStream(this);\n            if (underlyingSource.type === \"bytes\") {\n                if (strategy.size !== undefined) {\n                    throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n                }\n                const highWaterMark = ExtractHighWaterMark(strategy, 0);\n                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n            } else {\n                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n                const highWaterMark = ExtractHighWaterMark(strategy, 1);\n                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n            }\n        }\n        /**\n         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n         */ get locked() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"locked\");\n            }\n            return IsReadableStreamLocked(this);\n        }\n        /**\n         * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n         *\n         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n         * method, which might or might not use it.\n         */ cancel(reason = undefined) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"cancel\"));\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"Cannot cancel a stream that already has a reader\"));\n            }\n            return ReadableStreamCancel(this, reason);\n        }\n        getReader(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"getReader\");\n            }\n            const options = convertReaderOptions(rawOptions, \"First parameter\");\n            if (options.mode === undefined) {\n                return AcquireReadableStreamDefaultReader(this);\n            }\n            return AcquireReadableStreamBYOBReader(this);\n        }\n        pipeThrough(rawTransform, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"pipeThrough\");\n            }\n            assertRequiredArgument(rawTransform, 1, \"pipeThrough\");\n            const transform = convertReadableWritablePair(rawTransform, \"First parameter\");\n            const options = convertPipeOptions(rawOptions, \"Second parameter\");\n            if (IsReadableStreamLocked(this)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n            }\n            if (IsWritableStreamLocked(transform.writable)) {\n                throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n            }\n            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n            setPromiseIsHandledToTrue(promise);\n            return transform.readable;\n        }\n        pipeTo(destination, rawOptions = {}) {\n            if (!IsReadableStream(this)) {\n                return promiseRejectedWith(streamBrandCheckException$1(\"pipeTo\"));\n            }\n            if (destination === undefined) {\n                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n            }\n            if (!IsWritableStream(destination)) {\n                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n            }\n            let options;\n            try {\n                options = convertPipeOptions(rawOptions, \"Second parameter\");\n            } catch (e) {\n                return promiseRejectedWith(e);\n            }\n            if (IsReadableStreamLocked(this)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\"));\n            }\n            if (IsWritableStreamLocked(destination)) {\n                return promiseRejectedWith(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\"));\n            }\n            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        }\n        /**\n         * Tees this readable stream, returning a two-element array containing the two resulting branches as\n         * new {@link ReadableStream} instances.\n         *\n         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n         * propagated to the stream's underlying source.\n         *\n         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n         * this could allow interference between the two branches.\n         */ tee() {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"tee\");\n            }\n            const branches = ReadableStreamTee(this);\n            return CreateArrayFromList(branches);\n        }\n        values(rawOptions = undefined) {\n            if (!IsReadableStream(this)) {\n                throw streamBrandCheckException$1(\"values\");\n            }\n            const options = convertIteratorOptions(rawOptions, \"First parameter\");\n            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n        }\n        /**\n         * Creates a new ReadableStream wrapping the provided iterable or async iterable.\n         *\n         * This can be used to adapt various kinds of objects into a readable stream,\n         * such as an array, an async generator, or a Node.js readable stream.\n         */ static from(asyncIterable) {\n            return ReadableStreamFrom(asyncIterable);\n        }\n    }\n    Object.defineProperties(ReadableStream, {\n        from: {\n            enumerable: true\n        }\n    });\n    Object.defineProperties(ReadableStream.prototype, {\n        cancel: {\n            enumerable: true\n        },\n        getReader: {\n            enumerable: true\n        },\n        pipeThrough: {\n            enumerable: true\n        },\n        pipeTo: {\n            enumerable: true\n        },\n        tee: {\n            enumerable: true\n        },\n        values: {\n            enumerable: true\n        },\n        locked: {\n            enumerable: true\n        }\n    });\n    setFunctionName(ReadableStream.from, \"from\");\n    setFunctionName(ReadableStream.prototype.cancel, \"cancel\");\n    setFunctionName(ReadableStream.prototype.getReader, \"getReader\");\n    setFunctionName(ReadableStream.prototype.pipeThrough, \"pipeThrough\");\n    setFunctionName(ReadableStream.prototype.pipeTo, \"pipeTo\");\n    setFunctionName(ReadableStream.prototype.tee, \"tee\");\n    setFunctionName(ReadableStream.prototype.values, \"values\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ReadableStream\",\n            configurable: true\n        });\n    }\n    if (typeof SymbolPolyfill.asyncIterator === \"symbol\") {\n        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n            value: ReadableStream.prototype.values,\n            writable: true,\n            configurable: true\n        });\n    }\n    // Abstract operations for the ReadableStream.\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = ()=>1) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableStreamDefaultController.prototype);\n        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n        return stream;\n    }\n    // Throws if and only if startAlgorithm throws.\n    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {\n        const stream = Object.create(ReadableStream.prototype);\n        InitializeReadableStream(stream);\n        const controller = Object.create(ReadableByteStreamController.prototype);\n        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);\n        return stream;\n    }\n    function InitializeReadableStream(stream) {\n        stream._state = \"readable\";\n        stream._reader = undefined;\n        stream._storedError = undefined;\n        stream._disturbed = false;\n    }\n    function IsReadableStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_readableStreamController\")) {\n            return false;\n        }\n        return x instanceof ReadableStream;\n    }\n    function IsReadableStreamLocked(stream) {\n        if (stream._reader === undefined) {\n            return false;\n        }\n        return true;\n    }\n    // ReadableStream API exposed for controllers.\n    function ReadableStreamCancel(stream, reason) {\n        stream._disturbed = true;\n        if (stream._state === \"closed\") {\n            return promiseResolvedWith(undefined);\n        }\n        if (stream._state === \"errored\") {\n            return promiseRejectedWith(stream._storedError);\n        }\n        ReadableStreamClose(stream);\n        const reader = stream._reader;\n        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {\n            const readIntoRequests = reader._readIntoRequests;\n            reader._readIntoRequests = new SimpleQueue();\n            readIntoRequests.forEach((readIntoRequest)=>{\n                readIntoRequest._closeSteps(undefined);\n            });\n        }\n        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n        return transformPromiseWith(sourceCancelPromise, noop);\n    }\n    function ReadableStreamClose(stream) {\n        stream._state = \"closed\";\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseResolve(reader);\n        if (IsReadableStreamDefaultReader(reader)) {\n            const readRequests = reader._readRequests;\n            reader._readRequests = new SimpleQueue();\n            readRequests.forEach((readRequest)=>{\n                readRequest._closeSteps();\n            });\n        }\n    }\n    function ReadableStreamError(stream, e) {\n        stream._state = \"errored\";\n        stream._storedError = e;\n        const reader = stream._reader;\n        if (reader === undefined) {\n            return;\n        }\n        defaultReaderClosedPromiseReject(reader, e);\n        if (IsReadableStreamDefaultReader(reader)) {\n            ReadableStreamDefaultReaderErrorReadRequests(reader, e);\n        } else {\n            ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);\n        }\n    }\n    // Helper functions for the ReadableStream.\n    function streamBrandCheckException$1(name) {\n        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n    }\n    function convertQueuingStrategyInit(init, context) {\n        assertDictionary(init, context);\n        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n        assertRequiredField(highWaterMark, \"highWaterMark\", \"QueuingStrategyInit\");\n        return {\n            highWaterMark: convertUnrestrictedDouble(highWaterMark)\n        };\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const byteLengthSizeFunction = (chunk)=>{\n        return chunk.byteLength;\n    };\n    setFunctionName(byteLengthSizeFunction, \"size\");\n    /**\n     * A queuing strategy that counts the number of bytes in each chunk.\n     *\n     * @public\n     */ class ByteLengthQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"ByteLengthQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"highWaterMark\");\n            }\n            return this._byteLengthQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by returning the value of its `byteLength` property.\n         */ get size() {\n            if (!IsByteLengthQueuingStrategy(this)) {\n                throw byteLengthBrandCheckException(\"size\");\n            }\n            return byteLengthSizeFunction;\n        }\n    }\n    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"ByteLengthQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the ByteLengthQueuingStrategy.\n    function byteLengthBrandCheckException(name) {\n        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n    }\n    function IsByteLengthQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_byteLengthQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof ByteLengthQueuingStrategy;\n    }\n    // The size function must not have a prototype property nor be a constructor\n    const countSizeFunction = ()=>{\n        return 1;\n    };\n    setFunctionName(countSizeFunction, \"size\");\n    /**\n     * A queuing strategy that counts the number of chunks.\n     *\n     * @public\n     */ class CountQueuingStrategy {\n        constructor(options){\n            assertRequiredArgument(options, 1, \"CountQueuingStrategy\");\n            options = convertQueuingStrategyInit(options, \"First parameter\");\n            this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n        }\n        /**\n         * Returns the high water mark provided to the constructor.\n         */ get highWaterMark() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"highWaterMark\");\n            }\n            return this._countQueuingStrategyHighWaterMark;\n        }\n        /**\n         * Measures the size of `chunk` by always returning 1.\n         * This ensures that the total queue size is a count of the number of chunks in the queue.\n         */ get size() {\n            if (!IsCountQueuingStrategy(this)) {\n                throw countBrandCheckException(\"size\");\n            }\n            return countSizeFunction;\n        }\n    }\n    Object.defineProperties(CountQueuingStrategy.prototype, {\n        highWaterMark: {\n            enumerable: true\n        },\n        size: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n            value: \"CountQueuingStrategy\",\n            configurable: true\n        });\n    }\n    // Helper functions for the CountQueuingStrategy.\n    function countBrandCheckException(name) {\n        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n    }\n    function IsCountQueuingStrategy(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_countQueuingStrategyHighWaterMark\")) {\n            return false;\n        }\n        return x instanceof CountQueuingStrategy;\n    }\n    function convertTransformer(original, context) {\n        assertDictionary(original, context);\n        const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n        const flush = original === null || original === void 0 ? void 0 : original.flush;\n        const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n        const start = original === null || original === void 0 ? void 0 : original.start;\n        const transform = original === null || original === void 0 ? void 0 : original.transform;\n        const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n        return {\n            cancel: cancel === undefined ? undefined : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n            flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n            readableType,\n            start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n            transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n            writableType\n        };\n    }\n    function convertTransformerFlushCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>promiseCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerStartCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (controller)=>reflectCall(fn, original, [\n                controller\n            ]);\n    }\n    function convertTransformerTransformCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (chunk, controller)=>promiseCall(fn, original, [\n                chunk,\n                controller\n            ]);\n    }\n    function convertTransformerCancelCallback(fn, original, context) {\n        assertFunction(fn, context);\n        return (reason)=>promiseCall(fn, original, [\n                reason\n            ]);\n    }\n    // Class TransformStream\n    /**\n     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n     * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n     * made available for reading from the readable side.\n     *\n     * @public\n     */ class TransformStream {\n        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}){\n            if (rawTransformer === undefined) {\n                rawTransformer = null;\n            }\n            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, \"Second parameter\");\n            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, \"Third parameter\");\n            const transformer = convertTransformer(rawTransformer, \"First parameter\");\n            if (transformer.readableType !== undefined) {\n                throw new RangeError(\"Invalid readableType specified\");\n            }\n            if (transformer.writableType !== undefined) {\n                throw new RangeError(\"Invalid writableType specified\");\n            }\n            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n            let startPromise_resolve;\n            const startPromise = newPromise((resolve)=>{\n                startPromise_resolve = resolve;\n            });\n            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n            if (transformer.start !== undefined) {\n                startPromise_resolve(transformer.start(this._transformStreamController));\n            } else {\n                startPromise_resolve(undefined);\n            }\n        }\n        /**\n         * The readable side of the transform stream.\n         */ get readable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"readable\");\n            }\n            return this._readable;\n        }\n        /**\n         * The writable side of the transform stream.\n         */ get writable() {\n            if (!IsTransformStream(this)) {\n                throw streamBrandCheckException(\"writable\");\n            }\n            return this._writable;\n        }\n    }\n    Object.defineProperties(TransformStream.prototype, {\n        readable: {\n            enumerable: true\n        },\n        writable: {\n            enumerable: true\n        }\n    });\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStream\",\n            configurable: true\n        });\n    }\n    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n        function startAlgorithm() {\n            return startPromise;\n        }\n        function writeAlgorithm(chunk) {\n            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n        }\n        function abortAlgorithm(reason) {\n            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n        }\n        function closeAlgorithm() {\n            return TransformStreamDefaultSinkCloseAlgorithm(stream);\n        }\n        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n        function pullAlgorithm() {\n            return TransformStreamDefaultSourcePullAlgorithm(stream);\n        }\n        function cancelAlgorithm(reason) {\n            return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);\n        }\n        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n        stream._backpressure = undefined;\n        stream._backpressureChangePromise = undefined;\n        stream._backpressureChangePromise_resolve = undefined;\n        TransformStreamSetBackpressure(stream, true);\n        stream._transformStreamController = undefined;\n    }\n    function IsTransformStream(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_transformStreamController\")) {\n            return false;\n        }\n        return x instanceof TransformStream;\n    }\n    // This is a no-op if both sides are already errored.\n    function TransformStreamError(stream, e) {\n        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n    }\n    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n        TransformStreamUnblockWrite(stream);\n    }\n    function TransformStreamUnblockWrite(stream) {\n        if (stream._backpressure) {\n            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n            // _backpressure is set.\n            TransformStreamSetBackpressure(stream, false);\n        }\n    }\n    function TransformStreamSetBackpressure(stream, backpressure) {\n        // Passes also when called during construction.\n        if (stream._backpressureChangePromise !== undefined) {\n            stream._backpressureChangePromise_resolve();\n        }\n        stream._backpressureChangePromise = newPromise((resolve)=>{\n            stream._backpressureChangePromise_resolve = resolve;\n        });\n        stream._backpressure = backpressure;\n    }\n    // Class TransformStreamDefaultController\n    /**\n     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n     *\n     * @public\n     */ class TransformStreamDefaultController {\n        constructor(){\n            throw new TypeError(\"Illegal constructor\");\n        }\n        /**\n         * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n         */ get desiredSize() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"desiredSize\");\n            }\n            const readableController = this._controlledTransformStream._readable._readableStreamController;\n            return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n        }\n        enqueue(chunk = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"enqueue\");\n            }\n            TransformStreamDefaultControllerEnqueue(this, chunk);\n        }\n        /**\n         * Errors both the readable side and the writable side of the controlled transform stream, making all future\n         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n         */ error(reason = undefined) {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"error\");\n            }\n            TransformStreamDefaultControllerError(this, reason);\n        }\n        /**\n         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n         * transformer only needs to consume a portion of the chunks written to the writable side.\n         */ terminate() {\n            if (!IsTransformStreamDefaultController(this)) {\n                throw defaultControllerBrandCheckException(\"terminate\");\n            }\n            TransformStreamDefaultControllerTerminate(this);\n        }\n    }\n    Object.defineProperties(TransformStreamDefaultController.prototype, {\n        enqueue: {\n            enumerable: true\n        },\n        error: {\n            enumerable: true\n        },\n        terminate: {\n            enumerable: true\n        },\n        desiredSize: {\n            enumerable: true\n        }\n    });\n    setFunctionName(TransformStreamDefaultController.prototype.enqueue, \"enqueue\");\n    setFunctionName(TransformStreamDefaultController.prototype.error, \"error\");\n    setFunctionName(TransformStreamDefaultController.prototype.terminate, \"terminate\");\n    if (typeof SymbolPolyfill.toStringTag === \"symbol\") {\n        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n            value: \"TransformStreamDefaultController\",\n            configurable: true\n        });\n    }\n    // Transform Stream Default Controller Abstract Operations\n    function IsTransformStreamDefaultController(x) {\n        if (!typeIsObject(x)) {\n            return false;\n        }\n        if (!Object.prototype.hasOwnProperty.call(x, \"_controlledTransformStream\")) {\n            return false;\n        }\n        return x instanceof TransformStreamDefaultController;\n    }\n    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {\n        controller._controlledTransformStream = stream;\n        stream._transformStreamController = controller;\n        controller._transformAlgorithm = transformAlgorithm;\n        controller._flushAlgorithm = flushAlgorithm;\n        controller._cancelAlgorithm = cancelAlgorithm;\n        controller._finishPromise = undefined;\n        controller._finishPromise_resolve = undefined;\n        controller._finishPromise_reject = undefined;\n    }\n    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n        const controller = Object.create(TransformStreamDefaultController.prototype);\n        let transformAlgorithm;\n        let flushAlgorithm;\n        let cancelAlgorithm;\n        if (transformer.transform !== undefined) {\n            transformAlgorithm = (chunk)=>transformer.transform(chunk, controller);\n        } else {\n            transformAlgorithm = (chunk)=>{\n                try {\n                    TransformStreamDefaultControllerEnqueue(controller, chunk);\n                    return promiseResolvedWith(undefined);\n                } catch (transformResultE) {\n                    return promiseRejectedWith(transformResultE);\n                }\n            };\n        }\n        if (transformer.flush !== undefined) {\n            flushAlgorithm = ()=>transformer.flush(controller);\n        } else {\n            flushAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        if (transformer.cancel !== undefined) {\n            cancelAlgorithm = (reason)=>transformer.cancel(reason);\n        } else {\n            cancelAlgorithm = ()=>promiseResolvedWith(undefined);\n        }\n        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);\n    }\n    function TransformStreamDefaultControllerClearAlgorithms(controller) {\n        controller._transformAlgorithm = undefined;\n        controller._flushAlgorithm = undefined;\n        controller._cancelAlgorithm = undefined;\n    }\n    function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n            throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n        }\n        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n        // accept TransformStreamDefaultControllerEnqueue() calls.\n        try {\n            ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n        } catch (e) {\n            // This happens when readableStrategy.size() throws.\n            TransformStreamErrorWritableAndUnblockWrite(stream, e);\n            throw stream._readable._storedError;\n        }\n        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n        if (backpressure !== stream._backpressure) {\n            TransformStreamSetBackpressure(stream, true);\n        }\n    }\n    function TransformStreamDefaultControllerError(controller, e) {\n        TransformStreamError(controller._controlledTransformStream, e);\n    }\n    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n        const transformPromise = controller._transformAlgorithm(chunk);\n        return transformPromiseWith(transformPromise, undefined, (r)=>{\n            TransformStreamError(controller._controlledTransformStream, r);\n            throw r;\n        });\n    }\n    function TransformStreamDefaultControllerTerminate(controller) {\n        const stream = controller._controlledTransformStream;\n        const readableController = stream._readable._readableStreamController;\n        ReadableStreamDefaultControllerClose(readableController);\n        const error = new TypeError(\"TransformStream terminated\");\n        TransformStreamErrorWritableAndUnblockWrite(stream, error);\n    }\n    // TransformStreamDefaultSink Algorithms\n    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n        const controller = stream._transformStreamController;\n        if (stream._backpressure) {\n            const backpressureChangePromise = stream._backpressureChangePromise;\n            return transformPromiseWith(backpressureChangePromise, ()=>{\n                const writable = stream._writable;\n                const state = writable._state;\n                if (state === \"erroring\") {\n                    throw writable._storedError;\n                }\n                return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n            });\n        }\n        return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n    }\n    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n        const controller = stream._transformStreamController;\n        if (controller._finishPromise !== undefined) {\n            return controller._finishPromise;\n        }\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        // Assign the _finishPromise now so that if _cancelAlgorithm calls readable.cancel() internally,\n        // we don't run the _cancelAlgorithm again.\n        controller._finishPromise = newPromise((resolve, reject)=>{\n            controller._finishPromise_resolve = resolve;\n            controller._finishPromise_reject = reject;\n        });\n        const cancelPromise = controller._cancelAlgorithm(reason);\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(cancelPromise, ()=>{\n            if (readable._state === \"errored\") {\n                defaultControllerFinishPromiseReject(controller, readable._storedError);\n            } else {\n                ReadableStreamDefaultControllerError(readable._readableStreamController, reason);\n                defaultControllerFinishPromiseResolve(controller);\n            }\n            return null;\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n            defaultControllerFinishPromiseReject(controller, r);\n            return null;\n        });\n        return controller._finishPromise;\n    }\n    function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n        const controller = stream._transformStreamController;\n        if (controller._finishPromise !== undefined) {\n            return controller._finishPromise;\n        }\n        // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n        const readable = stream._readable;\n        // Assign the _finishPromise now so that if _flushAlgorithm calls readable.cancel() internally,\n        // we don't also run the _cancelAlgorithm.\n        controller._finishPromise = newPromise((resolve, reject)=>{\n            controller._finishPromise_resolve = resolve;\n            controller._finishPromise_reject = reject;\n        });\n        const flushPromise = controller._flushAlgorithm();\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(flushPromise, ()=>{\n            if (readable._state === \"errored\") {\n                defaultControllerFinishPromiseReject(controller, readable._storedError);\n            } else {\n                ReadableStreamDefaultControllerClose(readable._readableStreamController);\n                defaultControllerFinishPromiseResolve(controller);\n            }\n            return null;\n        }, (r)=>{\n            ReadableStreamDefaultControllerError(readable._readableStreamController, r);\n            defaultControllerFinishPromiseReject(controller, r);\n            return null;\n        });\n        return controller._finishPromise;\n    }\n    // TransformStreamDefaultSource Algorithms\n    function TransformStreamDefaultSourcePullAlgorithm(stream) {\n        // Invariant. Enforced by the promises returned by start() and pull().\n        TransformStreamSetBackpressure(stream, false);\n        // Prevent the next pull() call until there is backpressure.\n        return stream._backpressureChangePromise;\n    }\n    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {\n        const controller = stream._transformStreamController;\n        if (controller._finishPromise !== undefined) {\n            return controller._finishPromise;\n        }\n        // stream._writable cannot change after construction, so caching it across a call to user code is safe.\n        const writable = stream._writable;\n        // Assign the _finishPromise now so that if _flushAlgorithm calls writable.abort() or\n        // writable.cancel() internally, we don't run the _cancelAlgorithm again, or also run the\n        // _flushAlgorithm.\n        controller._finishPromise = newPromise((resolve, reject)=>{\n            controller._finishPromise_resolve = resolve;\n            controller._finishPromise_reject = reject;\n        });\n        const cancelPromise = controller._cancelAlgorithm(reason);\n        TransformStreamDefaultControllerClearAlgorithms(controller);\n        uponPromise(cancelPromise, ()=>{\n            if (writable._state === \"errored\") {\n                defaultControllerFinishPromiseReject(controller, writable._storedError);\n            } else {\n                WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);\n                TransformStreamUnblockWrite(stream);\n                defaultControllerFinishPromiseResolve(controller);\n            }\n            return null;\n        }, (r)=>{\n            WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);\n            TransformStreamUnblockWrite(stream);\n            defaultControllerFinishPromiseReject(controller, r);\n            return null;\n        });\n        return controller._finishPromise;\n    }\n    // Helper functions for the TransformStreamDefaultController.\n    function defaultControllerBrandCheckException(name) {\n        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n    }\n    function defaultControllerFinishPromiseResolve(controller) {\n        if (controller._finishPromise_resolve === undefined) {\n            return;\n        }\n        controller._finishPromise_resolve();\n        controller._finishPromise_resolve = undefined;\n        controller._finishPromise_reject = undefined;\n    }\n    function defaultControllerFinishPromiseReject(controller, reason) {\n        if (controller._finishPromise_reject === undefined) {\n            return;\n        }\n        setPromiseIsHandledToTrue(controller._finishPromise);\n        controller._finishPromise_reject(reason);\n        controller._finishPromise_resolve = undefined;\n        controller._finishPromise_reject = undefined;\n    }\n    // Helper functions for the TransformStream.\n    function streamBrandCheckException(name) {\n        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n    }\n    exports1.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n    exports1.CountQueuingStrategy = CountQueuingStrategy;\n    exports1.ReadableByteStreamController = ReadableByteStreamController;\n    exports1.ReadableStream = ReadableStream;\n    exports1.ReadableStreamBYOBReader = ReadableStreamBYOBReader;\n    exports1.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;\n    exports1.ReadableStreamDefaultController = ReadableStreamDefaultController;\n    exports1.ReadableStreamDefaultReader = ReadableStreamDefaultReader;\n    exports1.TransformStream = TransformStream;\n    exports1.TransformStreamDefaultController = TransformStreamDefaultController;\n    exports1.WritableStream = WritableStream;\n    exports1.WritableStreamDefaultController = WritableStreamDefaultController;\n    exports1.WritableStreamDefaultWriter = WritableStreamDefaultWriter;\n}); //# sourceMappingURL=ponyfill.es2018.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvZGlzdC9wb255ZmlsbC5lczIwMTguanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztDQU1DLEdBQ0EsVUFBVUEsT0FBTSxFQUFFQyxPQUFPO0lBQ3RCLEtBQWlELEdBQWNBLFFBQVFDLFdBQ3ZFLENBQ2tIO0FBQ3RILEdBQUcsSUFBSSxFQUFHLFNBQVVBLFFBQU87SUFBSTtJQUUzQixxQ0FBcUM7SUFDckMsTUFBTU8saUJBQWlCLE9BQU9DLFdBQVcsY0FBYyxPQUFPQSxPQUFPQyxRQUFRLEtBQUssV0FDOUVELFNBQ0FFLENBQUFBLGNBQWUsQ0FBQyxPQUFPLEVBQUVBLFlBQVksQ0FBQyxDQUFDO0lBRTNDLFNBQVNDO1FBQ0wsT0FBT0M7SUFDWDtJQUVBLFNBQVNDLGFBQWFDLENBQUM7UUFDbkIsT0FBTyxPQUFRQSxNQUFNLFlBQVlBLE1BQU0sUUFBUyxPQUFPQSxNQUFNO0lBQ2pFO0lBQ0EsTUFBTUMsaUNBQWlDSjtJQUN2QyxTQUFTSyxnQkFBZ0JDLEVBQUUsRUFBRUMsSUFBSTtRQUM3QixJQUFJO1lBQ0FDLE9BQU9DLGNBQWMsQ0FBQ0gsSUFBSSxRQUFRO2dCQUM5QkksT0FBT0g7Z0JBQ1BJLGNBQWM7WUFDbEI7UUFDSixFQUNBLE9BQU9DLElBQUk7UUFDUCxpRkFBaUY7UUFDakYsdUhBQXVIO1FBQzNIO0lBQ0o7SUFFQSxNQUFNQyxrQkFBa0JDO0lBQ3hCLE1BQU1DLHNCQUFzQkQsUUFBUUUsU0FBUyxDQUFDQyxJQUFJO0lBQ2xELE1BQU1DLHdCQUF3QkosUUFBUUssTUFBTSxDQUFDQyxJQUFJLENBQUNQO0lBQ2xELGdEQUFnRDtJQUNoRCxTQUFTUSxXQUFXQyxRQUFRO1FBQ3hCLE9BQU8sSUFBSVQsZ0JBQWdCUztJQUMvQjtJQUNBLDBEQUEwRDtJQUMxRCxTQUFTQyxvQkFBb0JiLEtBQUs7UUFDOUIsT0FBT1csV0FBV0csQ0FBQUEsVUFBV0EsUUFBUWQ7SUFDekM7SUFDQSwwREFBMEQ7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QVE4WCx3QkFBd0IsR0FBR0E7SUFDbkM5WCxTQUFRdVEseUJBQXlCLEdBQUdBO0lBQ3BDdlEsU0FBUTBqQiwrQkFBK0IsR0FBR0E7SUFDMUMxakIsU0FBUWlKLDJCQUEyQixHQUFHQTtJQUN0Q2pKLFNBQVFxcUIsZUFBZSxHQUFHQTtJQUMxQnJxQixTQUFRb3NCLGdDQUFnQyxHQUFHQTtJQUMzQ3BzQixTQUFROFosY0FBYyxHQUFHQTtJQUN6QjlaLFNBQVFrYiwrQkFBK0IsR0FBR0E7SUFDMUNsYixTQUFRNmEsMkJBQTJCLEdBQUdBO0FBRTFDLElBQ0EsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNlZS1wcm90by1vbmUvLi9ub2RlX21vZHVsZXMvd2ViLXN0cmVhbXMtcG9seWZpbGwvZGlzdC9wb255ZmlsbC5lczIwMTguanM/ZjczZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiB3ZWItc3RyZWFtcy1wb2x5ZmlsbCB2My4zLjJcbiAqIENvcHlyaWdodCAyMDI0IE1hdHRpYXMgQnVlbGVucywgRGl3YW5rIFNpbmdoIFRvbWVyIGFuZCBvdGhlciBjb250cmlidXRvcnMuXG4gKiBUaGlzIGNvZGUgaXMgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICAgIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxuICAgIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGZhY3RvcnkoZ2xvYmFsLldlYlN0cmVhbXNQb2x5ZmlsbCA9IHt9KSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE1LnN5bWJvbFwiIC8+XG4gICAgY29uc3QgU3ltYm9sUG9seWZpbGwgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdzeW1ib2wnID9cbiAgICAgICAgU3ltYm9sIDpcbiAgICAgICAgZGVzY3JpcHRpb24gPT4gYFN5bWJvbCgke2Rlc2NyaXB0aW9ufSlgO1xuXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0eXBlSXNPYmplY3QoeCkge1xuICAgICAgICByZXR1cm4gKHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsKSB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgY29uc3QgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uID0gbm9vcDtcbiAgICBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm4sIG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgJ25hbWUnLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgbm9uLWNvbmZpZ3VyYWJsZSBpbiBvbGRlciBicm93c2Vycywgc28gaWdub3JlIGlmIHRoaXMgdGhyb3dzLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRnVuY3Rpb24vbmFtZSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsUHJvbWlzZSA9IFByb21pc2U7XG4gICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlVGhlbiA9IFByb21pc2UucHJvdG90eXBlLnRoZW47XG4gICAgY29uc3Qgb3JpZ2luYWxQcm9taXNlUmVqZWN0ID0gUHJvbWlzZS5yZWplY3QuYmluZChvcmlnaW5hbFByb21pc2UpO1xuICAgIC8vIGh0dHBzOi8vd2ViaWRsLnNwZWMud2hhdHdnLm9yZy8jYS1uZXctcHJvbWlzZVxuICAgIGZ1bmN0aW9uIG5ld1Byb21pc2UoZXhlY3V0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBvcmlnaW5hbFByb21pc2UoZXhlY3V0b3IpO1xuICAgIH1cbiAgICAvLyBodHRwczovL3dlYmlkbC5zcGVjLndoYXR3Zy5vcmcvI2EtcHJvbWlzZS1yZXNvbHZlZC13aXRoXG4gICAgZnVuY3Rpb24gcHJvbWlzZVJlc29sdmVkV2l0aCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3UHJvbWlzZShyZXNvbHZlID0+IHJlc29sdmUodmFsdWUpKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly93ZWJpZGwuc3BlYy53aGF0d2cub3JnLyNhLXByb21pc2UtcmVqZWN0ZWQtd2l0aFxuICAgIGZ1bmN0aW9uIHByb21pc2VSZWplY3RlZFdpdGgocmVhc29uKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIC8vIFRoZXJlIGRvZXNuJ3QgYXBwZWFyIHRvIGJlIGFueSB3YXkgdG8gY29ycmVjdGx5IGVtdWxhdGUgdGhlIGJlaGF2aW91ciBmcm9tIEphdmFTY3JpcHQsIHNvIHRoaXMgaXMganVzdCBhblxuICAgICAgICAvLyBhcHByb3hpbWF0aW9uLlxuICAgICAgICByZXR1cm4gb3JpZ2luYWxQcm9taXNlVGhlbi5jYWxsKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gICAgLy8gQmx1ZWJpcmQgbG9ncyBhIHdhcm5pbmcgd2hlbiBhIHByb21pc2UgaXMgY3JlYXRlZCB3aXRoaW4gYSBmdWxmaWxsbWVudCBoYW5kbGVyLCBidXQgdGhlbiBpc24ndCByZXR1cm5lZFxuICAgIC8vIGZyb20gdGhhdCBoYW5kbGVyLiBUbyBwcmV2ZW50IHRoaXMsIHJldHVybiBudWxsIGluc3RlYWQgb2Ygdm9pZCBmcm9tIGFsbCBoYW5kbGVycy5cbiAgICAvLyBodHRwOi8vYmx1ZWJpcmRqcy5jb20vZG9jcy93YXJuaW5nLWV4cGxhbmF0aW9ucy5odG1sI3dhcm5pbmctYS1wcm9taXNlLXdhcy1jcmVhdGVkLWluLWEtaGFuZGxlci1idXQtd2FzLW5vdC1yZXR1cm5lZC1mcm9tLWl0XG4gICAgZnVuY3Rpb24gdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgUGVyZm9ybVByb21pc2VUaGVuKFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCksIHVuZGVmaW5lZCwgcmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIG9uRnVsZmlsbGVkKSB7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsIG9uRnVsZmlsbGVkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBvblJlamVjdGlvbihwcm9taXNlLCBvblJlamVjdGVkKSB7XG4gICAgICAgIHVwb25Qcm9taXNlKHByb21pc2UsIHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybVByb21pc2VXaXRoKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocHJvbWlzZSkge1xuICAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuICAgIH1cbiAgICBsZXQgX3F1ZXVlTWljcm90YXNrID0gY2FsbGJhY2sgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXVlTWljcm90YXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFzaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzayA9IGNiID0+IFBlcmZvcm1Qcm9taXNlVGhlbihyZXNvbHZlZFByb21pc2UsIGNiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3F1ZXVlTWljcm90YXNrKGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJlZmxlY3RDYWxsKEYsIFYsIGFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBGICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChGLCBWLCBhcmdzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHJvbWlzZUNhbGwoRiwgViwgYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgocmVmbGVjdENhbGwoRiwgViwgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gT3JpZ2luYWwgZnJvbSBDaHJvbWl1bVxuICAgIC8vIGh0dHBzOi8vY2hyb21pdW0uZ29vZ2xlc291cmNlLmNvbS9jaHJvbWl1bS9zcmMvKy8wYWVlNDQzNGE0ZGJhNDJhNDJhYmFlYTliZmJjMGNkMTk2YTYzYmMxL3RoaXJkX3BhcnR5L2JsaW5rL3JlbmRlcmVyL2NvcmUvc3RyZWFtcy9TaW1wbGVRdWV1ZS5qc1xuICAgIGNvbnN0IFFVRVVFX01BWF9BUlJBWV9TSVpFID0gMTYzODQ7XG4gICAgLyoqXG4gICAgICogU2ltcGxlIHF1ZXVlIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIEF2b2lkcyBzY2FsYWJpbGl0eSBpc3N1ZXMgd2l0aCB1c2luZyBhIHBhY2tlZCBhcnJheSBkaXJlY3RseSBieSB1c2luZ1xuICAgICAqIG11bHRpcGxlIGFycmF5cyBpbiBhIGxpbmtlZCBsaXN0IGFuZCBrZWVwaW5nIHRoZSBhcnJheSBzaXplIGJvdW5kZWQuXG4gICAgICovXG4gICAgY2xhc3MgU2ltcGxlUXVldWUge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRoaXMuX2N1cnNvciA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgICAgIC8vIF9mcm9udCBhbmQgX2JhY2sgYXJlIGFsd2F5cyBkZWZpbmVkLlxuICAgICAgICAgICAgdGhpcy5fZnJvbnQgPSB7XG4gICAgICAgICAgICAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICBfbmV4dDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fYmFjayA9IHRoaXMuX2Zyb250O1xuICAgICAgICAgICAgLy8gVGhlIGN1cnNvciBpcyB1c2VkIHRvIGF2b2lkIGNhbGxpbmcgQXJyYXkuc2hpZnQoKS5cbiAgICAgICAgICAgIC8vIEl0IGNvbnRhaW5zIHRoZSBpbmRleCBvZiB0aGUgZnJvbnQgZWxlbWVudCBvZiB0aGUgYXJyYXkgaW5zaWRlIHRoZVxuICAgICAgICAgICAgLy8gZnJvbnQtbW9zdCBub2RlLiBJdCBpcyBhbHdheXMgaW4gdGhlIHJhbmdlIFswLCBRVUVVRV9NQVhfQVJSQVlfU0laRSkuXG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBvbmx5IG9uZSBub2RlLCBzaXplID09PSBlbGVtZW50cy5sZW5ndGggLSBjdXJzb3IuXG4gICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIGV4Y2VwdGlvbiBzYWZldHksIHRoaXMgbWV0aG9kIGlzIHN0cnVjdHVyZWQgaW4gb3JkZXI6XG4gICAgICAgIC8vIDEuIFJlYWQgc3RhdGVcbiAgICAgICAgLy8gMi4gQ2FsY3VsYXRlIHJlcXVpcmVkIHN0YXRlIG11dGF0aW9uc1xuICAgICAgICAvLyAzLiBQZXJmb3JtIHN0YXRlIG11dGF0aW9uc1xuICAgICAgICBwdXNoKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEJhY2sgPSB0aGlzLl9iYWNrO1xuICAgICAgICAgICAgbGV0IG5ld0JhY2sgPSBvbGRCYWNrO1xuICAgICAgICAgICAgaWYgKG9sZEJhY2suX2VsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3QmFjayA9IHtcbiAgICAgICAgICAgICAgICAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwdXNoKCkgaXMgdGhlIG11dGF0aW9uIG1vc3QgbGlrZWx5IHRvIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gaXRcbiAgICAgICAgICAgIC8vIGdvZXMgZmlyc3QuXG4gICAgICAgICAgICBvbGRCYWNrLl9lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9iYWNrID0gbmV3QmFjaztcbiAgICAgICAgICAgICAgICBvbGRCYWNrLl9uZXh0ID0gbmV3QmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICsrdGhpcy5fc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaWtlIHB1c2goKSwgc2hpZnQoKSBmb2xsb3dzIHRoZSByZWFkIC0+IGNhbGN1bGF0ZSAtPiBtdXRhdGUgcGF0dGVybiBmb3JcbiAgICAgICAgLy8gZXhjZXB0aW9uIHNhZmV0eS5cbiAgICAgICAgc2hpZnQoKSB7IC8vIG11c3Qgbm90IGJlIGNhbGxlZCBvbiBhbiBlbXB0eSBxdWV1ZVxuICAgICAgICAgICAgY29uc3Qgb2xkRnJvbnQgPSB0aGlzLl9mcm9udDtcbiAgICAgICAgICAgIGxldCBuZXdGcm9udCA9IG9sZEZyb250O1xuICAgICAgICAgICAgY29uc3Qgb2xkQ3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgICAgICAgICAgbGV0IG5ld0N1cnNvciA9IG9sZEN1cnNvciArIDE7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IG9sZEZyb250Ll9lbGVtZW50cztcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tvbGRDdXJzb3JdO1xuICAgICAgICAgICAgaWYgKG5ld0N1cnNvciA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgICAgICAgICBuZXdGcm9udCA9IG9sZEZyb250Ll9uZXh0O1xuICAgICAgICAgICAgICAgIG5ld0N1cnNvciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBObyBtdXRhdGlvbnMgYmVmb3JlIHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAtLXRoaXMuX3NpemU7XG4gICAgICAgICAgICB0aGlzLl9jdXJzb3IgPSBuZXdDdXJzb3I7XG4gICAgICAgICAgICBpZiAob2xkRnJvbnQgIT09IG5ld0Zyb250KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJvbnQgPSBuZXdGcm9udDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBlcm1pdCBzaGlmdGVkIGVsZW1lbnQgdG8gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICAgICAgICBlbGVtZW50c1tvbGRDdXJzb3JdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIHRyaWNreSB0aGluZyBhYm91dCBmb3JFYWNoKCkgaXMgdGhhdCBpdCBjYW4gYmUgY2FsbGVkXG4gICAgICAgIC8vIHJlLWVudHJhbnRseS4gVGhlIHF1ZXVlIG1heSBiZSBtdXRhdGVkIGluc2lkZSB0aGUgY2FsbGJhY2suIEl0IGlzIGVhc3kgdG9cbiAgICAgICAgLy8gc2VlIHRoYXQgcHVzaCgpIHdpdGhpbiB0aGUgY2FsbGJhY2sgaGFzIG5vIG5lZ2F0aXZlIGVmZmVjdHMgc2luY2UgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgcXVldWUgaXMgY2hlY2tlZCBmb3Igb24gZXZlcnkgaXRlcmF0aW9uLiBJZiBzaGlmdCgpIGlzIGNhbGxlZFxuICAgICAgICAvLyByZXBlYXRlZGx5IHdpdGhpbiB0aGUgY2FsbGJhY2sgdGhlbiB0aGUgbmV4dCBpdGVyYXRpb24gbWF5IHJldHVybiBhblxuICAgICAgICAvLyBlbGVtZW50IHRoYXQgaGFzIGJlZW4gcmVtb3ZlZC4gSW4gdGhpcyBjYXNlIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAgICAvLyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMgdW50aWwgd2UgZWl0aGVyIFwiY2F0Y2ggdXBcIiB3aXRoIGVsZW1lbnRzIHRoYXQgc3RpbGxcbiAgICAgICAgLy8gZXhpc3Qgb3IgcmVhY2ggdGhlIGJhY2sgb2YgdGhlIHF1ZXVlLlxuICAgICAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsZXQgaSA9IHRoaXMuX2N1cnNvcjtcbiAgICAgICAgICAgIGxldCBub2RlID0gdGhpcy5fZnJvbnQ7XG4gICAgICAgICAgICBsZXQgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgICAgICAgICAgIHdoaWxlIChpICE9PSBlbGVtZW50cy5sZW5ndGggfHwgbm9kZS5fbmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5fbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBlbGVtZW50IHRoYXQgd291bGQgYmUgcmV0dXJuZWQgaWYgc2hpZnQoKSB3YXMgY2FsbGVkIG5vdyxcbiAgICAgICAgLy8gd2l0aG91dCBtb2RpZnlpbmcgdGhlIHF1ZXVlLlxuICAgICAgICBwZWVrKCkgeyAvLyBtdXN0IG5vdCBiZSBjYWxsZWQgb24gYW4gZW1wdHkgcXVldWVcbiAgICAgICAgICAgIGNvbnN0IGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICAgICAgICAgICByZXR1cm4gZnJvbnQuX2VsZW1lbnRzW2N1cnNvcl07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBBYm9ydFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQWJvcnRTdGVwc11dJyk7XG4gICAgY29uc3QgRXJyb3JTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0Vycm9yU3RlcHNdXScpO1xuICAgIGNvbnN0IENhbmNlbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQ2FuY2VsU3RlcHNdXScpO1xuICAgIGNvbnN0IFB1bGxTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW1B1bGxTdGVwc11dJyk7XG4gICAgY29uc3QgUmVsZWFzZVN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbUmVsZWFzZVN0ZXBzXV0nKTtcblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUocmVhZGVyLCBzdHJlYW0pIHtcbiAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHJlYWRlcjtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIGFuZCBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlXG4gICAgLy8gY2hlY2suXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHJlYWRlciwgcmVhc29uKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBuZXcgVHlwZUVycm9yKGBSZWFkZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtJ3MgY2xvc2VkbmVzc2ApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgbmV3IFR5cGVFcnJvcihgUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbSdzIGNsb3NlZG5lc3NgKSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUmVsZWFzZVN0ZXBzXSgpO1xuICAgICAgICBzdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgcmVhZGVycy5cbiAgICBmdW5jdGlvbiByZWFkZXJMb2NrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCByZWFkZXInKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZChyZWFkZXIpIHtcbiAgICAgICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIHJlYXNvbikge1xuICAgICAgICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcikge1xuICAgICAgICBpZiAocmVhZGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNGaW5pdGUjUG9seWZpbGxcbiAgICBjb25zdCBOdW1iZXJJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdudW1iZXInICYmIGlzRmluaXRlKHgpO1xuICAgIH07XG5cbiAgICAvLy8gPHJlZmVyZW5jZSBsaWI9XCJlczIwMTUuY29yZVwiIC8+XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC90cnVuYyNQb2x5ZmlsbFxuICAgIGNvbnN0IE1hdGhUcnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHYgPCAwID8gTWF0aC5jZWlsKHYpIDogTWF0aC5mbG9vcih2KTtcbiAgICB9O1xuXG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLWRpY3Rpb25hcmllc1xuICAgIGZ1bmN0aW9uIGlzRGljdGlvbmFyeSh4KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydERpY3Rpb25hcnkob2JqLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCAmJiAhaXNEaWN0aW9uYXJ5KG9iaikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtY2FsbGJhY2stZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gYXNzZXJ0RnVuY3Rpb24oeCwgY29udGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mIHggIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZnVuY3Rpb24uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLW9iamVjdFxuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydE9iamVjdCh4LCBjb250ZXh0KSB7XG4gICAgICAgIGlmICghaXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIG9iamVjdC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KHgsIHBvc2l0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFBhcmFtZXRlciAke3Bvc2l0aW9ufSBpcyByZXF1aXJlZCBpbiAnJHtjb250ZXh0fScuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXNzZXJ0UmVxdWlyZWRGaWVsZCh4LCBmaWVsZCwgY29udGV4dCkge1xuICAgICAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2ZpZWxkfSBpcyByZXF1aXJlZCBpbiAnJHtjb250ZXh0fScuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLXVucmVzdHJpY3RlZC1kb3VibGVcbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjZW5zb3JOZWdhdGl2ZVplcm8oeCkge1xuICAgICAgICByZXR1cm4geCA9PT0gMCA/IDAgOiB4O1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnRlZ2VyUGFydCh4KSB7XG4gICAgICAgIHJldHVybiBjZW5zb3JOZWdhdGl2ZVplcm8oTWF0aFRydW5jKHgpKTtcbiAgICB9XG4gICAgLy8gaHR0cHM6Ly9oZXljYW0uZ2l0aHViLmlvL3dlYmlkbC8jaWRsLXVuc2lnbmVkLWxvbmctbG9uZ1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSh2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gMDtcbiAgICAgICAgY29uc3QgdXBwZXJCb3VuZCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICBsZXQgeCA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIHggPSBjZW5zb3JOZWdhdGl2ZVplcm8oeCk7XG4gICAgICAgIGlmICghTnVtYmVySXNGaW5pdGUoeCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGEgZmluaXRlIG51bWJlcmApO1xuICAgICAgICB9XG4gICAgICAgIHggPSBpbnRlZ2VyUGFydCh4KTtcbiAgICAgICAgaWYgKHggPCBsb3dlckJvdW5kIHx8IHggPiB1cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG91dHNpZGUgdGhlIGFjY2VwdGVkIHJhbmdlIG9mICR7bG93ZXJCb3VuZH0gdG8gJHt1cHBlckJvdW5kfSwgaW5jbHVzaXZlYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXJJc0Zpbml0ZSh4KSB8fCB4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIFVzZSBCaWdJbnQgaWYgc3VwcG9ydGVkP1xuICAgICAgICAvLyBsZXQgeEJpZ0ludCA9IEJpZ0ludChpbnRlZ2VyUGFydCh4KSk7XG4gICAgICAgIC8vIHhCaWdJbnQgPSBCaWdJbnQuYXNVaW50Tig2NCwgeEJpZ0ludCk7XG4gICAgICAgIC8vIHJldHVybiBOdW1iZXIoeEJpZ0ludCk7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFJlYWRhYmxlU3RyZWFtKHgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFJlYWRhYmxlU3RyZWFtLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gICAgfVxuICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpIHtcbiAgICAgICAgc3RyZWFtLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5wdXNoKHJlYWRSZXF1ZXN0KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSByZWFkZXIuX3JlYWRSZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jaHVua1N0ZXBzKGNodW5rKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMubGVuZ3RoO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IHJlYWRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW19LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInKTtcbiAgICAgICAgICAgIGFzc2VydFJlYWRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgcmVhZGluZyBieSBhbm90aGVyIHJlYWRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuICAgICAgICAgICAgdGhpcy5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgd2hlbiB0aGUgc3RyZWFtIGJlY29tZXMgY2xvc2VkLFxuICAgICAgICAgKiBvciByZWplY3RlZCBpZiB0aGUgc3RyZWFtIGV2ZXIgZXJyb3JzIG9yIHRoZSByZWFkZXIncyBsb2NrIGlzIHJlbGVhc2VkIGJlZm9yZSB0aGUgc3RyZWFtIGZpbmlzaGVzIGNsb3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFJlYWRhYmxlU3RyZWFtLmNhbmNlbCB8IHN0cmVhbS5jYW5jZWwocmVhc29uKX0uXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgYWxsb3dzIGFjY2VzcyB0byB0aGUgbmV4dCBjaHVuayBmcm9tIHRoZSBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZSwgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiByZWFkaW5nIGEgY2h1bmsgY2F1c2VzIHRoZSBxdWV1ZSB0byBiZWNvbWUgZW1wdHksIG1vcmUgZGF0YSB3aWxsIGJlIHB1bGxlZCBmcm9tIHRoZSB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlYWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbigncmVhZCBmcm9tJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgbGV0IHJlamVjdFByb21pc2U7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgIHJlamVjdFByb21pc2UgPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiByZXNvbHZlUHJvbWlzZSh7IHZhbHVlOiBjaHVuaywgZG9uZTogZmFsc2UgfSksXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogZSA9PiByZWplY3RQcm9taXNlKGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZCh0aGlzLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmVsZWFzZXMgdGhlIHJlYWRlcidzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAqIGZyb20gbm93IG9uOyBvdGhlcndpc2UsIHRoZSByZWFkZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIHJlYWRlcidzIGxvY2sgY2Fubm90IGJlIHJlbGVhc2VkIHdoaWxlIGl0IHN0aWxsIGhhcyBhIHBlbmRpbmcgcmVhZCByZXF1ZXN0LCBpLmUuLCBpZiBhIHByb21pc2UgcmV0dXJuZWQgYnlcbiAgICAgICAgICogdGhlIHJlYWRlcidzIHtAbGluayBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucmVhZCB8IHJlYWQoKX0gbWV0aG9kIGhhcyBub3QgeWV0IGJlZW4gc2V0dGxlZC4gQXR0ZW1wdGluZyB0b1xuICAgICAgICAgKiBkbyBzbyB3aWxsIHRocm93IGEgYFR5cGVFcnJvcmAgYW5kIGxlYXZlIHRoZSByZWFkZXIgbG9ja2VkIHRvIHRoZSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICByZWxlYXNlTG9jaygpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVsZWFzZUxvY2snKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWxlYXNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2FuY2VsOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVhZDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2VkOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLmNhbmNlbCwgJ2NhbmNlbCcpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLnJlYWQsICdyZWFkJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgcmVhZGVycy5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkUmVxdWVzdHMnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwgcmVhZFJlcXVlc3QpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Nsb3NlU3RlcHMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXJbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVsZWFzZShyZWFkZXIpIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignUmVhZGVyIHdhcyByZWxlYXNlZCcpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJFcnJvclJlYWRSZXF1ZXN0cyhyZWFkZXIsIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJFcnJvclJlYWRSZXF1ZXN0cyhyZWFkZXIsIGUpIHtcbiAgICAgICAgY29uc3QgcmVhZFJlcXVlc3RzID0gcmVhZGVyLl9yZWFkUmVxdWVzdHM7XG4gICAgICAgIHJlYWRlci5fcmVhZFJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gICAgICAgIHJlYWRSZXF1ZXN0cy5mb3JFYWNoKHJlYWRSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcmApO1xuICAgIH1cblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxOC5hc3luY2l0ZXJhYmxlXCIgLz5cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb24gKi9cbiAgICBjb25zdCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihhc3luYyBmdW5jdGlvbiogKCkgeyB9KS5wcm90b3R5cGUpO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgbGliPVwiZXMyMDE4LmFzeW5jaXRlcmFibGVcIiAvPlxuICAgIGNsYXNzIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwge1xuICAgICAgICBjb25zdHJ1Y3RvcihyZWFkZXIsIHByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgICAgICAgICAgdGhpcy5fcHJldmVudENhbmNlbCA9IHByZXZlbnRDYW5jZWw7XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGVwcyA9ICgpID0+IHRoaXMuX25leHRTdGVwcygpO1xuICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIG5leHRTdGVwcywgbmV4dFN0ZXBzKSA6XG4gICAgICAgICAgICAgICAgbmV4dFN0ZXBzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb25nb2luZ1Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByZXR1cm5TdGVwcyA9ICgpID0+IHRoaXMuX3JldHVyblN0ZXBzKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmdvaW5nUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUHJvbWlzZVdpdGgodGhpcy5fb25nb2luZ1Byb21pc2UsIHJldHVyblN0ZXBzLCByZXR1cm5TdGVwcykgOlxuICAgICAgICAgICAgICAgIHJldHVyblN0ZXBzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX25leHRTdGVwcygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgICAgICAgICBsZXQgcmVzb2x2ZVByb21pc2U7XG4gICAgICAgICAgICBsZXQgcmVqZWN0UHJvbWlzZTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0UHJvbWlzZSA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb25nb2luZ1Byb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBieSBvbmUgbWljcm90YXNrLCBvdGhlcndpc2Ugd2Ugc3RvcCBwdWxsaW5nIHRvbyBlYXJseSB3aGljaCBicmVha3MgYSB0ZXN0LlxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRSBJcyB0aGlzIGEgYnVnIGluIHRoZSBzcGVjaWZpY2F0aW9uLCBvciBpbiB0aGUgdGVzdD9cbiAgICAgICAgICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrKCgpID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9vbmdvaW5nUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IHJlYXNvbiA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uZ29pbmdQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pc0ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBfcmV0dXJuU3RlcHModmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5faXNGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSB0aGlzLl9yZWFkZXI7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3ByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsICgpID0+ICh7IHZhbHVlLCBkb25lOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UocmVhZGVyKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHsgdmFsdWUsIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0ge1xuICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCduZXh0JykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FzeW5jSXRlcmF0b3JJbXBsLm5leHQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JldHVybicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hc3luY0l0ZXJhdG9ySW1wbC5yZXR1cm4odmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoQXN5bmNJdGVyYXRvclByb3RvdHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUpO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0sIHByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICBjb25zdCBpbXBsID0gbmV3IFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGwocmVhZGVyLCBwcmV2ZW50Q2FuY2VsKTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIGl0ZXJhdG9yLl9hc3luY0l0ZXJhdG9ySW1wbCA9IGltcGw7XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXN5bmNJdGVyYXRvckltcGwnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBub2luc3BlY3Rpb24gU3VzcGljaW91c1R5cGVPZkd1YXJkXG4gICAgICAgICAgICByZXR1cm4geC5fYXN5bmNJdGVyYXRvckltcGwgaW5zdGFuY2VvZlxuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvckltcGw7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvci4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0ZWFtQXN5bmNJdGVyYXRvcmApO1xuICAgIH1cblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImVzMjAxNS5jb3JlXCIgLz5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvaXNOYU4jUG9seWZpbGxcbiAgICBjb25zdCBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiAoeCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICAgIHJldHVybiB4ICE9PSB4O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDcmVhdGVBcnJheUZyb21MaXN0KGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIFdlIHVzZSBhcnJheXMgdG8gcmVwcmVzZW50IGxpc3RzLCBzbyB0aGlzIGlzIGJhc2ljYWxseSBhIG5vLW9wLlxuICAgICAgICAvLyBEbyBhIHNsaWNlIHRob3VnaCBqdXN0IGluIGNhc2Ugd2UgaGFwcGVuIHRvIGRlcGVuZCBvbiB0aGUgdW5pcXVlLW5lc3MuXG4gICAgICAgIHJldHVybiBlbGVtZW50cy5zbGljZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDb3B5RGF0YUJsb2NrQnl0ZXMoZGVzdCwgZGVzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIG4pIHtcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoZGVzdCkuc2V0KG5ldyBVaW50OEFycmF5KHNyYywgc3JjT2Zmc2V0LCBuKSwgZGVzdE9mZnNldCk7XG4gICAgfVxuICAgIGxldCBUcmFuc2ZlckFycmF5QnVmZmVyID0gKE8pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBPLnRyYW5zZmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBUcmFuc2ZlckFycmF5QnVmZmVyID0gYnVmZmVyID0+IGJ1ZmZlci50cmFuc2ZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIFRyYW5zZmVyQXJyYXlCdWZmZXIgPSBidWZmZXIgPT4gc3RydWN0dXJlZENsb25lKGJ1ZmZlciwgeyB0cmFuc2ZlcjogW2J1ZmZlcl0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQgY29ycmVjdGx5XG4gICAgICAgICAgICBUcmFuc2ZlckFycmF5QnVmZmVyID0gYnVmZmVyID0+IGJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVHJhbnNmZXJBcnJheUJ1ZmZlcihPKTtcbiAgICB9O1xuICAgIGxldCBJc0RldGFjaGVkQnVmZmVyID0gKE8pID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBPLmRldGFjaGVkID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIElzRGV0YWNoZWRCdWZmZXIgPSBidWZmZXIgPT4gYnVmZmVyLmRldGFjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm90IGltcGxlbWVudGVkIGNvcnJlY3RseVxuICAgICAgICAgICAgSXNEZXRhY2hlZEJ1ZmZlciA9IGJ1ZmZlciA9PiBidWZmZXIuYnl0ZUxlbmd0aCA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSXNEZXRhY2hlZEJ1ZmZlcihPKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEFycmF5QnVmZmVyU2xpY2UoYnVmZmVyLCBiZWdpbiwgZW5kKSB7XG4gICAgICAgIC8vIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3QgYXZhaWxhYmxlIG9uIElFMTBcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vbWRuLWphdmFzY3JpcHRfYnVpbHRpbnNfYXJyYXlidWZmZXJfc2xpY2VcbiAgICAgICAgaWYgKGJ1ZmZlci5zbGljZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZShiZWdpbiwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW5ndGggPSBlbmQgLSBiZWdpbjtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoKTtcbiAgICAgICAgQ29weURhdGFCbG9ja0J5dGVzKHNsaWNlLCAwLCBidWZmZXIsIGJlZ2luLCBsZW5ndGgpO1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdldE1ldGhvZChyZWNlaXZlciwgcHJvcCkge1xuICAgICAgICBjb25zdCBmdW5jID0gcmVjZWl2ZXJbcHJvcF07XG4gICAgICAgIGlmIChmdW5jID09PSB1bmRlZmluZWQgfHwgZnVuYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7U3RyaW5nKHByb3ApfSBpcyBub3QgYSBmdW5jdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDcmVhdGVBc3luY0Zyb21TeW5jSXRlcmF0b3Ioc3luY0l0ZXJhdG9yUmVjb3JkKSB7XG4gICAgICAgIC8vIEluc3RlYWQgb2YgcmUtaW1wbGVtZW50aW5nIENyZWF0ZUFzeW5jRnJvbVN5bmNJdGVyYXRvciBhbmQgJUFzeW5jRnJvbVN5bmNJdGVyYXRvclByb3RvdHlwZSUsXG4gICAgICAgIC8vIHdlIHVzZSB5aWVsZCogaW5zaWRlIGFuIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiB0byBhY2hpZXZlIHRoZSBzYW1lIHJlc3VsdC5cbiAgICAgICAgLy8gV3JhcCB0aGUgc3luYyBpdGVyYXRvciBpbnNpZGUgYSBzeW5jIGl0ZXJhYmxlLCBzbyB3ZSBjYW4gdXNlIGl0IHdpdGggeWllbGQqLlxuICAgICAgICBjb25zdCBzeW5jSXRlcmFibGUgPSB7XG4gICAgICAgICAgICBbU3ltYm9sUG9seWZpbGwuaXRlcmF0b3JdOiAoKSA9PiBzeW5jSXRlcmF0b3JSZWNvcmQuaXRlcmF0b3JcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBhbmQgaW1tZWRpYXRlbHkgaW52b2tlIGl0LlxuICAgICAgICBjb25zdCBhc3luY0l0ZXJhdG9yID0gKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQqIHN5bmNJdGVyYWJsZTtcbiAgICAgICAgfSgpKTtcbiAgICAgICAgLy8gUmV0dXJuIGFzIGFuIGFzeW5jIGl0ZXJhdG9yIHJlY29yZC5cbiAgICAgICAgY29uc3QgbmV4dE1ldGhvZCA9IGFzeW5jSXRlcmF0b3IubmV4dDtcbiAgICAgICAgcmV0dXJuIHsgaXRlcmF0b3I6IGFzeW5jSXRlcmF0b3IsIG5leHRNZXRob2QsIGRvbmU6IGZhbHNlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEdldEl0ZXJhdG9yKG9iaiwgaGludCA9ICdzeW5jJywgbWV0aG9kKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGhpbnQgPT09ICdhc3luYycpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBHZXRNZXRob2Qob2JqLCBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3luY01ldGhvZCA9IEdldE1ldGhvZChvYmosIFN5bWJvbFBvbHlmaWxsLml0ZXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3luY0l0ZXJhdG9yUmVjb3JkID0gR2V0SXRlcmF0b3Iob2JqLCAnc3luYycsIHN5bmNNZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQ3JlYXRlQXN5bmNGcm9tU3luY0l0ZXJhdG9yKHN5bmNJdGVyYXRvclJlY29yZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gR2V0TWV0aG9kKG9iaiwgU3ltYm9sUG9seWZpbGwuaXRlcmF0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIG9iamVjdCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHJlZmxlY3RDYWxsKG1ldGhvZCwgb2JqLCBbXSk7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KGl0ZXJhdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGl0ZXJhdG9yIG1ldGhvZCBtdXN0IHJldHVybiBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TWV0aG9kID0gaXRlcmF0b3IubmV4dDtcbiAgICAgICAgcmV0dXJuIHsgaXRlcmF0b3IsIG5leHRNZXRob2QsIGRvbmU6IGZhbHNlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEl0ZXJhdG9yTmV4dChpdGVyYXRvclJlY29yZCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWZsZWN0Q2FsbChpdGVyYXRvclJlY29yZC5uZXh0TWV0aG9kLCBpdGVyYXRvclJlY29yZC5pdGVyYXRvciwgW10pO1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdChyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgaXRlcmF0b3IubmV4dCgpIG1ldGhvZCBtdXN0IHJldHVybiBhbiBvYmplY3QnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBJdGVyYXRvckNvbXBsZXRlKGl0ZXJSZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oaXRlclJlc3VsdC5kb25lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXRlcmF0b3JWYWx1ZShpdGVyUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBpdGVyUmVzdWx0LnZhbHVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIElzTm9uTmVnYXRpdmVOdW1iZXIodikge1xuICAgICAgICBpZiAodHlwZW9mIHYgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlcklzTmFOKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIENsb25lQXNVaW50OEFycmF5KE8pIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQXJyYXlCdWZmZXJTbGljZShPLmJ1ZmZlciwgTy5ieXRlT2Zmc2V0LCBPLmJ5dGVPZmZzZXQgKyBPLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEZXF1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBhaXIgPSBjb250YWluZXIuX3F1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgLT0gcGFpci5zaXplO1xuICAgICAgICBpZiAoY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWlyLnZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250YWluZXIsIHZhbHVlLCBzaXplKSB7XG4gICAgICAgIGlmICghSXNOb25OZWdhdGl2ZU51bWJlcihzaXplKSB8fCBzaXplID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1NpemUgbXVzdCBiZSBhIGZpbml0ZSwgbm9uLU5hTiwgbm9uLW5lZ2F0aXZlIG51bWJlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIuX3F1ZXVlLnB1c2goeyB2YWx1ZSwgc2l6ZSB9KTtcbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBzaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQZWVrUXVldWVWYWx1ZShjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFpciA9IGNvbnRhaW5lci5fcXVldWUucGVlaygpO1xuICAgICAgICByZXR1cm4gcGFpci52YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVzZXRRdWV1ZShjb250YWluZXIpIHtcbiAgICAgICAgY29udGFpbmVyLl9xdWV1ZSA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGFWaWV3Q29uc3RydWN0b3IoY3Rvcikge1xuICAgICAgICByZXR1cm4gY3RvciA9PT0gRGF0YVZpZXc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzRGF0YVZpZXcodmlldykge1xuICAgICAgICByZXR1cm4gaXNEYXRhVmlld0NvbnN0cnVjdG9yKHZpZXcuY29uc3RydWN0b3IpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcnJheUJ1ZmZlclZpZXdFbGVtZW50U2l6ZShjdG9yKSB7XG4gICAgICAgIGlmIChpc0RhdGFWaWV3Q29uc3RydWN0b3IoY3RvcikpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdG9yLkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgcHVsbC1pbnRvIHJlcXVlc3QgaW4gYSB7QGxpbmsgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcn0uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSB2aWV3IGZvciB3cml0aW5nIGluIHRvLCBvciBgbnVsbGAgaWYgdGhlIEJZT0IgcmVxdWVzdCBoYXMgYWxyZWFkeSBiZWVuIHJlc3BvbmRlZCB0by5cbiAgICAgICAgICovXG4gICAgICAgIGdldCB2aWV3KCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3ZpZXcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3O1xuICAgICAgICB9XG4gICAgICAgIHJlc3BvbmQoYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigncmVzcG9uZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChieXRlc1dyaXR0ZW4sIDEsICdyZXNwb25kJyk7XG4gICAgICAgICAgICBieXRlc1dyaXR0ZW4gPSBjb252ZXJ0VW5zaWduZWRMb25nTG9uZ1dpdGhFbmZvcmNlUmFuZ2UoYnl0ZXNXcml0dGVuLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih0aGlzLl92aWV3LmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgQllPQiByZXF1ZXN0J3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc3BvbnNlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXNwb25kV2l0aE5ld1ZpZXcodmlldykge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Jlc3BvbmRXaXRoTmV3VmlldycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudCh2aWV3LCAxLCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW4gb25seSByZXNwb25kIHdpdGggYXJyYXkgYnVmZmVyIHZpZXdzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgZ2l2ZW4gdmlld1xcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkIGFuZCBzbyBjYW5ub3QgYmUgdXNlZCBhcyBhIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KHRoaXMuX2Fzc29jaWF0ZWRSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLCB2aWV3KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwge1xuICAgICAgICByZXNwb25kOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgcmVzcG9uZFdpdGhOZXdWaWV3OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgdmlldzogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZCwgJ3Jlc3BvbmQnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGhOZXdWaWV3LCAncmVzcG9uZFdpdGhOZXdWaWV3Jyk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0JyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGNvbnRyb2wgb2YgYSB7QGxpbmsgUmVhZGFibGVTdHJlYW0gfCByZWFkYWJsZSBieXRlIHN0cmVhbX0ncyBzdGF0ZSBhbmQgaW50ZXJuYWwgcXVldWUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWxsZWdhbCBjb25zdHJ1Y3RvcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IEJZT0IgcHVsbCByZXF1ZXN0LCBvciBgbnVsbGAgaWYgdGhlcmUgaXNuJ3Qgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGJ5b2JSZXF1ZXN0KCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2J5b2JSZXF1ZXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgY29udHJvbGxlZCBzdHJlYW0ncyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXNcbiAgICAgICAgICogb3Zlci1mdWxsLiBBbiB1bmRlcmx5aW5nIGJ5dGUgc291cmNlIG91Z2h0IHRvIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGVuIGFuZCBob3cgdG8gYXBwbHkgYmFja3ByZXNzdXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLiBDb25zdW1lcnMgd2lsbCBzdGlsbCBiZSBhYmxlIHRvIHJlYWQgYW55IHByZXZpb3VzbHktZW5xdWV1ZWQgY2h1bmtzIGZyb21cbiAgICAgICAgICogdGhlIHN0cmVhbSwgYnV0IG9uY2UgdGhvc2UgYXJlIHJlYWQsIHRoZSBzdHJlYW0gd2lsbCBiZWNvbWUgY2xvc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQ7IGRvIG5vdCBjbG9zZSBpdCBhZ2FpbiEnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGNsb3NlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVucXVldWUoY2h1bmspIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdlbnF1ZXVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KGNodW5rLCAxLCAnZW5xdWV1ZScpO1xuICAgICAgICAgICAgaWYgKCFBcnJheUJ1ZmZlci5pc1ZpZXcoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2h1bmsgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaHVuayBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgY2h1bmsncyBidWZmZXIgbXVzdCBoYXZlIG5vbi16ZXJvIGJ5dGVMZW5ndGhgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmVhbSBpcyBjbG9zZWQgb3IgZHJhaW5pbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgc3RyZWFtIChpbiAke3N0YXRlfSBzdGF0ZSkgaXMgbm90IGluIHRoZSByZWFkYWJsZSBzdGF0ZSBhbmQgY2Fubm90IGJlIGVucXVldWVkIHRvYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9ycyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0sIG1ha2luZyBhbGwgZnV0dXJlIGludGVyYWN0aW9ucyB3aXRoIGl0IGZhaWwgd2l0aCB0aGUgZ2l2ZW4gZXJyb3IgYGVgLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IoZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyh0aGlzKTtcbiAgICAgICAgICAgIFJlc2V0UXVldWUodGhpcyk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW1B1bGxTdGVwc10ocmVhZFJlcXVlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxSZWFkUmVxdWVzdEZyb21RdWV1ZSh0aGlzLCByZWFkUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdGhpcy5fYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICAgICAgICAgICAgaWYgKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGJ1ZmZlckUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJlcXVlc3QuX2Vycm9yU3RlcHMoYnVmZmVyRSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZU9mZnNldDogMCxcbiAgICAgICAgICAgICAgICAgICAgYnl0ZUxlbmd0aDogYXV0b0FsbG9jYXRlQ2h1bmtTaXplLFxuICAgICAgICAgICAgICAgICAgICBieXRlc0ZpbGxlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bUZpbGw6IDEsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplOiAxLFxuICAgICAgICAgICAgICAgICAgICB2aWV3Q29uc3RydWN0b3I6IFVpbnQ4QXJyYXksXG4gICAgICAgICAgICAgICAgICAgIHJlYWRlclR5cGU6ICdkZWZhdWx0J1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wdXNoKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbUmVsZWFzZVN0ZXBzXSgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdFB1bGxJbnRvID0gdGhpcy5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICAgICAgZmlyc3RQdWxsSW50by5yZWFkZXJUeXBlID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnB1c2goZmlyc3RQdWxsSW50byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIHtcbiAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBieW9iUmVxdWVzdDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGRlc2lyZWRTaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5jbG9zZSwgJ2Nsb3NlJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUsICdlbnF1ZXVlJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yLCAnZXJyb3InKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gVE9ETzogVGVzdCBjb250cm9sbGVyIGFyZ3VtZW50XG4gICAgICAgIGNvbnN0IHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwdWxsUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2Fpbikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIGUgPT4ge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IucmVhZGVyVHlwZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkUmVxdWVzdChzdHJlYW0sIGZpbGxlZFZpZXcsIGRvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZEludG9SZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICBjb25zdCBlbGVtZW50U2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBwdWxsSW50b0Rlc2NyaXB0b3Iudmlld0NvbnN0cnVjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCBieXRlc0ZpbGxlZCAvIGVsZW1lbnRTaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlLnB1c2goeyBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSk7XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplICs9IGJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2xvbmVkQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgICBsZXQgY2xvbmVkQ2h1bms7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbG9uZWRDaHVuayA9IEFycmF5QnVmZmVyU2xpY2UoYnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlT2Zmc2V0ICsgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNsb25lRSk7XG4gICAgICAgICAgICB0aHJvdyBjbG9uZUU7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgY2xvbmVkQ2h1bmssIDAsIGJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkID4gMCkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDbG9uZWRDaHVua1RvUXVldWUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciwgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgICAgICAgY29uc3QgbWF4Qnl0ZXNUb0NvcHkgPSBNYXRoLm1pbihjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICAgICAgICBjb25zdCBtYXhCeXRlc0ZpbGxlZCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIG1heEJ5dGVzVG9Db3B5O1xuICAgICAgICBsZXQgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEJ5dGVzVG9Db3B5O1xuICAgICAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyQnl0ZXMgPSBtYXhCeXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgY29uc3QgbWF4QWxpZ25lZEJ5dGVzID0gbWF4Qnl0ZXNGaWxsZWQgLSByZW1haW5kZXJCeXRlcztcbiAgICAgICAgLy8gQSBkZXNjcmlwdG9yIGZvciBhIHJlYWQoKSByZXF1ZXN0IHRoYXQgaXMgbm90IHlldCBmaWxsZWQgdXAgdG8gaXRzIG1pbmltdW0gbGVuZ3RoIHdpbGwgc3RheSBhdCB0aGUgaGVhZFxuICAgICAgICAvLyBvZiB0aGUgcXVldWUsIHNvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBjYW4ga2VlcCBmaWxsaW5nIGl0LlxuICAgICAgICBpZiAobWF4QWxpZ25lZEJ5dGVzID49IHB1bGxJbnRvRGVzY3JpcHRvci5taW5pbXVtRmlsbCkge1xuICAgICAgICAgICAgdG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA9IG1heEFsaWduZWRCeXRlcyAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuICAgICAgICB3aGlsZSAodG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRPZlF1ZXVlID0gcXVldWUucGVlaygpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXNUb0NvcHkgPSBNYXRoLm1pbih0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nLCBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc3RTdGFydCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgICAgICAgICAgQ29weURhdGFCbG9ja0J5dGVzKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGRlc3RTdGFydCwgaGVhZE9mUXVldWUuYnVmZmVyLCBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0LCBieXRlc1RvQ29weSk7XG4gICAgICAgICAgICBpZiAoaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCA9PT0gYnl0ZXNUb0NvcHkpIHtcbiAgICAgICAgICAgICAgICBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZE9mUXVldWUuYnl0ZU9mZnNldCArPSBieXRlc1RvQ29weTtcbiAgICAgICAgICAgICAgICBoZWFkT2ZRdWV1ZS5ieXRlTGVuZ3RoIC09IGJ5dGVzVG9Db3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgLT0gYnl0ZXNUb0NvcHk7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNUb0NvcHksIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nIC09IGJ5dGVzVG9Db3B5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWFkeTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxIZWFkUHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIsIHNpemUsIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICAgICAgICBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKz0gc2l6ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDAgJiYgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdChjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QuX3ZpZXcgPSBudWxsO1xuICAgICAgICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcikge1xuICAgICAgICB3aGlsZSAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwdWxsSW50b0Rlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICAgICAgICAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1JlYWRSZXF1ZXN0c1VzaW5nUXVldWUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIHdoaWxlIChyZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFJlYWRSZXF1ZXN0RnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oY29udHJvbGxlciwgdmlldywgbWluLCByZWFkSW50b1JlcXVlc3QpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgY29uc3QgY3RvciA9IHZpZXcuY29uc3RydWN0b3I7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRTaXplID0gYXJyYXlCdWZmZXJWaWV3RWxlbWVudFNpemUoY3Rvcik7XG4gICAgICAgIGNvbnN0IHsgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9ID0gdmlldztcbiAgICAgICAgY29uc3QgbWluaW11bUZpbGwgPSBtaW4gKiBlbGVtZW50U2l6ZTtcbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIodmlldy5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHVsbEludG9EZXNjcmlwdG9yID0ge1xuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgYnVmZmVyQnl0ZUxlbmd0aDogYnVmZmVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBieXRlT2Zmc2V0LFxuICAgICAgICAgICAgYnl0ZUxlbmd0aCxcbiAgICAgICAgICAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgICAgICAgICAgbWluaW11bUZpbGwsXG4gICAgICAgICAgICBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIHZpZXdDb25zdHJ1Y3RvcjogY3RvcixcbiAgICAgICAgICAgIHJlYWRlclR5cGU6ICdieW9iJ1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIC8vIE5vIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKCkgY2FsbCBzaW5jZTpcbiAgICAgICAgICAgIC8vIC0gTm8gY2hhbmdlIGhhcHBlbnMgb24gZGVzaXJlZFNpemVcbiAgICAgICAgICAgIC8vIC0gVGhlIHNvdXJjZSBoYXMgYWxyZWFkeSBiZWVuIG5vdGlmaWVkIG9mIHRoYXQgdGhlcmUncyBhdCBsZWFzdCAxIHBlbmRpbmcgcmVhZCh2aWV3KVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlWaWV3ID0gbmV3IGN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIDApO1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9jbG9zZVN0ZXBzKGVtcHR5Vmlldyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoZmlsbGVkVmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcikge1xuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSkge1xuICAgICAgICAgICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1bGxJbnRvRGVzY3JpcHRvciA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKHN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICBpZiAocHVsbEludG9EZXNjcmlwdG9yLnJlYWRlclR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVEZXRhY2hlZFB1bGxJbnRvVG9RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIDwgcHVsbEludG9EZXNjcmlwdG9yLm1pbmltdW1GaWxsKSB7XG4gICAgICAgICAgICAvLyBBIGRlc2NyaXB0b3IgZm9yIGEgcmVhZCgpIHJlcXVlc3QgdGhhdCBpcyBub3QgeWV0IGZpbGxlZCB1cCB0byBpdHMgbWluaW11bSBsZW5ndGggd2lsbCBzdGF5IGF0IHRoZSBoZWFkXG4gICAgICAgICAgICAvLyBvZiB0aGUgcXVldWUsIHNvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSBjYW4ga2VlcCBmaWxsaW5nIGl0LlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgY29uc3QgcmVtYWluZGVyU2l6ZSA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIHB1bGxJbnRvRGVzY3JpcHRvci5lbGVtZW50U2l6ZTtcbiAgICAgICAgaWYgKHJlbWFpbmRlclNpemUgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2xvbmVkQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGVuZCAtIHJlbWFpbmRlclNpemUsIHJlbWFpbmRlclNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtPSByZW1haW5kZXJTaXplO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29tbWl0UHVsbEludG9EZXNjcmlwdG9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUoY29udHJvbGxlciwgZmlyc3REZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW5SZWFkYWJsZVN0YXRlKGNvbnRyb2xsZXIsIGJ5dGVzV3JpdHRlbiwgZmlyc3REZXNjcmlwdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3Muc2hpZnQoKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250cm9sbGVyLl9zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBBIGNsaWVudCBvZiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICAgICAgICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgfHwgc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgaWYgKGZpcnN0UGVuZGluZ1B1bGxJbnRvLmJ5dGVzRmlsbGVkICUgZmlyc3RQZW5kaW5nUHVsbEludG8uZWxlbWVudFNpemUgIT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignSW5zdWZmaWNpZW50IGJ5dGVzIHRvIGZpbGwgZWxlbWVudHMgaW4gdGhlIGdpdmVuIGJ1ZmZlcicpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkIHx8IHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCB9ID0gY2h1bms7XG4gICAgICAgIGlmIChJc0RldGFjaGVkQnVmZmVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NodW5rXFwncyBidWZmZXIgaXMgZGV0YWNoZWQgYW5kIHNvIGNhbm5vdCBiZSBlbnF1ZXVlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZmVycmVkQnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihidWZmZXIpO1xuICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFBlbmRpbmdQdWxsSW50byA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIoZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBCWU9CIHJlcXVlc3RcXCdzIGJ1ZmZlciBoYXMgYmVlbiBkZXRhY2hlZCBhbmQgc28gY2Fubm90IGJlIGZpbGxlZCB3aXRoIGFuIGVucXVldWVkIGNodW5rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgZmlyc3RQZW5kaW5nUHVsbEludG8uYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdFBlbmRpbmdQdWxsSW50by5idWZmZXIpO1xuICAgICAgICAgICAgaWYgKGZpcnN0UGVuZGluZ1B1bGxJbnRvLnJlYWRlclR5cGUgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlRGV0YWNoZWRQdWxsSW50b1RvUXVldWUoY29udHJvbGxlciwgZmlyc3RQZW5kaW5nUHVsbEludG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIoc3RyZWFtKSkge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NSZWFkUmVxdWVzdHNVc2luZ1F1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IElkZWFsbHkgaW4gdGhpcyBicmFuY2ggZGV0YWNoaW5nIHNob3VsZCBoYXBwZW4gb25seSBpZiB0aGUgYnVmZmVyIGlzIG5vdCBjb25zdW1lZCBmdWxseS5cbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICAgICAgIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKTtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFJlYWRSZXF1ZXN0RnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHJlYWRSZXF1ZXN0KSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gY29udHJvbGxlci5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgLT0gZW50cnkuYnl0ZUxlbmd0aDtcbiAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShlbnRyeS5idWZmZXIsIGVudHJ5LmJ5dGVPZmZzZXQsIGVudHJ5LmJ5dGVMZW5ndGgpO1xuICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyh2aWV3KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSBudWxsICYmIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5wZWVrKCk7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciwgZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQsIGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoIC0gZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSk7XG4gICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoYnlvYlJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpO1xuICAgICAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBieW9iUmVxdWVzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fYnlvYlJlcXVlc3Q7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNXcml0dGVuICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGJ5dGVzV3JpdHRlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwIHdoZW4gY2FsbGluZyByZXNwb25kKCkgb24gYSByZWFkYWJsZSBzdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBieXRlc1dyaXR0ZW4gPiBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdieXRlc1dyaXR0ZW4gb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3REZXNjcmlwdG9yLmJ1ZmZlciA9IFRyYW5zZmVyQXJyYXlCdWZmZXIoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlcik7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyhjb250cm9sbGVyLCB2aWV3KSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICBpZiAodmlldy5ieXRlTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZpZXdcXCdzIGxlbmd0aCBtdXN0IGJlIDAgd2hlbiBjYWxsaW5nIHJlc3BvbmRXaXRoTmV3VmlldygpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZpZXcuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2aWV3XFwncyBsZW5ndGggbXVzdCBiZSBncmVhdGVyIHRoYW4gMCB3aGVuIGNhbGxpbmcgcmVzcG9uZFdpdGhOZXdWaWV3KCkgb24gYSByZWFkYWJsZSBzdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgIT09IHZpZXcuYnl0ZU9mZnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgZG9lcyBub3QgbWF0Y2ggYnlvYlJlcXVlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ1ZmZlckJ5dGVMZW5ndGggIT09IHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgYnVmZmVyIG9mIHZpZXcgaGFzIGRpZmZlcmVudCBjYXBhY2l0eSB0aGFuIGJ5b2JSZXF1ZXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIHZpZXcuYnl0ZUxlbmd0aCA+IGZpcnN0RGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHJlZ2lvbiBzcGVjaWZpZWQgYnkgdmlldyBpcyBsYXJnZXIgdGhhbiBieW9iUmVxdWVzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZpZXdCeXRlTGVuZ3RoID0gdmlldy5ieXRlTGVuZ3RoO1xuICAgICAgICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG4gICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlld0J5dGVMZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpIHtcbiAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fYnlvYlJlcXVlc3QgPSBudWxsO1xuICAgICAgICAvLyBOZWVkIHRvIHNldCB0aGUgc2xvdHMgc28gdGhhdCB0aGUgYXNzZXJ0IGRvZXNuJ3QgZmlyZS4gSW4gdGhlIHNwZWMgdGhlIHNsb3RzIGFscmVhZHkgZXhpc3QgaW1wbGljaXRseS5cbiAgICAgICAgY29udHJvbGxlci5fcXVldWUgPSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgICAgICAgY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHN0YXJ0UmVzdWx0ID0gc3RhcnRBbGdvcml0aG0oKTtcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCksICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgciA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ0J5dGVTb3VyY2UsIGhpZ2hXYXRlck1hcmspIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgc3RhcnRBbGdvcml0aG07XG4gICAgICAgIGxldCBwdWxsQWxnb3JpdGhtO1xuICAgICAgICBsZXQgY2FuY2VsQWxnb3JpdGhtO1xuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5zdGFydChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHB1bGxBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ0J5dGVTb3VyY2UuY2FuY2VsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9IHJlYXNvbiA9PiB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5jYW5jZWwocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbmNlbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPSB1bmRlcmx5aW5nQnl0ZVNvdXJjZS5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwJyk7XG4gICAgICAgIH1cbiAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KHJlcXVlc3QsIGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgICAgICAgcmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICByZXF1ZXN0Ll92aWV3ID0gdmlldztcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QuXG4gICAgZnVuY3Rpb24gYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3RgKTtcbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UmVhZGVyT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubW9kZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGU6IG1vZGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnbW9kZScgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUobW9kZSwgY29udGV4dCkge1xuICAgICAgICBtb2RlID0gYCR7bW9kZX1gO1xuICAgICAgICBpZiAobW9kZSAhPT0gJ2J5b2InKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke21vZGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1SZWFkZXJNb2RlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRCeW9iUmVhZE9wdGlvbnMob3B0aW9ucywgY29udGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IG1pbiA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW46IGNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZShtaW4sIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ21pbicgdGhhdGApXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSk7XG4gICAgfVxuICAgIC8vIFJlYWRhYmxlU3RyZWFtIEFQSSBleHBvc2VkIGZvciBjb250cm9sbGVycy5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICBzdHJlYW0uX3JlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5wdXNoKHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRJbnRvUmVxdWVzdChzdHJlYW0sIGNodW5rLCBkb25lKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyhjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2NodW5rU3RlcHMoY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgQllPQiByZWFkZXIgdmVuZGVkIGJ5IGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICAgICAgICAgIGFzc2VydFJlcXVpcmVkQXJndW1lbnQoc3RyZWFtLCAxLCAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyk7XG4gICAgICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShzdHJlYW0sICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb25zdHJ1Y3QgYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIgZm9yIGEgc3RyZWFtIG5vdCBjb25zdHJ1Y3RlZCB3aXRoIGEgYnl0ZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3NvdXJjZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZSh0aGlzLCBzdHJlYW0pO1xuICAgICAgICAgICAgdGhpcy5fcmVhZEludG9SZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIHN0cmVhbSBiZWNvbWVzIGNsb3NlZCwgb3IgcmVqZWN0ZWQgaWYgdGhlIHN0cmVhbSBldmVyIGVycm9ycyBvclxuICAgICAgICAgKiB0aGUgcmVhZGVyJ3MgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBSZWFkYWJsZVN0cmVhbS5jYW5jZWwgfCBzdHJlYW0uY2FuY2VsKHJlYXNvbil9LlxuICAgICAgICAgKi9cbiAgICAgICAgY2FuY2VsKHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjYW5jZWwnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgocmVhZGVyTG9ja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0NhbmNlbCh0aGlzLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJlYWQodmlldywgcmF3T3B0aW9ucyA9IHt9KSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlYWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2aWV3LmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCd2aWV3IG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZpZXcuYnVmZmVyLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGB2aWV3J3MgYnVmZmVyIG11c3QgaGF2ZSBub24temVybyBieXRlTGVuZ3RoYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzRGV0YWNoZWRCdWZmZXIodmlldy5idWZmZXIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlld1xcJ3MgYnVmZmVyIGhhcyBiZWVuIGRldGFjaGVkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0QnlvYlJlYWRPcHRpb25zKHJhd09wdGlvbnMsICdvcHRpb25zJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWluID0gb3B0aW9ucy5taW47XG4gICAgICAgICAgICBpZiAobWluID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignb3B0aW9ucy5taW4gbXVzdCBiZSBncmVhdGVyIHRoYW4gMCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNEYXRhVmlldyh2aWV3KSkge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPiB2aWV3Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgUmFuZ2VFcnJvcignb3B0aW9ucy5taW4gbXVzdCBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdmlld1xcJ3MgbGVuZ3RoJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1pbiA+IHZpZXcuYnl0ZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBSYW5nZUVycm9yKCdvcHRpb25zLm1pbiBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB2aWV3XFwncyBieXRlTGVuZ3RoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNvbHZlUHJvbWlzZTtcbiAgICAgICAgICAgIGxldCByZWplY3RQcm9taXNlO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICByZWplY3RQcm9taXNlID0gcmVqZWN0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHJlc29sdmVQcm9taXNlKHsgdmFsdWU6IGNodW5rLCBkb25lOiBmYWxzZSB9KSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogY2h1bmsgPT4gcmVzb2x2ZVByb21pc2UoeyB2YWx1ZTogY2h1bmssIGRvbmU6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgX2Vycm9yU3RlcHM6IGUgPT4gcmVqZWN0UHJvbWlzZShlKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQodGhpcywgdmlldywgbWluLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbGVhc2VzIHRoZSByZWFkZXIncyBsb2NrIG9uIHRoZSBjb3JyZXNwb25kaW5nIHN0cmVhbS4gQWZ0ZXIgdGhlIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZWFkZXIgaXMgbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICAgICAgICogSWYgdGhlIGFzc29jaWF0ZWQgc3RyZWFtIGlzIGVycm9yZWQgd2hlbiB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHJlYWRlciB3aWxsIGFwcGVhciBlcnJvcmVkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgKiBmcm9tIG5vdyBvbjsgb3RoZXJ3aXNlLCB0aGUgcmVhZGVyIHdpbGwgYXBwZWFyIGNsb3NlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSByZWFkZXIncyBsb2NrIGNhbm5vdCBiZSByZWxlYXNlZCB3aGlsZSBpdCBzdGlsbCBoYXMgYSBwZW5kaW5nIHJlYWQgcmVxdWVzdCwgaS5lLiwgaWYgYSBwcm9taXNlIHJldHVybmVkIGJ5XG4gICAgICAgICAqIHRoZSByZWFkZXIncyB7QGxpbmsgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnJlYWQgfCByZWFkKCl9IG1ldGhvZCBoYXMgbm90IHlldCBiZWVuIHNldHRsZWQuIEF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogZG8gc28gd2lsbCB0aHJvdyBhIGBUeXBlRXJyb3JgIGFuZCBsZWF2ZSB0aGUgcmVhZGVyIGxvY2tlZCB0byB0aGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVsZWFzZUxvY2soKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnlvYlJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fb3duZXJSZWFkYWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVsZWFzZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGNhbmNlbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlYWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICByZWxlYXNlTG9jazogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGNsb3NlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS5jYW5jZWwsICdjYW5jZWwnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS5yZWFkLCAncmVhZCcpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrLCAncmVsZWFzZUxvY2snKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIHJlYWRlcnMuXG4gICAgZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZEludG9SZXF1ZXN0cycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmVhZEludG9SZXF1ZXN0Ll9lcnJvclN0ZXBzKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2aWV3LCBtaW4sIHJlYWRJbnRvUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVsZWFzZShyZWFkZXIpIHtcbiAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcignUmVhZGVyIHdhcyByZWxlYXNlZCcpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJFcnJvclJlYWRJbnRvUmVxdWVzdHMocmVhZGVyLCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyRXJyb3JSZWFkSW50b1JlcXVlc3RzKHJlYWRlciwgZSkge1xuICAgICAgICBjb25zdCByZWFkSW50b1JlcXVlc3RzID0gcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzO1xuICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKHJlYWRJbnRvUmVxdWVzdCA9PiB7XG4gICAgICAgICAgICByZWFkSW50b1JlcXVlc3QuX2Vycm9yU3RlcHMoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLlxuICAgIGZ1bmN0aW9uIGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlci5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyYCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gRXh0cmFjdEhpZ2hXYXRlck1hcmsoc3RyYXRlZ3ksIGRlZmF1bHRIV00pIHtcbiAgICAgICAgY29uc3QgeyBoaWdoV2F0ZXJNYXJrIH0gPSBzdHJhdGVneTtcbiAgICAgICAgaWYgKGhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRIV007XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBoaWdoV2F0ZXJNYXJrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZ2hXYXRlck1hcms7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEV4dHJhY3RTaXplQWxnb3JpdGhtKHN0cmF0ZWd5KSB7XG4gICAgICAgIGNvbnN0IHsgc2l6ZSB9ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFF1ZXVpbmdTdHJhdGVneShpbml0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5zaXplO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGlnaFdhdGVyTWFyazogaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogY29udmVydFVucmVzdHJpY3RlZERvdWJsZShoaWdoV2F0ZXJNYXJrKSxcbiAgICAgICAgICAgIHNpemU6IHNpemUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lTaXplKHNpemUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpemUnIHRoYXRgKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZShmbiwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiBjaHVuayA9PiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGZuKGNodW5rKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rKG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3JpZ2luYWwsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBhYm9ydCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5hYm9ydDtcbiAgICAgICAgY29uc3QgY2xvc2UgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuY2xvc2U7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuICAgICAgICBjb25zdCB0eXBlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnR5cGU7XG4gICAgICAgIGNvbnN0IHdyaXRlID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLndyaXRlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWJvcnQ6IGFib3J0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rQWJvcnRDYWxsYmFjayhhYm9ydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ2Fib3J0JyB0aGF0YCksXG4gICAgICAgICAgICBjbG9zZTogY2xvc2UgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGNsb3NlLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2xvc2UnIHRoYXRgKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2soc3RhcnQsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdzdGFydCcgdGhhdGApLFxuICAgICAgICAgICAgd3JpdGU6IHdyaXRlID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayh3cml0ZSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3dyaXRlJyB0aGF0YCksXG4gICAgICAgICAgICB0eXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU2lua0Fib3J0Q2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChyZWFzb24pID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW3JlYXNvbl0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NpbmtDbG9zZUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTaW5rV3JpdGVDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNodW5rLCBjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjaHVuaywgY29udHJvbGxlcl0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzc2VydFdyaXRhYmxlU3RyZWFtKHgsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9IGlzIG5vdCBhIFdyaXRhYmxlU3RyZWFtLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBYm9ydFNpZ25hbCh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLmFib3J0ZWQgPT09ICdib29sZWFuJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIC8vIEFib3J0U2lnbmFsLnByb3RvdHlwZS5hYm9ydGVkIHRocm93cyBpZiBpdHMgYnJhbmQgY2hlY2sgZmFpbHNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdXBwb3J0c0Fib3J0Q29udHJvbGxlciA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgPT09ICdmdW5jdGlvbic7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGEgbmV3IEFib3J0Q29udHJvbGxlciwgaWYgc3VwcG9ydGVkIGJ5IHRoZSBwbGF0Zm9ybS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFib3J0Q29udHJvbGxlcigpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzQWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSB3cml0YWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIGRlc3RpbmF0aW9uIGZvciBkYXRhLCBpbnRvIHdoaWNoIHlvdSBjYW4gd3JpdGUuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgV3JpdGFibGVTdHJlYW0ge1xuICAgICAgICBjb25zdHJ1Y3RvcihyYXdVbmRlcmx5aW5nU2luayA9IHt9LCByYXdTdHJhdGVneSA9IHt9KSB7XG4gICAgICAgICAgICBpZiAocmF3VW5kZXJseWluZ1NpbmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJhd1VuZGVybHlpbmdTaW5rID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFzc2VydE9iamVjdChyYXdVbmRlcmx5aW5nU2luaywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1N0cmF0ZWd5LCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgY29uc3QgdW5kZXJseWluZ1NpbmsgPSBjb252ZXJ0VW5kZXJseWluZ1NpbmsocmF3VW5kZXJseWluZ1NpbmssICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB1bmRlcmx5aW5nU2luay50eXBlO1xuICAgICAgICAgICAgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGUgaXMgc3BlY2lmaWVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0oc3RyYXRlZ3kpO1xuICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcbiAgICAgICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayh0aGlzLCB1bmRlcmx5aW5nU2luaywgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIHdyaXRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB3cml0ZXIuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgbG9ja2VkKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdsb2NrZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBYm9ydHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIHRoYXQgdGhlIHByb2R1Y2VyIGNhbiBubyBsb25nZXIgc3VjY2Vzc2Z1bGx5IHdyaXRlIHRvIHRoZSBzdHJlYW0gYW5kIGl0IGlzIHRvIGJlXG4gICAgICAgICAqIGltbWVkaWF0ZWx5IG1vdmVkIHRvIGFuIGVycm9yZWQgc3RhdGUsIHdpdGggYW55IHF1ZXVlZC11cCB3cml0ZXMgZGlzY2FyZGVkLiBUaGlzIHdpbGwgYWxzbyBleGVjdXRlIGFueSBhYm9ydFxuICAgICAgICAgKiBtZWNoYW5pc20gb2YgdGhlIHVuZGVybHlpbmcgc2luay5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCBmdWxmaWxsIGlmIHRoZSBzdHJlYW0gc2h1dHMgZG93biBzdWNjZXNzZnVsbHksIG9yIHJlamVjdCBpZiB0aGUgdW5kZXJseWluZyBzaW5rIHNpZ25hbGVkXG4gICAgICAgICAqIHRoYXQgdGhlcmUgd2FzIGFuIGVycm9yIGRvaW5nIHNvLiBBZGRpdGlvbmFsbHksIGl0IHdpbGwgcmVqZWN0IHdpdGggYSBgVHlwZUVycm9yYCAod2l0aG91dCBhdHRlbXB0aW5nIHRvIGNhbmNlbFxuICAgICAgICAgKiB0aGUgc3RyZWFtKSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBsb2NrZWQuXG4gICAgICAgICAqL1xuICAgICAgICBhYm9ydChyZWFzb24gPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBhYm9ydCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgd3JpdGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQodGhpcywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBzdHJlYW0uIFRoZSB1bmRlcmx5aW5nIHNpbmsgd2lsbCBmaW5pc2ggcHJvY2Vzc2luZyBhbnkgcHJldmlvdXNseS13cml0dGVuIGNodW5rcywgYmVmb3JlIGludm9raW5nIGl0c1xuICAgICAgICAgKiBjbG9zZSBiZWhhdmlvci4gRHVyaW5nIHRoaXMgdGltZSBhbnkgZnVydGhlciBhdHRlbXB0cyB0byB3cml0ZSB3aWxsIGZhaWwgKHdpdGhvdXQgZXJyb3JpbmcgdGhlIHN0cmVhbSkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGZ1bGZpbGwgaWYgYWxsIHJlbWFpbmluZyBjaHVua3MgYXJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIGFuZCB0aGUgc3RyZWFtXG4gICAgICAgICAqIHN1Y2Nlc3NmdWxseSBjbG9zZXMsIG9yIHJlamVjdHMgaWYgYW4gZXJyb3IgaXMgZW5jb3VudGVyZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcy4gQWRkaXRpb25hbGx5LCBpdCB3aWxsIHJlamVjdCB3aXRoXG4gICAgICAgICAqIGEgYFR5cGVFcnJvcmAgKHdpdGhvdXQgYXR0ZW1wdGluZyB0byBjYW5jZWwgdGhlIHN0cmVhbSkgaWYgdGhlIHN0cmVhbSBpcyBjdXJyZW50bHkgbG9ja2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2Nsb3NlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIHwgd3JpdGVyfSBhbmQgbG9ja3MgdGhlIHN0cmVhbSB0byB0aGUgbmV3IHdyaXRlci4gV2hpbGUgdGhlIHN0cmVhbVxuICAgICAgICAgKiBpcyBsb2NrZWQsIG5vIG90aGVyIHdyaXRlciBjYW4gYmUgYWNxdWlyZWQgdW50aWwgdGhpcyBvbmUgaXMgcmVsZWFzZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBlc3BlY2lhbGx5IHVzZWZ1bCBmb3IgY3JlYXRpbmcgYWJzdHJhY3Rpb25zIHRoYXQgZGVzaXJlIHRoZSBhYmlsaXR5IHRvIHdyaXRlIHRvIGEgc3RyZWFtXG4gICAgICAgICAqIHdpdGhvdXQgaW50ZXJydXB0aW9uIG9yIGludGVybGVhdmluZy4gQnkgZ2V0dGluZyBhIHdyaXRlciBmb3IgdGhlIHN0cmVhbSwgeW91IGNhbiBlbnN1cmUgbm9ib2R5IGVsc2UgY2FuIHdyaXRlIGF0XG4gICAgICAgICAqIHRoZSBzYW1lIHRpbWUsIHdoaWNoIHdvdWxkIGNhdXNlIHRoZSByZXN1bHRpbmcgd3JpdHRlbiBkYXRhIHRvIGJlIHVucHJlZGljdGFibGUgYW5kIHByb2JhYmx5IHVzZWxlc3MuXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXcml0ZXIoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ2dldFdyaXRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgIGFib3J0OiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgY2xvc2U6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBnZXRXcml0ZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBsb2NrZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5hYm9ydCwgJ2Fib3J0Jyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5jbG9zZSwgJ2Nsb3NlJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRXcml0ZXIsICdnZXRXcml0ZXInKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdXcml0YWJsZVN0cmVhbScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbS5cbiAgICBmdW5jdGlvbiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihzdHJlYW0pO1xuICAgIH1cbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuICAgIGZ1bmN0aW9uIENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrID0gMSwgc2l6ZUFsZ29yaXRobSA9ICgpID0+IDEpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUpO1xuICAgICAgICBJbml0aWFsaXplV3JpdGFibGVTdHJlYW0oc3RyZWFtKTtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XG4gICAgICAgIC8vIFRoZSBlcnJvciB0aGF0IHdpbGwgYmUgcmVwb3J0ZWQgYnkgbmV3IG1ldGhvZCBjYWxscyBvbmNlIHRoZSBzdGF0ZSBiZWNvbWVzIGVycm9yZWQuIE9ubHkgc2V0IHdoZW4gW1tzdGF0ZV1dIGlzXG4gICAgICAgIC8vICdlcnJvcmluZycgb3IgJ2Vycm9yZWQnLiBNYXkgYmUgc2V0IHRvIGFuIHVuZGVmaW5lZCB2YWx1ZS5cbiAgICAgICAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdG8gdW5kZWZpbmVkIGZpcnN0IGJlY2F1c2UgdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBjb250cm9sbGVyIGNoZWNrcyB0aGlzXG4gICAgICAgIC8vIHZhcmlhYmxlIHRvIHZhbGlkYXRlIHRoZSBjYWxsZXIuXG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGlzIHF1ZXVlIGlzIHBsYWNlZCBoZXJlIGluc3RlYWQgb2YgdGhlIHdyaXRlciBjbGFzcyBpbiBvcmRlciB0byBhbGxvdyBmb3IgcGFzc2luZyBhIHdyaXRlciB0byB0aGUgbmV4dCBkYXRhXG4gICAgICAgIC8vIHByb2R1Y2VyIHdpdGhvdXQgd2FpdGluZyBmb3IgdGhlIHF1ZXVlZCB3cml0ZXMgdG8gZmluaXNoLlxuICAgICAgICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgLy8gV3JpdGUgcmVxdWVzdHMgYXJlIHJlbW92ZWQgZnJvbSBfd3JpdGVSZXF1ZXN0cyB3aGVuIHdyaXRlKCkgaXMgY2FsbGVkIG9uIHRoZSB1bmRlcmx5aW5nIHNpbmsuIFRoaXMgcHJldmVudHNcbiAgICAgICAgLy8gdGhlbSBmcm9tIGJlaW5nIGVycm9uZW91c2x5IHJlamVjdGVkIG9uIGVycm9yLiBJZiBhIHdyaXRlKCkgY2FsbCBpcyBpbi1mbGlnaHQsIHRoZSByZXF1ZXN0IGlzIHN0b3JlZCBoZXJlLlxuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGUgcHJvbWlzZSB0aGF0IHdhcyByZXR1cm5lZCBmcm9tIHdyaXRlci5jbG9zZSgpLiBTdG9yZWQgaGVyZSBiZWNhdXNlIGl0IG1heSBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhlIHdyaXRlclxuICAgICAgICAvLyBoYXMgYmVlbiBkZXRhY2hlZC5cbiAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIENsb3NlIHJlcXVlc3QgaXMgcmVtb3ZlZCBmcm9tIF9jbG9zZVJlcXVlc3Qgd2hlbiBjbG9zZSgpIGlzIGNhbGxlZCBvbiB0aGUgdW5kZXJseWluZyBzaW5rLiBUaGlzIHByZXZlbnRzIGl0XG4gICAgICAgIC8vIGZyb20gYmVpbmcgZXJyb25lb3VzbHkgcmVqZWN0ZWQgb24gZXJyb3IuIElmIGEgY2xvc2UoKSBjYWxsIGlzIGluLWZsaWdodCwgdGhlIHJlcXVlc3QgaXMgc3RvcmVkIGhlcmUuXG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoZSBwcm9taXNlIHRoYXQgd2FzIHJldHVybmVkIGZyb20gd3JpdGVyLmFib3J0KCkuIFRoaXMgbWF5IGFsc28gYmUgZnVsZmlsbGVkIGFmdGVyIHRoZSB3cml0ZXIgaGFzIGRldGFjaGVkLlxuICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRoZSBiYWNrcHJlc3N1cmUgc2lnbmFsIHNldCBieSB0aGUgY29udHJvbGxlci5cbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbSh4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ193cml0YWJsZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV3JpdGFibGVTdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX3dyaXRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWJvcnQoc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLl9hYm9ydFJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgKF9hID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KHJlYXNvbik7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgbmFycm93cyB0aGUgdHlwZSBvZiBgc3RyZWFtLl9zdGF0ZWAgZG93biB0byAnd3JpdGFibGUnIHwgJ2Vycm9yaW5nJyxcbiAgICAgICAgLy8gYnV0IGl0IGRvZXNuJ3Qga25vdyB0aGF0IHNpZ25hbGluZyBhYm9ydCBydW5zIGF1dGhvciBjb2RlIHRoYXQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gV2lkZW4gdGhlIHR5cGUgYWdhaW4gYnkgY2FzdGluZyB0byBXcml0YWJsZVN0cmVhbVN0YXRlLlxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Byb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdhc0FscmVhZHlFcnJvcmluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgIHdhc0FscmVhZHlFcnJvcmluZyA9IHRydWU7XG4gICAgICAgICAgICAvLyByZWFzb24gd2lsbCBub3QgYmUgdXNlZCwgc28gZG9uJ3Qga2VlcCBhIHJlZmVyZW5jZSB0byBpdC5cbiAgICAgICAgICAgIHJlYXNvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Byb21pc2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBfcmVqZWN0OiByZWplY3QsXG4gICAgICAgICAgICAgICAgX3JlYXNvbjogcmVhc29uLFxuICAgICAgICAgICAgICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgIGlmICghd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHwgc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcihgVGhlIHN0cmVhbSAoaW4gJHtzdGF0ZX0gc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRgKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgIF9yZWplY3Q6IHJlamVjdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gY2xvc2VSZXF1ZXN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gICAgICAgIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICAgICAgfVxuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2Uoc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLy8gV3JpdGFibGVTdHJlYW0gQVBJIGV4cG9zZWQgZm9yIGNvbnRyb2xsZXJzLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZVJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX3Jlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgX3JlamVjdDogcmVqZWN0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLnB1c2god3JpdGVSZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbikge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JpbmcnO1xuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkgJiYgY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnZXJyb3JlZCc7XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Vycm9yU3RlcHNdKCk7XG4gICAgICAgIGNvbnN0IHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICAgICAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2god3JpdGVSZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgIHdyaXRlUmVxdWVzdC5fcmVqZWN0KHN0b3JlZEVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5fd3JpdGVSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYm9ydFJlcXVlc3QgPSBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3Q7XG4gICAgICAgIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3J0UmVxdWVzdC5fd2FzQWxyZWFkeUVycm9yaW5nKSB7XG4gICAgICAgICAgICBhYm9ydFJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyW0Fib3J0U3RlcHNdKGFib3J0UmVxdWVzdC5fcmVhc29uKTtcbiAgICAgICAgdXBvblByb21pc2UocHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZXNvbHZlKCk7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgYWJvcnRSZXF1ZXN0Ll9yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgLy8gVGhlIGVycm9yIHdhcyB0b28gbGF0ZSB0byBkbyBhbnl0aGluZywgc28gaXQgaXMgaWdub3JlZC5cbiAgICAgICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl9zdGF0ZSA9ICdjbG9zZWQnO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3Ioc3RyZWFtLCBlcnJvcikge1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICAgICAgICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBOZXZlciBleGVjdXRlIHNpbmsgYWJvcnQoKSBhZnRlciBzaW5rIGNsb3NlKCkuXG4gICAgICAgIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG4gICAgfVxuICAgIC8vIFRPRE8ocmljZWEpOiBGaXggYWxwaGFiZXRpY2FsIG9yZGVyLlxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrQ2xvc2VSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPSBzdHJlYW0uX2Nsb3NlUmVxdWVzdDtcbiAgICAgICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSBzdHJlYW0uX3dyaXRlUmVxdWVzdHMuc2hpZnQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pIHtcbiAgICAgICAgaWYgKHN0cmVhbS5fY2xvc2VSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0Ll9yZWplY3Qoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgICAgICAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICAgICAgICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgaWYgKGJhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBkZWZhdWx0IHdyaXRlciB2ZW5kZWQgYnkgYSB7QGxpbmsgV3JpdGFibGVTdHJlYW19LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChzdHJlYW0sIDEsICdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXInKTtcbiAgICAgICAgICAgIGFzc2VydFdyaXRhYmxlU3RyZWFtKHN0cmVhbSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgc3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gbG9ja2VkIGZvciBleGNsdXNpdmUgd3JpdGluZyBieSBhbm90aGVyIHdyaXRlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHN0cmVhbS5fd3JpdGVyID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIGlmICghV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdG9yZWRFcnJvciA9IHN0cmVhbS5fc3RvcmVkRXJyb3I7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHRoaXMsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBzdHJlYW0gYmVjb21lcyBjbG9zZWQsIG9yIHJlamVjdGVkIGlmIHRoZSBzdHJlYW0gZXZlciBlcnJvcnMgb3JcbiAgICAgICAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZCBiZWZvcmUgdGhlIHN0cmVhbSBmaW5pc2hlcyBjbG9zaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb3NlZFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBzdHJlYW3igJlzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpcyBvdmVyLWZ1bGwuXG4gICAgICAgICAqIEEgcHJvZHVjZXIgY2FuIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB0aGUgcmlnaHQgYW1vdW50IG9mIGRhdGEgdG8gd3JpdGUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZSBzdHJlYW0gY2Fubm90IGJlIHN1Y2Nlc3NmdWxseSB3cml0dGVuIHRvIChkdWUgdG8gZWl0aGVyIGJlaW5nIGVycm9yZWQsIG9yIGhhdmluZyBhbiBhYm9ydFxuICAgICAgICAgKiBxdWV1ZWQgdXApLiBJdCB3aWxsIHJldHVybiB6ZXJvIGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkLiBBbmQgdGhlIGdldHRlciB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBpbnZva2VkIHdoZW5cbiAgICAgICAgICogdGhlIHdyaXRlcuKAmXMgbG9jayBpcyByZWxlYXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBkZXNpcmVkU2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCB3aGVuIHRoZSBkZXNpcmVkIHNpemUgdG8gZmlsbCB0aGUgc3RyZWFt4oCZcyBpbnRlcm5hbCBxdWV1ZSB0cmFuc2l0aW9uc1xuICAgICAgICAgKiBmcm9tIG5vbi1wb3NpdGl2ZSB0byBwb3NpdGl2ZSwgc2lnbmFsaW5nIHRoYXQgaXQgaXMgbm8gbG9uZ2VyIGFwcGx5aW5nIGJhY2twcmVzc3VyZS4gT25jZSB0aGUgZGVzaXJlZCBzaXplIGRpcHNcbiAgICAgICAgICogYmFjayB0byB6ZXJvIG9yIGJlbG93LCB0aGUgZ2V0dGVyIHdpbGwgcmV0dXJuIGEgbmV3IHByb21pc2UgdGhhdCBzdGF5cyBwZW5kaW5nIHVudGlsIHRoZSBuZXh0IHRyYW5zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBzdHJlYW0gYmVjb21lcyBlcnJvcmVkIG9yIGFib3J0ZWQsIG9yIHRoZSB3cml0ZXLigJlzIGxvY2sgaXMgcmVsZWFzZWQsIHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmVjb21lXG4gICAgICAgICAqIHJlamVjdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSByZWFkZXIgaXMgYWN0aXZlLCBiZWhhdmVzIHRoZSBzYW1lIGFzIHtAbGluayBXcml0YWJsZVN0cmVhbS5hYm9ydCB8IHN0cmVhbS5hYm9ydChyZWFzb24pfS5cbiAgICAgICAgICovXG4gICAgICAgIGFib3J0KHJlYXNvbiA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQodGhpcywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHJlYWRlciBpcyBhY3RpdmUsIGJlaGF2ZXMgdGhlIHNhbWUgYXMge0BsaW5rIFdyaXRhYmxlU3RyZWFtLmNsb3NlIHwgc3RyZWFtLmNsb3NlKCl9LlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgICAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbGVhc2VzIHRoZSB3cml0ZXLigJlzIGxvY2sgb24gdGhlIGNvcnJlc3BvbmRpbmcgc3RyZWFtLiBBZnRlciB0aGUgbG9jayBpcyByZWxlYXNlZCwgdGhlIHdyaXRlciBpcyBubyBsb25nZXIgYWN0aXZlLlxuICAgICAgICAgKiBJZiB0aGUgYXNzb2NpYXRlZCBzdHJlYW0gaXMgZXJyb3JlZCB3aGVuIHRoZSBsb2NrIGlzIHJlbGVhc2VkLCB0aGUgd3JpdGVyIHdpbGwgYXBwZWFyIGVycm9yZWQgaW4gdGhlIHNhbWUgd2F5IGZyb21cbiAgICAgICAgICogbm93IG9uOyBvdGhlcndpc2UsIHRoZSB3cml0ZXIgd2lsbCBhcHBlYXIgY2xvc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGxvY2sgY2FuIHN0aWxsIGJlIHJlbGVhc2VkIGV2ZW4gaWYgc29tZSBvbmdvaW5nIHdyaXRlcyBoYXZlIG5vdCB5ZXQgZmluaXNoZWQgKGkuZS4gZXZlbiBpZiB0aGVcbiAgICAgICAgICogcHJvbWlzZXMgcmV0dXJuZWQgZnJvbSBwcmV2aW91cyBjYWxscyB0byB7QGxpbmsgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLndyaXRlIHwgd3JpdGUoKX0gaGF2ZSBub3QgeWV0IHNldHRsZWQpLlxuICAgICAgICAgKiBJdOKAmXMgbm90IG5lY2Vzc2FyeSB0byBob2xkIHRoZSBsb2NrIG9uIHRoZSB3cml0ZXIgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgd3JpdGU7IHRoZSBsb2NrIGluc3RlYWQgc2ltcGx5IHByZXZlbnRzXG4gICAgICAgICAqIG90aGVyIHByb2R1Y2VycyBmcm9tIHdyaXRpbmcgaW4gYW4gaW50ZXJsZWF2ZWQgbWFubmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVsZWFzZUxvY2soKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKHN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd3cml0ZScpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUodGhpcywgY2h1bmspO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUsIHtcbiAgICAgICAgYWJvcnQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlbGVhc2VMb2NrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgd3JpdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBjbG9zZWQ6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHJlYWR5OiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIHNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmFib3J0LCAnYWJvcnQnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5jbG9zZSwgJ2Nsb3NlJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUucmVsZWFzZUxvY2ssICdyZWxlYXNlTG9jaycpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLndyaXRlLCAnd3JpdGUnKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyJyxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWJzdHJhY3Qgb3BlcmF0aW9ucyBmb3IgdGhlIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5cbiAgICBmdW5jdGlvbiBJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19vd25lcldyaXRhYmxlU3RyZWFtJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyIG1heSB1c2UgdGhlc2UgZnVuY3Rpb25zIGRpcmVjdGx5IHRvIGJ5cGFzcyBzdGF0ZSBjaGVjay5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJBYm9ydCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIGVycm9yKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcbiAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUod3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJyB8fCBzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgY29uc3QgcmVsZWFzZWRFcnJvciA9IG5ldyBUeXBlRXJyb3IoYFdyaXRlciB3YXMgcmVsZWFzZWQgYW5kIGNhbiBubyBsb25nZXIgYmUgdXNlZCB0byBtb25pdG9yIHRoZSBzdHJlYW0ncyBjbG9zZWRuZXNzYCk7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG4gICAgICAgIC8vIFRoZSBzdGF0ZSB0cmFuc2l0aW9ucyB0byBcImVycm9yZWRcIiBiZWZvcmUgdGhlIHNpbmsgYWJvcnQoKSBtZXRob2QgcnVucywgYnV0IHRoZSB3cml0ZXIuY2xvc2VkIHByb21pc2UgaXMgbm90XG4gICAgICAgIC8vIHJlamVjdGVkIHVudGlsIGFmdGVyd2FyZHMuIFRoaXMgbWVhbnMgdGhhdCBzaW1wbHkgdGVzdGluZyBzdGF0ZSB3aWxsIG5vdCB3b3JrLlxuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQod3JpdGVyLCByZWxlYXNlZEVycm9yKTtcbiAgICAgICAgc3RyZWFtLl93cml0ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyV3JpdGUod3JpdGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgY29uc3QgY2h1bmtTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldENodW5rU2l6ZShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgIGlmIChzdHJlYW0gIT09IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBjbG9zaW5nIG9yIGNsb3NlZCBhbmQgY2Fubm90IGJlIHdyaXR0ZW4gdG8nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNlID0gV3JpdGFibGVTdHJlYW1BZGRXcml0ZVJlcXVlc3Qoc3RyZWFtKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgY2xvc2VTZW50aW5lbCA9IHt9O1xuICAgIC8qKlxuICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSByZWFzb24gd2hpY2ggd2FzIHBhc3NlZCB0byBgV3JpdGFibGVTdHJlYW0uYWJvcnQocmVhc29uKWAgd2hlbiB0aGUgc3RyZWFtIHdhcyBhYm9ydGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAgICAgKiAgVGhpcyBwcm9wZXJ0eSBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNwZWNpZmljYXRpb24sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvcHVsbC8xMTc3LlxuICAgICAgICAgKiAgVXNlIHtAbGluayBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnNpZ25hbH0ncyBgcmVhc29uYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGFib3J0UmVhc29uKCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignYWJvcnRSZWFzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hYm9ydFJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYEFib3J0U2lnbmFsYCB0aGF0IGNhbiBiZSB1c2VkIHRvIGFib3J0IHRoZSBwZW5kaW5nIHdyaXRlIG9yIGNsb3NlIG9wZXJhdGlvbiB3aGVuIHRoZSBzdHJlYW0gaXMgYWJvcnRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgICAgICBpZiAoIUlzV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdzaWduYWwnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9hYm9ydENvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIE9sZGVyIGJyb3dzZXJzIG9yIG9sZGVyIE5vZGUgdmVyc2lvbnMgbWF5IG5vdCBzdXBwb3J0IGBBYm9ydENvbnRyb2xsZXJgIG9yIGBBYm9ydFNpZ25hbGAuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBidW5kbGUgYW5kIHNoaXAgYW4gYEFib3J0Q29udHJvbGxlcmAgcG9seWZpbGwgdG9nZXRoZXIgd2l0aCBvdXIgcG9seWZpbGwsXG4gICAgICAgICAgICAgICAgLy8gc28gaW5zdGVhZCB3ZSBvbmx5IGltcGxlbWVudCBzdXBwb3J0IGZvciBgc2lnbmFsYCBpZiB3ZSBmaW5kIGEgZ2xvYmFsIGBBYm9ydENvbnRyb2xsZXJgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnNpZ25hbCBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIHdyaXRhYmxlIHN0cmVhbSwgbWFraW5nIGFsbCBmdXR1cmUgaW50ZXJhY3Rpb25zIHdpdGggaXQgZmFpbCB3aXRoIHRoZSBnaXZlbiBlcnJvciBgZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGlzIHJhcmVseSB1c2VkLCBzaW5jZSB1c3VhbGx5IGl0IHN1ZmZpY2VzIHRvIHJldHVybiBhIHJlamVjdGVkIHByb21pc2UgZnJvbSBvbmUgb2YgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICogc2luaydzIG1ldGhvZHMuIEhvd2V2ZXIsIGl0IGNhbiBiZSB1c2VmdWwgZm9yIHN1ZGRlbmx5IHNodXR0aW5nIGRvd24gYSBzdHJlYW0gaW4gcmVzcG9uc2UgdG8gYW4gZXZlbnQgb3V0c2lkZSB0aGVcbiAgICAgICAgICogbm9ybWFsIGxpZmVjeWNsZSBvZiBpbnRlcmFjdGlvbnMgd2l0aCB0aGUgdW5kZXJseWluZyBzaW5rLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IoZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMignZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzdHJlYW0gaXMgY2xvc2VkLCBlcnJvcmVkIG9yIHdpbGwgYmUgc29vbi4gVGhlIHNpbmsgY2FuJ3QgZG8gYW55dGhpbmcgdXNlZnVsIGlmIGl0IGdldHMgYW4gZXJyb3IgaGVyZSwgc29cbiAgICAgICAgICAgICAgICAvLyBqdXN0IHRyZWF0IGl0IGFzIGEgbm8tb3AuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIGUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW0Fib3J0U3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fYWJvcnRBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW0Vycm9yU3RlcHNdKCkge1xuICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBhYm9ydFJlYXNvbjogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHNpZ25hbDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgaW1wbGVtZW50aW5nIGludGVyZmFjZSByZXF1aXJlZCBieSB0aGUgV3JpdGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbScpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgLy8gTmVlZCB0byBzZXQgdGhlIHNsb3RzIHNvIHRoYXQgdGhlIGFzc2VydCBkb2Vzbid0IGZpcmUuIEluIHRoZSBzcGVjIHRoZSBzbG90cyBhbHJlYWR5IGV4aXN0IGltcGxpY2l0bHkuXG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRSZWFzb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Fib3J0Q29udHJvbGxlciA9IGNyZWF0ZUFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHNpemVBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gaGlnaFdhdGVyTWFyaztcbiAgICAgICAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB3cml0ZUFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0gPSBjbG9zZUFsZ29yaXRobTtcbiAgICAgICAgY29udHJvbGxlci5fYWJvcnRBbGdvcml0aG0gPSBhYm9ydEFsZ29yaXRobTtcbiAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICAgICAgICBjb25zdCBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0UHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpO1xuICAgICAgICB1cG9uUHJvbWlzZShzdGFydFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sIHIgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlYWxXaXRoUmVqZWN0aW9uKHN0cmVhbSwgcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayhzdHJlYW0sIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtO1xuICAgICAgICBsZXQgd3JpdGVBbGdvcml0aG07XG4gICAgICAgIGxldCBjbG9zZUFsZ29yaXRobTtcbiAgICAgICAgbGV0IGFib3J0QWxnb3JpdGhtO1xuICAgICAgICBpZiAodW5kZXJseWluZ1Npbmsuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU2luay5zdGFydChjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0QWxnb3JpdGhtID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay53cml0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3cml0ZUFsZ29yaXRobSA9IGNodW5rID0+IHVuZGVybHlpbmdTaW5rLndyaXRlKGNodW5rLCBjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXRlQWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlcmx5aW5nU2luay5jbG9zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHVuZGVybHlpbmdTaW5rLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9zZUFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1NpbmsuYWJvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSByZWFzb24gPT4gdW5kZXJseWluZ1NpbmsuYWJvcnQocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFib3J0QWxnb3JpdGhtID0gKCkgPT4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICB9XG4gICAgLy8gQ2xlYXJBbGdvcml0aG1zIG1heSBiZSBjYWxsZWQgdHdpY2UuIEVycm9yaW5nIHRoZSBzYW1lIHN0cmVhbSBpbiBtdWx0aXBsZSB3YXlzIHdpbGwgb2Z0ZW4gcmVzdWx0IGluIHJlZHVuZGFudCBjYWxscy5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjbG9zZVNlbnRpbmVsLCAwKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pICYmIHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbVVwZGF0ZUJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSk7XG4gICAgICAgIH1cbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgICAvLyBBYnN0cmFjdCBvcGVyYXRpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIGlmICghY29udHJvbGxlci5fc3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IFBlZWtRdWV1ZVZhbHVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAodmFsdWUgPT09IGNsb3NlU2VudGluZWwpIHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3JJZk5lZWRlZChjb250cm9sbGVyLCBlcnJvcikge1xuICAgICAgICBpZiAoY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtLl9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICAgICAgICBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICAgICAgICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gICAgICAgIGNvbnN0IHNpbmtDbG9zZVByb21pc2UgPSBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSgpO1xuICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICB1cG9uUHJvbWlzZShzaW5rQ2xvc2VQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZShjb250cm9sbGVyLCBjaHVuaykge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcbiAgICAgICAgY29uc3Qgc2lua1dyaXRlUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3dyaXRlQWxnb3JpdGhtKGNodW5rKTtcbiAgICAgICAgdXBvblByb21pc2Uoc2lua1dyaXRlUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gICAgICAgICAgICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KHN0cmVhbSkgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByZWFzb24gPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgICAgICAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IGRlc2lyZWRTaXplID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICAgICAgICByZXR1cm4gZGVzaXJlZFNpemUgPD0gMDtcbiAgICB9XG4gICAgLy8gQSBjbGllbnQgb2YgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBtYXkgdXNlIHRoZXNlIGZ1bmN0aW9ucyBkaXJlY3RseSB0byBieXBhc3Mgc3RhdGUgY2hlY2suXG4gICAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgICAgICAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW0uXG4gICAgZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbWApO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5cbiAgICBmdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMihuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyYCk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQ2Fubm90ICcgKyBuYW1lICsgJyBhIHN0cmVhbSB1c2luZyBhIHJlbGVhc2VkIHdyaXRlcicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKSB7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1Jlc29sdmVkKHdyaXRlcikge1xuICAgICAgICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVqZWN0KHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fY2xvc2VkUHJvbWlzZSk7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QocmVhc29uKTtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fY2xvc2VkUHJvbWlzZVN0YXRlID0gJ3JlamVjdGVkJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCh3cml0ZXIsIHJlYXNvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcbiAgICAgICAgaWYgKHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncmVzb2x2ZWQnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdwZW5kaW5nJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX3JlYWR5UHJvbWlzZSk7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAncmVqZWN0ZWQnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKSB7XG4gICAgICAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgICAgICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKSB7XG4gICAgICAgIGlmICh3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdmdWxmaWxsZWQnO1xuICAgIH1cblxuICAgIC8vLyA8cmVmZXJlbmNlIGxpYj1cImRvbVwiIC8+XG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFscygpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBnbG9iYWxzID0gZ2V0R2xvYmFscygpO1xuXG4gICAgLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIgLz5cbiAgICBmdW5jdGlvbiBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKGN0b3IpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIGN0b3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGN0b3IgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdG9yLm5hbWUgIT09ICdET01FeGNlcHRpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5ldyBjdG9yKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0OlxuICAgICAqIC0gV2ViIGJyb3dzZXJzXG4gICAgICogLSBOb2RlIDE4IGFuZCBoaWdoZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9jb21taXQvZTRiMWZiNWU2NDIyYzFmZjE1MTIzNGJiOWRlNzkyZDQ1ZGQ4OGQ4NylcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRGcm9tR2xvYmFsKCkge1xuICAgICAgICBjb25zdCBjdG9yID0gZ2xvYmFscyA9PT0gbnVsbCB8fCBnbG9iYWxzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxzLkRPTUV4Y2VwdGlvbjtcbiAgICAgICAgcmV0dXJuIGlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IoY3RvcikgPyBjdG9yIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdXBwb3J0OlxuICAgICAqIC0gQWxsIHBsYXRmb3Jtc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVBvbHlmaWxsKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXNoYWRvd1xuICAgICAgICBjb25zdCBjdG9yID0gZnVuY3Rpb24gRE9NRXhjZXB0aW9uKG1lc3NhZ2UsIG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lIHx8ICdFcnJvcic7XG4gICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2V0RnVuY3Rpb25OYW1lKGN0b3IsICdET01FeGNlcHRpb24nKTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgeyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIGN0b3I7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkZWNsYXJlXG4gICAgY29uc3QgRE9NRXhjZXB0aW9uID0gZ2V0RnJvbUdsb2JhbCgpIHx8IGNyZWF0ZVBvbHlmaWxsKCk7XG5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVBpcGVUbyhzb3VyY2UsIGRlc3QsIHByZXZlbnRDbG9zZSwgcHJldmVudEFib3J0LCBwcmV2ZW50Q2FuY2VsLCBzaWduYWwpIHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzb3VyY2UpO1xuICAgICAgICBjb25zdCB3cml0ZXIgPSBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKGRlc3QpO1xuICAgICAgICBzb3VyY2UuX2Rpc3R1cmJlZCA9IHRydWU7XG4gICAgICAgIGxldCBzaHV0dGluZ0Rvd24gPSBmYWxzZTtcbiAgICAgICAgLy8gVGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHNwZWMncyByZXF1aXJlbWVudCB0aGF0IHdlIHdhaXQgZm9yIG9uZ29pbmcgd3JpdGVzIGR1cmluZyBzaHV0ZG93bi5cbiAgICAgICAgbGV0IGN1cnJlbnRXcml0ZSA9IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgbGV0IGFib3J0QWxnb3JpdGhtO1xuICAgICAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gc2lnbmFsLnJlYXNvbiAhPT0gdW5kZWZpbmVkID8gc2lnbmFsLnJlYXNvbiA6IG5ldyBET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZXN0Ll9zdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1BYm9ydChkZXN0LCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXByZXZlbnRDYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHNvdXJjZSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFByb21pc2UuYWxsKGFjdGlvbnMubWFwKGFjdGlvbiA9PiBhY3Rpb24oKSkpLCB0cnVlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWJvcnRBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEFsZ29yaXRobSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2luZyByZWFkZXIgYW5kIHdyaXRlciwgcmVhZCBhbGwgY2h1bmtzIGZyb20gdGhpcyBhbmQgd3JpdGUgdGhlbSB0byBkZXN0XG4gICAgICAgICAgICAvLyAtIEJhY2twcmVzc3VyZSBtdXN0IGJlIGVuZm9yY2VkXG4gICAgICAgICAgICAvLyAtIFNodXRkb3duIG11c3Qgc3RvcCBhbGwgYWN0aXZpdHlcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVMb29wKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQcm9taXNlKChyZXNvbHZlTG9vcCwgcmVqZWN0TG9vcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBuZXh0KGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUxvb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBgUGVyZm9ybVByb21pc2VUaGVuYCBpbnN0ZWFkIG9mIGB1cG9uUHJvbWlzZWAgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGRpbmcgdW5uZWNlc3NhcnkgYC5jYXRjaChyZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pYCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBlcmZvcm1Qcm9taXNlVGhlbihwaXBlU3RlcCgpLCBuZXh0LCByZWplY3RMb29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBpcGVTdGVwKCkge1xuICAgICAgICAgICAgICAgIGlmIChzaHV0dGluZ0Rvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4od3JpdGVyLl9yZWFkeVByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2UoKHJlc29sdmVSZWFkLCByZWplY3RSZWFkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSwgdW5kZWZpbmVkLCBub29wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVJlYWQoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHJlc29sdmVSZWFkKHRydWUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiByZWplY3RSZWFkXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBFcnJvcnMgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICAgICAgICAgIGlzT3JCZWNvbWVzRXJyb3JlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJldmVudEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBXcml0YWJsZVN0cmVhbUFib3J0KGRlc3QsIHN0b3JlZEVycm9yKSwgdHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gRXJyb3JzIG11c3QgYmUgcHJvcGFnYXRlZCBiYWNrd2FyZFxuICAgICAgICAgICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgc3RvcmVkRXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcHJldmVudENhbmNlbCkge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bldpdGhBY3Rpb24oKCkgPT4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvciksIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENsb3NpbmcgbXVzdCBiZSBwcm9wYWdhdGVkIGZvcndhcmRcbiAgICAgICAgICAgIGlzT3JCZWNvbWVzQ2xvc2VkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2h1dGRvd25XaXRoQWN0aW9uKCgpID0+IFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzaHV0ZG93bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2xvc2luZyBtdXN0IGJlIHByb3BhZ2F0ZWQgYmFja3dhcmRcbiAgICAgICAgICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSB8fCBkZXN0Ll9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZXN0Q2xvc2VkID0gbmV3IFR5cGVFcnJvcigndGhlIGRlc3RpbmF0aW9uIHdyaXRhYmxlIHN0cmVhbSBjbG9zZWQgYmVmb3JlIGFsbCBkYXRhIGNvdWxkIGJlIHBpcGVkIHRvIGl0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwcmV2ZW50Q2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duV2l0aEFjdGlvbigoKSA9PiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGRlc3RDbG9zZWQpLCB0cnVlLCBkZXN0Q2xvc2VkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNodXRkb3duKHRydWUsIGRlc3RDbG9zZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocGlwZUxvb3AoKSk7XG4gICAgICAgICAgICBmdW5jdGlvbiB3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSB7XG4gICAgICAgICAgICAgICAgLy8gQW5vdGhlciB3cml0ZSBtYXkgaGF2ZSBzdGFydGVkIHdoaWxlIHdlIHdlcmUgd2FpdGluZyBvbiB0aGlzIGN1cnJlbnRXcml0ZSwgc28gd2UgaGF2ZSB0byBiZSBzdXJlIHRvIHdhaXRcbiAgICAgICAgICAgICAgICAvLyBmb3IgdGhhdCB0b28uXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkQ3VycmVudFdyaXRlID0gY3VycmVudFdyaXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oY3VycmVudFdyaXRlLCAoKSA9PiBvbGRDdXJyZW50V3JpdGUgIT09IGN1cnJlbnRXcml0ZSA/IHdhaXRGb3JXcml0ZXNUb0ZpbmlzaCgpIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzRXJyb3JlZChzdHJlYW0sIHByb21pc2UsIGFjdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBvblJlamVjdGlvbihwcm9taXNlLCBhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGlzT3JCZWNvbWVzQ2xvc2VkKHN0cmVhbSwgcHJvbWlzZSwgYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbiwgb3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNodXR0aW5nRG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmICFXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChkZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkb1RoZVJlc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gZG9UaGVSZXN0KCkge1xuICAgICAgICAgICAgICAgICAgICB1cG9uUHJvbWlzZShhY3Rpb24oKSwgKCkgPT4gZmluYWxpemUob3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSwgbmV3RXJyb3IgPT4gZmluYWxpemUodHJ1ZSwgbmV3RXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gc2h1dGRvd24oaXNFcnJvciwgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2h1dHRpbmdEb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2h1dHRpbmdEb3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScgJiYgIVdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwb25GdWxmaWxsbWVudCh3YWl0Rm9yV3JpdGVzVG9GaW5pc2goKSwgKCkgPT4gZmluYWxpemUoaXNFcnJvciwgZXJyb3IpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikge1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFsbG93cyBjb250cm9sIG9mIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSdzIHN0YXRlIGFuZCBpbnRlcm5hbCBxdWV1ZS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSBjb250cm9sbGVkIHN0cmVhbSdzIGludGVybmFsIHF1ZXVlLiBJdCBjYW4gYmUgbmVnYXRpdmUsIGlmIHRoZSBxdWV1ZSBpc1xuICAgICAgICAgKiBvdmVyLWZ1bGwuIEFuIHVuZGVybHlpbmcgc291cmNlIG91Z2h0IHRvIHVzZSB0aGlzIGluZm9ybWF0aW9uIHRvIGRldGVybWluZSB3aGVuIGFuZCBob3cgdG8gYXBwbHkgYmFja3ByZXNzdXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZGVzaXJlZFNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgY29udHJvbGxlZCByZWFkYWJsZSBzdHJlYW0uIENvbnN1bWVycyB3aWxsIHN0aWxsIGJlIGFibGUgdG8gcmVhZCBhbnkgcHJldmlvdXNseS1lbnF1ZXVlZCBjaHVua3MgZnJvbVxuICAgICAgICAgKiB0aGUgc3RyZWFtLCBidXQgb25jZSB0aG9zZSBhcmUgcmVhZCwgdGhlIHN0cmVhbSB3aWxsIGJlY29tZSBjbG9zZWQuXG4gICAgICAgICAqL1xuICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBzdHJlYW0gaXMgbm90IGluIGEgc3RhdGUgdGhhdCBwZXJtaXRzIGNsb3NlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5xdWV1ZShjaHVuayA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZW5xdWV1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFcnJvcnMgdGhlIGNvbnRyb2xsZWQgcmVhZGFibGUgc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZSBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC5cbiAgICAgICAgICovXG4gICAgICAgIGVycm9yKGUgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbQ2FuY2VsU3RlcHNdKHJlYXNvbikge1xuICAgICAgICAgICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2NhbmNlbEFsZ29yaXRobShyZWFzb24pO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgICAgICBbUHVsbFN0ZXBzXShyZWFkUmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IERlcXVldWVWYWx1ZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VSZXF1ZXN0ZWQgJiYgdGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWFkUmVxdWVzdC5fY2h1bmtTdGVwcyhjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSwgcmVhZFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICAgICAgW1JlbGVhc2VTdGVwc10oKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCB7XG4gICAgICAgIGNsb3NlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZW5xdWV1ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGVycm9yOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZGVzaXJlZFNpemU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmNsb3NlLCAnY2xvc2UnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZW5xdWV1ZSwgJ2VucXVldWUnKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IsICdlcnJvcicpO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcih4KSB7XG4gICAgICAgIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19jb250cm9sbGVkUmVhZGFibGVTdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzaG91bGRQdWxsID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICBpZiAoIXNob3VsZFB1bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbGluZykge1xuICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcHVsbFByb21pc2UgPSBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtKCk7XG4gICAgICAgIHVwb25Qcm9taXNlKHB1bGxQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5fcHVsbEFnYWluKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbnRyb2xsZXIuX3N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXNpcmVkU2l6ZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKTtcbiAgICAgICAgaWYgKGRlc2lyZWRTaXplID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEEgY2xpZW50IG9mIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgbWF5IHVzZSB0aGVzZSBmdW5jdGlvbnMgZGlyZWN0bHkgdG8gYnlwYXNzIHN0YXRlIGNoZWNrLlxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShjb250cm9sbGVyKSB7XG4gICAgICAgIGlmICghUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKGNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgaWYgKCFSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjaHVua1NpemU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBjaHVua1NpemVFKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBjaHVua1NpemVFO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlbnF1ZXVlRSkge1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlbnF1ZXVlRSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZW5xdWV1ZUU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZShjb250cm9sbGVyKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtLl9zdGF0ZTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuICAgIH1cbiAgICAvLyBUaGlzIGlzIHVzZWQgaW4gdGhlIGltcGxlbWVudGF0aW9uIG9mIFRyYW5zZm9ybVN0cmVhbS5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbS5fc3RhdGU7XG4gICAgICAgIGlmICghY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgJiYgc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGNvbnRyb2xsZXIuX3F1ZXVlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgUmVzZXRRdWV1ZShjb250cm9sbGVyKTtcbiAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICAgICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneVNpemVBbGdvcml0aG0gPSBzaXplQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9zdHJhdGVneUhXTSA9IGhpZ2hXYXRlck1hcms7XG4gICAgICAgIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSBwdWxsQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgY29uc3Qgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICAgICAgICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgKCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgbGV0IHN0YXJ0QWxnb3JpdGhtO1xuICAgICAgICBsZXQgcHVsbEFsZ29yaXRobTtcbiAgICAgICAgbGV0IGNhbmNlbEFsZ29yaXRobTtcbiAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2Uuc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlcmx5aW5nU291cmNlLnN0YXJ0KGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRBbGdvcml0aG0gPSAoKSA9PiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UucHVsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwdWxsQWxnb3JpdGhtID0gKCkgPT4gdW5kZXJseWluZ1NvdXJjZS5wdWxsKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHVsbEFsZ29yaXRobSA9ICgpID0+IHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZXJseWluZ1NvdXJjZS5jYW5jZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2FuY2VsQWxnb3JpdGhtID0gcmVhc29uID0+IHVuZGVybHlpbmdTb3VyY2UuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVRlZShzdHJlYW0sIGNsb25lRm9yQnJhbmNoMikge1xuICAgICAgICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbVRlZShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUoc3RyZWFtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0VGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgbGV0IHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlYWRBZ2FpbiA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlYXNvbjE7XG4gICAgICAgIGxldCByZWFzb24yO1xuICAgICAgICBsZXQgYnJhbmNoMTtcbiAgICAgICAgbGV0IGJyYW5jaDI7XG4gICAgICAgIGxldCByZXNvbHZlQ2FuY2VsUHJvbWlzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZWFkQWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRSZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIF9jaHVua1N0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgZGVsYXllZCBhIG1pY3JvdGFzayBiZWNhdXNlIGl0IHRha2VzIGF0IGxlYXN0IGEgbWljcm90YXNrIHRvIGRldGVjdCBlcnJvcnMgKHVzaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWRlci5fY2xvc2VkUHJvbWlzZSBiZWxvdyksIGFuZCB3ZSB3YW50IGVycm9ycyBpbiBzdHJlYW0gdG8gZXJyb3IgYm90aCBicmFuY2hlcyBpbW1lZGlhdGVseS4gV2UgY2Fubm90IGxldFxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsIHN5bmNocm9ub3VzbHktYXZhaWxhYmxlIHJlYWRzIGdldCBhaGVhZCBvZiBhc3luY2hyb25vdXNseS1hdmFpbGFibGUgZXJyb3JzLlxuICAgICAgICAgICAgICAgICAgICBfcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rMiA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gd2F5IHRvIGFjY2VzcyB0aGUgY2xvbmluZyBjb2RlIHJpZ2h0IG5vdyBpbiB0aGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgYWRkIG9uZSB0aGVuIHdlJ2xsIG5lZWQgYW4gaW1wbGVtZW50YXRpb24gZm9yIHNlcmlhbGl6YWJsZSBvYmplY3RzLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKCFjYW5jZWxlZDIgJiYgY2xvbmVGb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNodW5rMiA9IFN0cnVjdHVyZWREZXNlcmlhbGl6ZShTdHJ1Y3R1cmVkU2VyaWFsaXplKGNodW5rMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmsyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgX2Nsb3NlU3RlcHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxIHx8ICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9lcnJvclN0ZXBzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIsIHJlYWRSZXF1ZXN0KTtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsMUFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIGNhbmNlbGVkMSA9IHRydWU7XG4gICAgICAgICAgICByZWFzb24xID0gcmVhc29uO1xuICAgICAgICAgICAgaWYgKGNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0ZVJlYXNvbiA9IENyZWF0ZUFycmF5RnJvbUxpc3QoW3JlYXNvbjEsIHJlYXNvbjJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDJBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjYW5jZWxlZDIgPSB0cnVlO1xuICAgICAgICAgICAgcmVhc29uMiA9IHJlYXNvbjtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgfVxuICAgICAgICBicmFuY2gxID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbDJBbGdvcml0aG0pO1xuICAgICAgICB1cG9uUmVqZWN0aW9uKHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgKHIpID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFticmFuY2gxLCBicmFuY2gyXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtVGVlKHN0cmVhbSkge1xuICAgICAgICBsZXQgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICBsZXQgcmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMSA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVhZEFnYWluRm9yQnJhbmNoMiA9IGZhbHNlO1xuICAgICAgICBsZXQgY2FuY2VsZWQxID0gZmFsc2U7XG4gICAgICAgIGxldCBjYW5jZWxlZDIgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlYXNvbjE7XG4gICAgICAgIGxldCByZWFzb24yO1xuICAgICAgICBsZXQgYnJhbmNoMTtcbiAgICAgICAgbGV0IGJyYW5jaDI7XG4gICAgICAgIGxldCByZXNvbHZlQ2FuY2VsUHJvbWlzZTtcbiAgICAgICAgY29uc3QgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBmb3J3YXJkUmVhZGVyRXJyb3IodGhpc1JlYWRlcikge1xuICAgICAgICAgICAgdXBvblJlamVjdGlvbih0aGlzUmVhZGVyLl9jbG9zZWRQcm9taXNlLCByID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpc1JlYWRlciAhPT0gcmVhZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCkge1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgICAgICAgICAgICAgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICAgICAgICAgICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3QgPSB7XG4gICAgICAgICAgICAgICAgX2NodW5rU3RlcHM6IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSBkZWxheWVkIGEgbWljcm90YXNrIGJlY2F1c2UgaXQgdGFrZXMgYXQgbGVhc3QgYSBtaWNyb3Rhc2sgdG8gZGV0ZWN0IGVycm9ycyAodXNpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZGVyLl9jbG9zZWRQcm9taXNlIGJlbG93KSwgYW5kIHdlIHdhbnQgZXJyb3JzIGluIHN0cmVhbSB0byBlcnJvciBib3RoIGJyYW5jaGVzIGltbWVkaWF0ZWx5LiBXZSBjYW5ub3QgbGV0XG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgc3luY2hyb25vdXNseS1hdmFpbGFibGUgcmVhZHMgZ2V0IGFoZWFkIG9mIGFzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSBlcnJvcnMuXG4gICAgICAgICAgICAgICAgICAgIF9xdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuazEgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxICYmICFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuazIgPSBDbG9uZUFzVWludDhBcnJheShjaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChjbG9uZUUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjaHVuazEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVhZEFnYWluRm9yQnJhbmNoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1bGwxQWxnb3JpdGhtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDJBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfY2xvc2VTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChicmFuY2gyLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbmNlbGVkMSB8fCAhY2FuY2VsZWQyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyLCByZWFkUmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbFdpdGhCWU9CUmVhZGVyKHZpZXcsIGZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJlYWRlciA9IEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICBmb3J3YXJkUmVhZGVyRXJyb3IocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJ5b2JCcmFuY2ggPSBmb3JCcmFuY2gyID8gYnJhbmNoMiA6IGJyYW5jaDE7XG4gICAgICAgICAgICBjb25zdCBvdGhlckJyYW5jaCA9IGZvckJyYW5jaDIgPyBicmFuY2gxIDogYnJhbmNoMjtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBfY2h1bmtTdGVwczogY2h1bmsgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGRlbGF5ZWQgYSBtaWNyb3Rhc2sgYmVjYXVzZSBpdCB0YWtlcyBhdCBsZWFzdCBhIG1pY3JvdGFzayB0byBkZXRlY3QgZXJyb3JzICh1c2luZ1xuICAgICAgICAgICAgICAgICAgICAvLyByZWFkZXIuX2Nsb3NlZFByb21pc2UgYmVsb3cpLCBhbmQgd2Ugd2FudCBlcnJvcnMgaW4gc3RyZWFtIHRvIGVycm9yIGJvdGggYnJhbmNoZXMgaW1tZWRpYXRlbHkuIFdlIGNhbm5vdCBsZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBzeW5jaHJvbm91c2x5LWF2YWlsYWJsZSByZWFkcyBnZXQgYWhlYWQgb2YgYXN5bmNocm9ub3VzbHktYXZhaWxhYmxlIGVycm9ycy5cbiAgICAgICAgICAgICAgICAgICAgX3F1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5b2JDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDIgOiBjYW5jZWxlZDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlckNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMSA6IGNhbmNlbGVkMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3RoZXJDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjbG9uZWRDaHVuaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRDaHVuayA9IENsb25lQXNVaW50OEFycmF5KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGNsb25lRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZUUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3Iob3RoZXJCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2xvbmVFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjbG9uZUUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ5b2JDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCBjbG9uZWRDaHVuayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyhieW9iQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWFkQWdhaW5Gb3JCcmFuY2gxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVsbDFBbGdvcml0aG0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWRBZ2FpbkZvckJyYW5jaDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdWxsMkFsZ29yaXRobSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF9jbG9zZVN0ZXBzOiBjaHVuayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnlvYkNhbmNlbGVkID0gZm9yQnJhbmNoMiA/IGNhbmNlbGVkMiA6IGNhbmNlbGVkMTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3RoZXJDYW5jZWxlZCA9IGZvckJyYW5jaDIgPyBjYW5jZWxlZDEgOiBjYW5jZWxlZDI7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xvc2UoYnlvYkJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW90aGVyQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbG9zZShvdGhlckJyYW5jaC5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFieW9iQ2FuY2VsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGJ5b2JCcmFuY2guX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvdGhlckNhbmNlbGVkICYmIG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kKG90aGVyQnJhbmNoLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYnlvYkNhbmNlbGVkIHx8ICFvdGhlckNhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBfZXJyb3JTdGVwczogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3LCAxLCByZWFkSW50b1JlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHB1bGwxQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgaWYgKHJlYWRpbmcpIHtcbiAgICAgICAgICAgICAgICByZWFkQWdhaW5Gb3JCcmFuY2gxID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVhZGluZyA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBieW9iUmVxdWVzdCA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdChicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgaWYgKGJ5b2JSZXF1ZXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcHVsbFdpdGhEZWZhdWx0UmVhZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aEJZT0JSZWFkZXIoYnlvYlJlcXVlc3QuX3ZpZXcsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbDJBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICBpZiAocmVhZGluZykge1xuICAgICAgICAgICAgICAgIHJlYWRBZ2FpbkZvckJyYW5jaDIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZWFkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJ5b2JSZXF1ZXN0ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldEJZT0JSZXF1ZXN0KGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICBpZiAoYnlvYlJlcXVlc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdWxsV2l0aERlZmF1bHRSZWFkZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHB1bGxXaXRoQllPQlJlYWRlcihieW9iUmVxdWVzdC5fdmlldywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbDFBbGdvcml0aG0ocmVhc29uKSB7XG4gICAgICAgICAgICBjYW5jZWxlZDEgPSB0cnVlO1xuICAgICAgICAgICAgcmVhc29uMSA9IHJlYXNvbjtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb3NpdGVSZWFzb24gPSBDcmVhdGVBcnJheUZyb21MaXN0KFtyZWFzb24xLCByZWFzb24yXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsUmVzdWx0ID0gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCBjb21wb3NpdGVSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVDYW5jZWxQcm9taXNlKGNhbmNlbFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FuY2VsUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYW5jZWwyQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgY2FuY2VsZWQyID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlYXNvbjIgPSByZWFzb247XG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG9zaXRlUmVhc29uID0gQ3JlYXRlQXJyYXlGcm9tTGlzdChbcmVhc29uMSwgcmVhc29uMl0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgYnJhbmNoMSA9IENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbDFBbGdvcml0aG0sIGNhbmNlbDFBbGdvcml0aG0pO1xuICAgICAgICBicmFuY2gyID0gQ3JlYXRlUmVhZGFibGVCeXRlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsMkFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG4gICAgICAgIGZvcndhcmRSZWFkZXJFcnJvcihyZWFkZXIpO1xuICAgICAgICByZXR1cm4gW2JyYW5jaDEsIGJyYW5jaDJdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzUmVhZGFibGVTdHJlYW1MaWtlKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gdHlwZUlzT2JqZWN0KHN0cmVhbSkgJiYgdHlwZW9mIHN0cmVhbS5nZXRSZWFkZXIgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbShzb3VyY2UpIHtcbiAgICAgICAgaWYgKGlzUmVhZGFibGVTdHJlYW1MaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUZyb21EZWZhdWx0UmVhZGVyKHNvdXJjZS5nZXRSZWFkZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRnJvbUl0ZXJhYmxlKHNvdXJjZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbUl0ZXJhYmxlKGFzeW5jSXRlcmFibGUpIHtcbiAgICAgICAgbGV0IHN0cmVhbTtcbiAgICAgICAgY29uc3QgaXRlcmF0b3JSZWNvcmQgPSBHZXRJdGVyYXRvcihhc3luY0l0ZXJhYmxlLCAnYXN5bmMnKTtcbiAgICAgICAgY29uc3Qgc3RhcnRBbGdvcml0aG0gPSBub29wO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgbGV0IG5leHRSZXN1bHQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5leHRSZXN1bHQgPSBJdGVyYXRvck5leHQoaXRlcmF0b3JSZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aChuZXh0UmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChuZXh0UHJvbWlzZSwgaXRlclJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoaXRlclJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIGl0ZXJhdG9yLm5leHQoKSBtZXRob2QgbXVzdCBmdWxmaWxsIHdpdGggYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRvbmUgPSBJdGVyYXRvckNvbXBsZXRlKGl0ZXJSZXN1bHQpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEl0ZXJhdG9yVmFsdWUoaXRlclJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgY29uc3QgaXRlcmF0b3IgPSBpdGVyYXRvclJlY29yZC5pdGVyYXRvcjtcbiAgICAgICAgICAgIGxldCByZXR1cm5NZXRob2Q7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybk1ldGhvZCA9IEdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXR1cm5NZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmV0dXJuUmVzdWx0O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm5SZXN1bHQgPSByZWZsZWN0Q2FsbChyZXR1cm5NZXRob2QsIGl0ZXJhdG9yLCBbcmVhc29uXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmV0dXJuUHJvbWlzZSA9IHByb21pc2VSZXNvbHZlZFdpdGgocmV0dXJuUmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXR1cm5Qcm9taXNlLCBpdGVyUmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGVJc09iamVjdChpdGVyUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgcHJvbWlzZSByZXR1cm5lZCBieSB0aGUgaXRlcmF0b3IucmV0dXJuKCkgbWV0aG9kIG11c3QgZnVsZmlsbCB3aXRoIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCk7XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRnJvbURlZmF1bHRSZWFkZXIocmVhZGVyKSB7XG4gICAgICAgIGxldCBzdHJlYW07XG4gICAgICAgIGNvbnN0IHN0YXJ0QWxnb3JpdGhtID0gbm9vcDtcbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIGxldCByZWFkUHJvbWlzZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVhZFByb21pc2UgPSByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZWFkUHJvbWlzZSwgcmVhZFJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QocmVhZFJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIHJlYWRlci5yZWFkKCkgbWV0aG9kIG11c3QgZnVsZmlsbCB3aXRoIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVhZFJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHJlYWRSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FuY2VsQWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChyZWFkZXIuY2FuY2VsKHJlYXNvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0gPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCAwKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2Uoc291cmNlLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkoc291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2U7XG4gICAgICAgIGNvbnN0IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5hdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gICAgICAgIGNvbnN0IGNhbmNlbCA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5jYW5jZWw7XG4gICAgICAgIGNvbnN0IHB1bGwgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwucHVsbDtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHlwZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZTogYXV0b0FsbG9jYXRlQ2h1bmtTaXplID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuc2lnbmVkTG9uZ0xvbmdXaXRoRW5mb3JjZVJhbmdlKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnYXV0b0FsbG9jYXRlQ2h1bmtTaXplJyB0aGF0YCksXG4gICAgICAgICAgICBjYW5jZWw6IGNhbmNlbCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlQ2FuY2VsQ2FsbGJhY2soY2FuY2VsLCBvcmlnaW5hbCwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnY2FuY2VsJyB0aGF0YCksXG4gICAgICAgICAgICBwdWxsOiBwdWxsID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2socHVsbCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3B1bGwnIHRoYXRgKSxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgICAgICAgICB0eXBlOiB0eXBlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBjb252ZXJ0UmVhZGFibGVTdHJlYW1UeXBlKHR5cGUsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3R5cGUnIHRoYXRgKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb252ZXJ0VW5kZXJseWluZ1NvdXJjZUNhbmNlbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFVuZGVybHlpbmdTb3VyY2VQdWxsQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRVbmRlcmx5aW5nU291cmNlU3RhcnRDYWxsYmFjayhmbiwgb3JpZ2luYWwsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RnVuY3Rpb24oZm4sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gKGNvbnRyb2xsZXIpID0+IHJlZmxlY3RDYWxsKGZuLCBvcmlnaW5hbCwgW2NvbnRyb2xsZXJdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSh0eXBlLCBjb250ZXh0KSB7XG4gICAgICAgIHR5cGUgPSBgJHt0eXBlfWA7XG4gICAgICAgIGlmICh0eXBlICE9PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2NvbnRleHR9ICcke3R5cGV9JyBpcyBub3QgYSB2YWxpZCBlbnVtZXJhdGlvbiB2YWx1ZSBmb3IgUmVhZGFibGVTdHJlYW1UeXBlYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcbiAgICAgICAgcmV0dXJuIHsgcHJldmVudENhbmNlbDogQm9vbGVhbihwcmV2ZW50Q2FuY2VsKSB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRQaXBlT3B0aW9ucyhvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkob3B0aW9ucywgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByZXZlbnRBYm9ydCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmV2ZW50QWJvcnQ7XG4gICAgICAgIGNvbnN0IHByZXZlbnRDYW5jZWwgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucHJldmVudENhbmNlbDtcbiAgICAgICAgY29uc3QgcHJldmVudENsb3NlID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXZlbnRDbG9zZTtcbiAgICAgICAgY29uc3Qgc2lnbmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpZ25hbDtcbiAgICAgICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3NpZ25hbCcgdGhhdGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmV2ZW50QWJvcnQ6IEJvb2xlYW4ocHJldmVudEFib3J0KSxcbiAgICAgICAgICAgIHByZXZlbnRDYW5jZWw6IEJvb2xlYW4ocHJldmVudENhbmNlbCksXG4gICAgICAgICAgICBwcmV2ZW50Q2xvc2U6IEJvb2xlYW4ocHJldmVudENsb3NlKSxcbiAgICAgICAgICAgIHNpZ25hbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRBYm9ydFNpZ25hbChzaWduYWwsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y29udGV4dH0gaXMgbm90IGFuIEFib3J0U2lnbmFsLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHBhaXIsIGNvbnRleHQpIHtcbiAgICAgICAgYXNzZXJ0RGljdGlvbmFyeShwYWlyLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgcmVhZGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIucmVhZGFibGU7XG4gICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQocmVhZGFibGUsICdyZWFkYWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICAgICAgICBhc3NlcnRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAncmVhZGFibGUnIHRoYXRgKTtcbiAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBwYWlyID09PSBudWxsIHx8IHBhaXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhaXIud3JpdGFibGU7XG4gICAgICAgIGFzc2VydFJlcXVpcmVkRmllbGQod3JpdGFibGUsICd3cml0YWJsZScsICdSZWFkYWJsZVdyaXRhYmxlUGFpcicpO1xuICAgICAgICBhc3NlcnRXcml0YWJsZVN0cmVhbSh3cml0YWJsZSwgYCR7Y29udGV4dH0gaGFzIG1lbWJlciAnd3JpdGFibGUnIHRoYXRgKTtcbiAgICAgICAgcmV0dXJuIHsgcmVhZGFibGUsIHdyaXRhYmxlIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSByZWFkYWJsZSBzdHJlYW0gcmVwcmVzZW50cyBhIHNvdXJjZSBvZiBkYXRhLCBmcm9tIHdoaWNoIHlvdSBjYW4gcmVhZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1VuZGVybHlpbmdTb3VyY2UgPSB7fSwgcmF3U3RyYXRlZ3kgPSB7fSkge1xuICAgICAgICAgICAgaWYgKHJhd1VuZGVybHlpbmdTb3VyY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJhd1VuZGVybHlpbmdTb3VyY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0T2JqZWN0KHJhd1VuZGVybHlpbmdTb3VyY2UsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdTdHJhdGVneSwgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHVuZGVybHlpbmdTb3VyY2UgPSBjb252ZXJ0VW5kZXJseWluZ0RlZmF1bHRPckJ5dGVTb3VyY2UocmF3VW5kZXJseWluZ1NvdXJjZSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHVuZGVybHlpbmdTb3VyY2UudHlwZSA9PT0gJ2J5dGVzJykge1xuICAgICAgICAgICAgICAgIGlmIChzdHJhdGVneS5zaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBzdHJhdGVneSBmb3IgYSBieXRlIHN0cmVhbSBjYW5ub3QgaGF2ZSBhIHNpemUgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAwKTtcbiAgICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShzdHJhdGVneSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHN0cmF0ZWd5LCAxKTtcbiAgICAgICAgICAgICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVW5kZXJseWluZ1NvdXJjZSh0aGlzLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdGhlIHJlYWRhYmxlIHN0cmVhbSBpcyBsb2NrZWQgdG8gYSB7QGxpbmsgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyIHwgcmVhZGVyfS5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBsb2NrZWQoKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2xvY2tlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbmNlbHMgdGhlIHN0cmVhbSwgc2lnbmFsaW5nIGEgbG9zcyBvZiBpbnRlcmVzdCBpbiB0aGUgc3RyZWFtIGJ5IGEgY29uc3VtZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBzdXBwbGllZCBgcmVhc29uYCBhcmd1bWVudCB3aWxsIGJlIGdpdmVuIHRvIHRoZSB1bmRlcmx5aW5nIHNvdXJjZSdzIHtAbGluayBVbmRlcmx5aW5nU291cmNlLmNhbmNlbCB8IGNhbmNlbCgpfVxuICAgICAgICAgKiBtZXRob2QsIHdoaWNoIG1pZ2h0IG9yIG1pZ2h0IG5vdCB1c2UgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBjYW5jZWwocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzUmVhZGFibGVTdHJlYW0odGhpcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2NhbmNlbCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UmVhZGVyKHJhd09wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZ2V0UmVhZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydFJlYWRlck9wdGlvbnMocmF3T3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBwaXBlVGhyb3VnaChyYXdUcmFuc2Zvcm0sIHJhd09wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVGhyb3VnaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0UmVxdWlyZWRBcmd1bWVudChyYXdUcmFuc2Zvcm0sIDEsICdwaXBlVGhyb3VnaCcpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gY29udmVydFJlYWRhYmxlV3JpdGFibGVQYWlyKHJhd1RyYW5zZm9ybSwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGNvbnZlcnRQaXBlT3B0aW9ucyhyYXdPcHRpb25zLCAnU2Vjb25kIHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRyYW5zZm9ybS53cml0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCB0cmFuc2Zvcm0ud3JpdGFibGUsIG9wdGlvbnMucHJldmVudENsb3NlLCBvcHRpb25zLnByZXZlbnRBYm9ydCwgb3B0aW9ucy5wcmV2ZW50Q2FuY2VsLCBvcHRpb25zLnNpZ25hbCk7XG4gICAgICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5yZWFkYWJsZTtcbiAgICAgICAgfVxuICAgICAgICBwaXBlVG8oZGVzdGluYXRpb24sIHJhd09wdGlvbnMgPSB7fSkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdwaXBlVG8nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVzdGluYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGBQYXJhbWV0ZXIgMSBpcyByZXF1aXJlZCBpbiAncGlwZVRvJy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSXNXcml0YWJsZVN0cmVhbShkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvJ3MgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIFdyaXRhYmxlU3RyZWFtYCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBjb252ZXJ0UGlwZU9wdGlvbnMocmF3T3B0aW9ucywgJ1NlY29uZCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0aW5hdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvIGNhbm5vdCBiZSB1c2VkIG9uIGEgbG9ja2VkIFdyaXRhYmxlU3RyZWFtJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHRoaXMsIGRlc3RpbmF0aW9uLCBvcHRpb25zLnByZXZlbnRDbG9zZSwgb3B0aW9ucy5wcmV2ZW50QWJvcnQsIG9wdGlvbnMucHJldmVudENhbmNlbCwgb3B0aW9ucy5zaWduYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUZWVzIHRoaXMgcmVhZGFibGUgc3RyZWFtLCByZXR1cm5pbmcgYSB0d28tZWxlbWVudCBhcnJheSBjb250YWluaW5nIHRoZSB0d28gcmVzdWx0aW5nIGJyYW5jaGVzIGFzXG4gICAgICAgICAqIG5ldyB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGluc3RhbmNlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGVlaW5nIGEgc3RyZWFtIHdpbGwgbG9jayBpdCwgcHJldmVudGluZyBhbnkgb3RoZXIgY29uc3VtZXIgZnJvbSBhY3F1aXJpbmcgYSByZWFkZXIuXG4gICAgICAgICAqIFRvIGNhbmNlbCB0aGUgc3RyZWFtLCBjYW5jZWwgYm90aCBvZiB0aGUgcmVzdWx0aW5nIGJyYW5jaGVzOyBhIGNvbXBvc2l0ZSBjYW5jZWxsYXRpb24gcmVhc29uIHdpbGwgdGhlbiBiZVxuICAgICAgICAgKiBwcm9wYWdhdGVkIHRvIHRoZSBzdHJlYW0ncyB1bmRlcmx5aW5nIHNvdXJjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZSBjaHVua3Mgc2VlbiBpbiBlYWNoIGJyYW5jaCB3aWxsIGJlIHRoZSBzYW1lIG9iamVjdC4gSWYgdGhlIGNodW5rcyBhcmUgbm90IGltbXV0YWJsZSxcbiAgICAgICAgICogdGhpcyBjb3VsZCBhbGxvdyBpbnRlcmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIGJyYW5jaGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGVlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCd0ZWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gQ3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzKHJhd09wdGlvbnMgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICghSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgndmFsdWVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY29udmVydEl0ZXJhdG9yT3B0aW9ucyhyYXdPcHRpb25zLCAnRmlyc3QgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzLCBvcHRpb25zLnByZXZlbnRDYW5jZWwpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFJlYWRhYmxlU3RyZWFtIHdyYXBwaW5nIHRoZSBwcm92aWRlZCBpdGVyYWJsZSBvciBhc3luYyBpdGVyYWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBjYW4gYmUgdXNlZCB0byBhZGFwdCB2YXJpb3VzIGtpbmRzIG9mIG9iamVjdHMgaW50byBhIHJlYWRhYmxlIHN0cmVhbSxcbiAgICAgICAgICogc3VjaCBhcyBhbiBhcnJheSwgYW4gYXN5bmMgZ2VuZXJhdG9yLCBvciBhIE5vZGUuanMgcmVhZGFibGUgc3RyZWFtLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb20oYXN5bmNJdGVyYWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRnJvbShhc3luY0l0ZXJhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhSZWFkYWJsZVN0cmVhbSwge1xuICAgICAgICBmcm9tOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwge1xuICAgICAgICBjYW5jZWw6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBnZXRSZWFkZXI6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBwaXBlVGhyb3VnaDogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHBpcGVUbzogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHRlZTogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIHZhbHVlczogeyBlbnVtZXJhYmxlOiB0cnVlIH0sXG4gICAgICAgIGxvY2tlZDogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0uZnJvbSwgJ2Zyb20nKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLmNhbmNlbCwgJ2NhbmNlbCcpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0UmVhZGVyLCAnZ2V0UmVhZGVyJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCwgJ3BpcGVUaHJvdWdoJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8sICdwaXBlVG8nKTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlLnRlZSwgJ3RlZScpO1xuICAgIHNldEZ1bmN0aW9uTmFtZShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudmFsdWVzLCAndmFsdWVzJyk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnUmVhZGFibGVTdHJlYW0nLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IsIHtcbiAgICAgICAgICAgIHZhbHVlOiBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUudmFsdWVzLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFic3RyYWN0IG9wZXJhdGlvbnMgZm9yIHRoZSBSZWFkYWJsZVN0cmVhbS5cbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuICAgIGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmsgPSAxLCBzaXplQWxnb3JpdGhtID0gKCkgPT4gMSkge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gICAgICAgIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gICAgICAgIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbiAgICAvLyBUaHJvd3MgaWYgYW5kIG9ubHkgaWYgc3RhcnRBbGdvcml0aG0gdGhyb3dzLlxuICAgIGZ1bmN0aW9uIENyZWF0ZVJlYWRhYmxlQnl0ZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW0ucHJvdG90eXBlKTtcbiAgICAgICAgSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSk7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgICAgICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgMCwgdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcbiAgICAgICAgc3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkge1xuICAgICAgICBpZiAoc3RyZWFtLl9yZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBSZWFkYWJsZVN0cmVhbSBBUEkgZXhwb3NlZCBmb3IgY29udHJvbGxlcnMuXG4gICAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgICAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgICAgICAgaWYgKHJlYWRlciAhPT0gdW5kZWZpbmVkICYmIElzUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHJlYWRlcikpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRJbnRvUmVxdWVzdHMgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHM7XG4gICAgICAgICAgICByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdHMuZm9yRWFjaChyZWFkSW50b1JlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlYWRJbnRvUmVxdWVzdC5fY2xvc2VTdGVwcyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gICAgICAgIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzb2x2ZShyZWFkZXIpO1xuICAgICAgICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgICAgICAgICAgY29uc3QgcmVhZFJlcXVlc3RzID0gcmVhZGVyLl9yZWFkUmVxdWVzdHM7XG4gICAgICAgICAgICByZWFkZXIuX3JlYWRSZXF1ZXN0cyA9IG5ldyBTaW1wbGVRdWV1ZSgpO1xuICAgICAgICAgICAgcmVhZFJlcXVlc3RzLmZvckVhY2gocmVhZFJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgIHJlYWRSZXF1ZXN0Ll9jbG9zZVN0ZXBzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUVycm9yKHN0cmVhbSwgZSkge1xuICAgICAgICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yZWQnO1xuICAgICAgICBzdHJlYW0uX3N0b3JlZEVycm9yID0gZTtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gICAgICAgIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgZSk7XG4gICAgICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihyZWFkZXIpKSB7XG4gICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJFcnJvclJlYWRSZXF1ZXN0cyhyZWFkZXIsIGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyRXJyb3JSZWFkSW50b1JlcXVlc3RzKHJlYWRlciwgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgdGhlIFJlYWRhYmxlU3RyZWFtLlxuICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMShuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVHlwZUVycm9yKGBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuJHtuYW1lfSBjYW4gb25seSBiZSB1c2VkIG9uIGEgUmVhZGFibGVTdHJlYW1gKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdChpbml0LCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydERpY3Rpb25hcnkoaW5pdCwgY29udGV4dCk7XG4gICAgICAgIGNvbnN0IGhpZ2hXYXRlck1hcmsgPSBpbml0ID09PSBudWxsIHx8IGluaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluaXQuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgYXNzZXJ0UmVxdWlyZWRGaWVsZChoaWdoV2F0ZXJNYXJrLCAnaGlnaFdhdGVyTWFyaycsICdRdWV1aW5nU3RyYXRlZ3lJbml0Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrOiBjb252ZXJ0VW5yZXN0cmljdGVkRG91YmxlKGhpZ2hXYXRlck1hcmspXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpemUgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBub3IgYmUgYSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IGJ5dGVMZW5ndGhTaXplRnVuY3Rpb24gPSAoY2h1bmspID0+IHtcbiAgICAgICAgcmV0dXJuIGNodW5rLmJ5dGVMZW5ndGg7XG4gICAgfTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoYnl0ZUxlbmd0aFNpemVGdW5jdGlvbiwgJ3NpemUnKTtcbiAgICAvKipcbiAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBieXRlcyBpbiBlYWNoIGNodW5rLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kge1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5Jyk7XG4gICAgICAgICAgICBvcHRpb25zID0gY29udmVydFF1ZXVpbmdTdHJhdGVneUluaXQob3B0aW9ucywgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgdGhpcy5fYnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneUhpZ2hXYXRlck1hcmsgPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGhpZ2ggd2F0ZXIgbWFyayBwcm92aWRlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGlnaFdhdGVyTWFyaygpIHtcbiAgICAgICAgICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ2hpZ2hXYXRlck1hcmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ieXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTWVhc3VyZXMgdGhlIHNpemUgb2YgYGNodW5rYCBieSByZXR1cm5pbmcgdGhlIHZhbHVlIG9mIGl0cyBgYnl0ZUxlbmd0aGAgcHJvcGVydHkuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3NpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBieXRlTGVuZ3RoU2l6ZUZ1bmN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCB7XG4gICAgICAgIGhpZ2hXYXRlck1hcms6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBzaXplOiB7IGVudW1lcmFibGU6IHRydWUgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwgU3ltYm9sUG9seWZpbGwudG9TdHJpbmdUYWcsIHtcbiAgICAgICAgICAgIHZhbHVlOiAnQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LlxuICAgIGZ1bmN0aW9uIGJ5dGVMZW5ndGhCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5KHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNpemUgZnVuY3Rpb24gbXVzdCBub3QgaGF2ZSBhIHByb3RvdHlwZSBwcm9wZXJ0eSBub3IgYmUgYSBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IGNvdW50U2l6ZUZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9O1xuICAgIHNldEZ1bmN0aW9uTmFtZShjb3VudFNpemVGdW5jdGlvbiwgJ3NpemUnKTtcbiAgICAvKipcbiAgICAgKiBBIHF1ZXVpbmcgc3RyYXRlZ3kgdGhhdCBjb3VudHMgdGhlIG51bWJlciBvZiBjaHVua3MuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY2xhc3MgQ291bnRRdWV1aW5nU3RyYXRlZ3kge1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICBhc3NlcnRSZXF1aXJlZEFyZ3VtZW50KG9wdGlvbnMsIDEsICdDb3VudFF1ZXVpbmdTdHJhdGVneScpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbnZlcnRRdWV1aW5nU3RyYXRlZ3lJbml0KG9wdGlvbnMsICdGaXJzdCBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgaGlnaCB3YXRlciBtYXJrIHByb3ZpZGVkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIGdldCBoaWdoV2F0ZXJNYXJrKCkge1xuICAgICAgICAgICAgaWYgKCFJc0NvdW50UXVldWluZ1N0cmF0ZWd5KHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgY291bnRCcmFuZENoZWNrRXhjZXB0aW9uKCdoaWdoV2F0ZXJNYXJrJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZWFzdXJlcyB0aGUgc2l6ZSBvZiBgY2h1bmtgIGJ5IGFsd2F5cyByZXR1cm5pbmcgMS5cbiAgICAgICAgICogVGhpcyBlbnN1cmVzIHRoYXQgdGhlIHRvdGFsIHF1ZXVlIHNpemUgaXMgYSBjb3VudCBvZiB0aGUgbnVtYmVyIG9mIGNodW5rcyBpbiB0aGUgcXVldWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgIGlmICghSXNDb3VudFF1ZXVpbmdTdHJhdGVneSh0aGlzKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGNvdW50QnJhbmRDaGVja0V4Y2VwdGlvbignc2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvdW50U2l6ZUZ1bmN0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKENvdW50UXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZSwge1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgc2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdDb3VudFF1ZXVpbmdTdHJhdGVneScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIHRoZSBDb3VudFF1ZXVpbmdTdHJhdGVneS5cbiAgICBmdW5jdGlvbiBjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLiR7bmFtZX0gY2FuIG9ubHkgYmUgdXNlZCBvbiBhIENvdW50UXVldWluZ1N0cmF0ZWd5YCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIElzQ291bnRRdWV1aW5nU3RyYXRlZ3koeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY291bnRRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lcihvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnREaWN0aW9uYXJ5KG9yaWdpbmFsLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLmNhbmNlbDtcbiAgICAgICAgY29uc3QgZmx1c2ggPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwuZmx1c2g7XG4gICAgICAgIGNvbnN0IHJlYWRhYmxlVHlwZSA9IG9yaWdpbmFsID09PSBudWxsIHx8IG9yaWdpbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5hbC5yZWFkYWJsZVR5cGU7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gb3JpZ2luYWwgPT09IG51bGwgfHwgb3JpZ2luYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbmFsLnN0YXJ0O1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwudHJhbnNmb3JtO1xuICAgICAgICBjb25zdCB3cml0YWJsZVR5cGUgPSBvcmlnaW5hbCA9PT0gbnVsbCB8fCBvcmlnaW5hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luYWwud3JpdGFibGVUeXBlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWwgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICAgICBjb252ZXJ0VHJhbnNmb3JtZXJDYW5jZWxDYWxsYmFjayhjYW5jZWwsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdjYW5jZWwnIHRoYXRgKSxcbiAgICAgICAgICAgIGZsdXNoOiBmbHVzaCA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZmx1c2gsIG9yaWdpbmFsLCBgJHtjb250ZXh0fSBoYXMgbWVtYmVyICdmbHVzaCcgdGhhdGApLFxuICAgICAgICAgICAgcmVhZGFibGVUeXBlLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6XG4gICAgICAgICAgICAgICAgY29udmVydFRyYW5zZm9ybWVyU3RhcnRDYWxsYmFjayhzdGFydCwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3N0YXJ0JyB0aGF0YCksXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICB1bmRlZmluZWQgOlxuICAgICAgICAgICAgICAgIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKHRyYW5zZm9ybSwgb3JpZ2luYWwsIGAke2NvbnRleHR9IGhhcyBtZW1iZXIgJ3RyYW5zZm9ybScgdGhhdGApLFxuICAgICAgICAgICAgd3JpdGFibGVUeXBlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckZsdXNoQ2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2soZm4sIG9yaWdpbmFsLCBjb250ZXh0KSB7XG4gICAgICAgIGFzc2VydEZ1bmN0aW9uKGZuLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIChjb250cm9sbGVyKSA9PiByZWZsZWN0Q2FsbChmbiwgb3JpZ2luYWwsIFtjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lclRyYW5zZm9ybUNhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHByb21pc2VDYWxsKGZuLCBvcmlnaW5hbCwgW2NodW5rLCBjb250cm9sbGVyXSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrKGZuLCBvcmlnaW5hbCwgY29udGV4dCkge1xuICAgICAgICBhc3NlcnRGdW5jdGlvbihmbiwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiAocmVhc29uKSA9PiBwcm9taXNlQ2FsbChmbiwgb3JpZ2luYWwsIFtyZWFzb25dKTtcbiAgICB9XG5cbiAgICAvLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1cbiAgICAvKipcbiAgICAgKiBBIHRyYW5zZm9ybSBzdHJlYW0gY29uc2lzdHMgb2YgYSBwYWlyIG9mIHN0cmVhbXM6IGEge0BsaW5rIFdyaXRhYmxlU3RyZWFtIHwgd3JpdGFibGUgc3RyZWFtfSxcbiAgICAgKiBrbm93biBhcyBpdHMgd3JpdGFibGUgc2lkZSwgYW5kIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtIHwgcmVhZGFibGUgc3RyZWFtfSwga25vd24gYXMgaXRzIHJlYWRhYmxlIHNpZGUuXG4gICAgICogSW4gYSBtYW5uZXIgc3BlY2lmaWMgdG8gdGhlIHRyYW5zZm9ybSBzdHJlYW0gaW4gcXVlc3Rpb24sIHdyaXRlcyB0byB0aGUgd3JpdGFibGUgc2lkZSByZXN1bHQgaW4gbmV3IGRhdGEgYmVpbmdcbiAgICAgKiBtYWRlIGF2YWlsYWJsZSBmb3IgcmVhZGluZyBmcm9tIHRoZSByZWFkYWJsZSBzaWRlLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFRyYW5zZm9ybVN0cmVhbSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJhd1RyYW5zZm9ybWVyID0ge30sIHJhd1dyaXRhYmxlU3RyYXRlZ3kgPSB7fSwgcmF3UmVhZGFibGVTdHJhdGVneSA9IHt9KSB7XG4gICAgICAgICAgICBpZiAocmF3VHJhbnNmb3JtZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJhd1RyYW5zZm9ybWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlU3RyYXRlZ3kgPSBjb252ZXJ0UXVldWluZ1N0cmF0ZWd5KHJhd1dyaXRhYmxlU3RyYXRlZ3ksICdTZWNvbmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZVN0cmF0ZWd5ID0gY29udmVydFF1ZXVpbmdTdHJhdGVneShyYXdSZWFkYWJsZVN0cmF0ZWd5LCAnVGhpcmQgcGFyYW1ldGVyJyk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNvbnZlcnRUcmFuc2Zvcm1lcihyYXdUcmFuc2Zvcm1lciwgJ0ZpcnN0IHBhcmFtZXRlcicpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgcmVhZGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybWVyLndyaXRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd3JpdGFibGVUeXBlIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVIaWdoV2F0ZXJNYXJrID0gRXh0cmFjdEhpZ2hXYXRlck1hcmsocmVhZGFibGVTdHJhdGVneSwgMCk7XG4gICAgICAgICAgICBjb25zdCByZWFkYWJsZVNpemVBbGdvcml0aG0gPSBFeHRyYWN0U2l6ZUFsZ29yaXRobShyZWFkYWJsZVN0cmF0ZWd5KTtcbiAgICAgICAgICAgIGNvbnN0IHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IEV4dHJhY3RIaWdoV2F0ZXJNYXJrKHdyaXRhYmxlU3RyYXRlZ3ksIDEpO1xuICAgICAgICAgICAgY29uc3Qgd3JpdGFibGVTaXplQWxnb3JpdGhtID0gRXh0cmFjdFNpemVBbGdvcml0aG0od3JpdGFibGVTdHJhdGVneSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRQcm9taXNlX3Jlc29sdmU7XG4gICAgICAgICAgICBjb25zdCBzdGFydFByb21pc2UgPSBuZXdQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0UHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgSW5pdGlhbGl6ZVRyYW5zZm9ybVN0cmVhbSh0aGlzLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gICAgICAgICAgICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVRyYW5zZm9ybWVyKHRoaXMsIHRyYW5zZm9ybWVyKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lci5zdGFydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodHJhbnNmb3JtZXIuc3RhcnQodGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRQcm9taXNlX3Jlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmVhZGFibGUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHdyaXRhYmxlIHNpZGUgb2YgdGhlIHRyYW5zZm9ybSBzdHJlYW0uXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgd3JpdGFibGUoKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignd3JpdGFibGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCB7XG4gICAgICAgIHJlYWRhYmxlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgd3JpdGFibGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZyA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnLCB7XG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zZm9ybVN0cmVhbScsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEluaXRpYWxpemVUcmFuc2Zvcm1TdHJlYW0oc3RyZWFtLCBzdGFydFByb21pc2UsIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtLCByZWFkYWJsZUhpZ2hXYXRlck1hcmssIHJlYWRhYmxlU2l6ZUFsZ29yaXRobSkge1xuICAgICAgICBmdW5jdGlvbiBzdGFydEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JpdGVBbGdvcml0aG0oY2h1bmspIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFib3J0QWxnb3JpdGhtKHJlYXNvbikge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3NlQWxnb3JpdGhtKCkge1xuICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3dyaXRhYmxlID0gQ3JlYXRlV3JpdGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIHdyaXRhYmxlSGlnaFdhdGVyTWFyaywgd3JpdGFibGVTaXplQWxnb3JpdGhtKTtcbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsZ29yaXRobSgpIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlUHVsbEFsZ29yaXRobShzdHJlYW0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbmNlbEFsZ29yaXRobShyZWFzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlQ2FuY2VsQWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0uX3JlYWRhYmxlID0gQ3JlYXRlUmVhZGFibGVTdHJlYW0oc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG0pO1xuICAgICAgICAvLyBUaGUgW1tiYWNrcHJlc3N1cmVdXSBzbG90IGlzIHNldCB0byB1bmRlZmluZWQgc28gdGhhdCBpdCBjYW4gYmUgaW5pdGlhbGlzZWQgYnkgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlLlxuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gICAgICAgIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXNUcmFuc2Zvcm1TdHJlYW0oeCkge1xuICAgICAgICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBUcmFuc2Zvcm1TdHJlYW07XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgYSBuby1vcCBpZiBib3RoIHNpZGVzIGFyZSBhbHJlYWR5IGVycm9yZWQuXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKSB7XG4gICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihzdHJlYW0uX3JlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIGUpO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKSB7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHN0cmVhbS5fd3JpdGFibGUuX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbVVuYmxvY2tXcml0ZShzdHJlYW0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUoc3RyZWFtKSB7XG4gICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgLy8gUHJldGVuZCB0aGF0IHB1bGwoKSB3YXMgY2FsbGVkIHRvIHBlcm1pdCBhbnkgcGVuZGluZyB3cml0ZSgpIGNhbGxzIHRvIGNvbXBsZXRlLiBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoKVxuICAgICAgICAgICAgLy8gY2Fubm90IGJlIGNhbGxlZCBmcm9tIGVucXVldWUoKSBvciBwdWxsKCkgb25jZSB0aGUgUmVhZGFibGVTdHJlYW0gaXMgZXJyb3JlZCwgc28gdGhpcyB3aWxsIHdpbGwgYmUgdGhlIGZpbmFsIHRpbWVcbiAgICAgICAgICAgIC8vIF9iYWNrcHJlc3N1cmUgaXMgc2V0LlxuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGJhY2twcmVzc3VyZSkge1xuICAgICAgICAvLyBQYXNzZXMgYWxzbyB3aGVuIGNhbGxlZCBkdXJpbmcgY29uc3RydWN0aW9uLlxuICAgICAgICBpZiAoc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlID0gbmV3UHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gYmFja3ByZXNzdXJlO1xuICAgIH1cbiAgICAvLyBDbGFzcyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclxuICAgIC8qKlxuICAgICAqIEFsbG93cyBjb250cm9sIG9mIHRoZSB7QGxpbmsgUmVhZGFibGVTdHJlYW19IGFuZCB7QGxpbmsgV3JpdGFibGVTdHJlYW19IG9mIHRoZSBhc3NvY2lhdGVkIHtAbGluayBUcmFuc2Zvcm1TdHJlYW19LlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsYXNzIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIGRlc2lyZWQgc2l6ZSB0byBmaWxsIHRoZSByZWFkYWJsZSBzaWRl4oCZcyBpbnRlcm5hbCBxdWV1ZS4gSXQgY2FuIGJlIG5lZ2F0aXZlLCBpZiB0aGUgcXVldWUgaXMgb3Zlci1mdWxsLlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGRlc2lyZWRTaXplKCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdkZXNpcmVkU2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbnF1ZXVlKGNodW5rID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2VucXVldWUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSh0aGlzLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVycm9ycyBib3RoIHRoZSByZWFkYWJsZSBzaWRlIGFuZCB0aGUgd3JpdGFibGUgc2lkZSBvZiB0aGUgY29udHJvbGxlZCB0cmFuc2Zvcm0gc3RyZWFtLCBtYWtpbmcgYWxsIGZ1dHVyZVxuICAgICAgICAgKiBpbnRlcmFjdGlvbnMgd2l0aCBpdCBmYWlsIHdpdGggdGhlIGdpdmVuIGVycm9yIGBlYC4gQW55IGNodW5rcyBxdWV1ZWQgZm9yIHRyYW5zZm9ybWF0aW9uIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgZXJyb3IocmVhc29uID0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIUlzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Vycm9yJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHRoaXMsIHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsb3NlcyB0aGUgcmVhZGFibGUgc2lkZSBhbmQgZXJyb3JzIHRoZSB3cml0YWJsZSBzaWRlIG9mIHRoZSBjb250cm9sbGVkIHRyYW5zZm9ybSBzdHJlYW0uIFRoaXMgaXMgdXNlZnVsIHdoZW4gdGhlXG4gICAgICAgICAqIHRyYW5zZm9ybWVyIG9ubHkgbmVlZHMgdG8gY29uc3VtZSBhIHBvcnRpb24gb2YgdGhlIGNodW5rcyB3cml0dGVuIHRvIHRoZSB3cml0YWJsZSBzaWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGVybWluYXRlKCkge1xuICAgICAgICAgICAgaWYgKCFJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCd0ZXJtaW5hdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSwge1xuICAgICAgICBlbnF1ZXVlOiB7IGVudW1lcmFibGU6IHRydWUgfSxcbiAgICAgICAgZXJyb3I6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICB0ZXJtaW5hdGU6IHsgZW51bWVyYWJsZTogdHJ1ZSB9LFxuICAgICAgICBkZXNpcmVkU2l6ZTogeyBlbnVtZXJhYmxlOiB0cnVlIH1cbiAgICB9KTtcbiAgICBzZXRGdW5jdGlvbk5hbWUoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUsICdlbnF1ZXVlJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lcnJvciwgJ2Vycm9yJyk7XG4gICAgc2V0RnVuY3Rpb25OYW1lKFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS50ZXJtaW5hdGUsICd0ZXJtaW5hdGUnKTtcbiAgICBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLnRvU3RyaW5nVGFnID09PSAnc3ltYm9sJykge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC50b1N0cmluZ1RhZywge1xuICAgICAgICAgICAgdmFsdWU6ICdUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcicsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybSBTdHJlYW0gRGVmYXVsdCBDb250cm9sbGVyIEFic3RyYWN0IE9wZXJhdGlvbnNcbiAgICBmdW5jdGlvbiBJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgICAgICAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0nKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0pIHtcbiAgICAgICAgY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdHJhbnNmb3JtQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IGZsdXNoQWxnb3JpdGhtO1xuICAgICAgICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIoc3RyZWFtLCB0cmFuc2Zvcm1lcikge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICAgICAgICBsZXQgdHJhbnNmb3JtQWxnb3JpdGhtO1xuICAgICAgICBsZXQgZmx1c2hBbGdvcml0aG07XG4gICAgICAgIGxldCBjYW5jZWxBbGdvcml0aG07XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lci50cmFuc2Zvcm0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQWxnb3JpdGhtID0gY2h1bmsgPT4gdHJhbnNmb3JtZXIudHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGNodW5rID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAodHJhbnNmb3JtUmVzdWx0RSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lci5mbHVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBmbHVzaEFsZ29yaXRobSA9ICgpID0+IHRyYW5zZm9ybWVyLmZsdXNoKGNvbnRyb2xsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmx1c2hBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zZm9ybWVyLmNhbmNlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSByZWFzb24gPT4gdHJhbnNmb3JtZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5jZWxBbGdvcml0aG0gPSAoKSA9PiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHRyYW5zZm9ybUFsZ29yaXRobSwgZmx1c2hBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgICAgICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUoY29udHJvbGxlciwgY2h1bmspIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBpZiAoIVJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZSBzaWRlIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgdGhyb3R0bGUgdHJhbnNmb3JtIGludm9jYXRpb25zIGJhc2VkIG9uIHRoZSBiYWNrcHJlc3N1cmUgb2YgdGhlIFJlYWRhYmxlU3RyZWFtLCBidXQgd2Ugc3RpbGxcbiAgICAgICAgLy8gYWNjZXB0IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSgpIGNhbGxzLlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUocmVhZGFibGVDb250cm9sbGVyLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaGFwcGVucyB3aGVuIHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZSgpIHRocm93cy5cbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbiAgICAgICAgICAgIHRocm93IHN0cmVhbS5fcmVhZGFibGUuX3N0b3JlZEVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhY2twcmVzc3VyZSA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJIYXNCYWNrcHJlc3N1cmUocmVhZGFibGVDb250cm9sbGVyKTtcbiAgICAgICAgaWYgKGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcihjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtLCBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCByID0+IHtcbiAgICAgICAgICAgIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIHIpO1xuICAgICAgICAgICAgdGhyb3cgcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgICAgICAgY29uc3QgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGVDb250cm9sbGVyKTtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuICAgICAgICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xuICAgIH1cbiAgICAvLyBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2luayBBbGdvcml0aG1zXG4gICAgZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgICAgICAgICAgY29uc3QgYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZTtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChiYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd3JpdGFibGUgPSBzdHJlYW0uX3dyaXRhYmxlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gd3JpdGFibGUuX3N0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyZWFtLl9yZWFkYWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICAgICAgICBjb25zdCByZWFkYWJsZSA9IHN0cmVhbS5fcmVhZGFibGU7XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgX2ZpbmlzaFByb21pc2Ugbm93IHNvIHRoYXQgaWYgX2NhbmNlbEFsZ29yaXRobSBjYWxscyByZWFkYWJsZS5jYW5jZWwoKSBpbnRlcm5hbGx5LFxuICAgICAgICAvLyB3ZSBkb24ndCBydW4gdGhlIF9jYW5jZWxBbGdvcml0aG0gYWdhaW4uXG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgPSBuZXdQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbFByb21pc2UgPSBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIHVwb25Qcm9taXNlKGNhbmNlbFByb21pc2UsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWFkYWJsZS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByZWFkYWJsZS5fc3RvcmVkRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHJlYWRhYmxlLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQ2xvc2VBbGdvcml0aG0oc3RyZWFtKSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGlmIChjb250cm9sbGVyLl9maW5pc2hQcm9taXNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cmVhbS5fcmVhZGFibGUgY2Fubm90IGNoYW5nZSBhZnRlciBjb25zdHJ1Y3Rpb24sIHNvIGNhY2hpbmcgaXQgYWNyb3NzIGEgY2FsbCB0byB1c2VyIGNvZGUgaXMgc2FmZS5cbiAgICAgICAgY29uc3QgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuICAgICAgICAvLyBBc3NpZ24gdGhlIF9maW5pc2hQcm9taXNlIG5vdyBzbyB0aGF0IGlmIF9mbHVzaEFsZ29yaXRobSBjYWxscyByZWFkYWJsZS5jYW5jZWwoKSBpbnRlcm5hbGx5LFxuICAgICAgICAvLyB3ZSBkb24ndCBhbHNvIHJ1biB0aGUgX2NhbmNlbEFsZ29yaXRobS5cbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZSA9IG5ld1Byb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmx1c2hQcm9taXNlID0gY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0oKTtcbiAgICAgICAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gICAgICAgIHVwb25Qcm9taXNlKGZsdXNoUHJvbWlzZSwgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlYWRhYmxlLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVqZWN0KGNvbnRyb2xsZXIsIHJlYWRhYmxlLl9zdG9yZWRFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihyZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gICAgfVxuICAgIC8vIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2UgQWxnb3JpdGhtc1xuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xuICAgICAgICAvLyBJbnZhcmlhbnQuIEVuZm9yY2VkIGJ5IHRoZSBwcm9taXNlcyByZXR1cm5lZCBieSBzdGFydCgpIGFuZCBwdWxsKCkuXG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIGZhbHNlKTtcbiAgICAgICAgLy8gUHJldmVudCB0aGUgbmV4dCBwdWxsKCkgY2FsbCB1bnRpbCB0aGVyZSBpcyBiYWNrcHJlc3N1cmUuXG4gICAgICAgIHJldHVybiBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VDYW5jZWxBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyZWFtLl93cml0YWJsZSBjYW5ub3QgY2hhbmdlIGFmdGVyIGNvbnN0cnVjdGlvbiwgc28gY2FjaGluZyBpdCBhY3Jvc3MgYSBjYWxsIHRvIHVzZXIgY29kZSBpcyBzYWZlLlxuICAgICAgICBjb25zdCB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgICAgIC8vIEFzc2lnbiB0aGUgX2ZpbmlzaFByb21pc2Ugbm93IHNvIHRoYXQgaWYgX2ZsdXNoQWxnb3JpdGhtIGNhbGxzIHdyaXRhYmxlLmFib3J0KCkgb3JcbiAgICAgICAgLy8gd3JpdGFibGUuY2FuY2VsKCkgaW50ZXJuYWxseSwgd2UgZG9uJ3QgcnVuIHRoZSBfY2FuY2VsQWxnb3JpdGhtIGFnYWluLCBvciBhbHNvIHJ1biB0aGVcbiAgICAgICAgLy8gX2ZsdXNoQWxnb3JpdGhtLlxuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlID0gbmV3UHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtKHJlYXNvbik7XG4gICAgICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgICAgICB1cG9uUHJvbWlzZShjYW5jZWxQcm9taXNlLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAod3JpdGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QoY29udHJvbGxlciwgd3JpdGFibGUuX3N0b3JlZEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHdyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtVW5ibG9ja1dyaXRlKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdENvbnRyb2xsZXJGaW5pc2hQcm9taXNlUmVzb2x2ZShjb250cm9sbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9LCByID0+IHtcbiAgICAgICAgICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKHdyaXRhYmxlLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIsIHIpO1xuICAgICAgICAgICAgVHJhbnNmb3JtU3RyZWFtVW5ibG9ja1dyaXRlKHN0cmVhbSk7XG4gICAgICAgICAgICBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QoY29udHJvbGxlciwgcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIuXG4gICAgZnVuY3Rpb24gZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoYFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcmApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZXNvbHZlKCk7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29udHJvbGxlci5fZmluaXNoUHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyRmluaXNoUHJvbWlzZVJlamVjdChjb250cm9sbGVyLCByZWFzb24pIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2UpO1xuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3JlamVjdChyZWFzb24pO1xuICAgICAgICBjb250cm9sbGVyLl9maW5pc2hQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnRyb2xsZXIuX2ZpbmlzaFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb25zIGZvciB0aGUgVHJhbnNmb3JtU3RyZWFtLlxuICAgIGZ1bmN0aW9uIHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcihgVHJhbnNmb3JtU3RyZWFtLnByb3RvdHlwZS4ke25hbWV9IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBUcmFuc2Zvcm1TdHJlYW1gKTtcbiAgICB9XG5cbiAgICBleHBvcnRzLkJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3kgPSBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5O1xuICAgIGV4cG9ydHMuQ291bnRRdWV1aW5nU3RyYXRlZ3kgPSBDb3VudFF1ZXVpbmdTdHJhdGVneTtcbiAgICBleHBvcnRzLlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyO1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW0gPSBSZWFkYWJsZVN0cmVhbTtcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciA9IFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbiAgICBleHBvcnRzLlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QgPSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xuICAgIGV4cG9ydHMuUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gICAgZXhwb3J0cy5SZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgPSBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXI7XG4gICAgZXhwb3J0cy5UcmFuc2Zvcm1TdHJlYW0gPSBUcmFuc2Zvcm1TdHJlYW07XG4gICAgZXhwb3J0cy5UcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciA9IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW0gPSBXcml0YWJsZVN0cmVhbTtcbiAgICBleHBvcnRzLldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuICAgIGV4cG9ydHMuV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb255ZmlsbC5lczIwMTguanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsIldlYlN0cmVhbXNQb2x5ZmlsbCIsIlN5bWJvbFBvbHlmaWxsIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJkZXNjcmlwdGlvbiIsIm5vb3AiLCJ1bmRlZmluZWQiLCJ0eXBlSXNPYmplY3QiLCJ4IiwicmV0aHJvd0Fzc2VydGlvbkVycm9yUmVqZWN0aW9uIiwic2V0RnVuY3Rpb25OYW1lIiwiZm4iLCJuYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImNvbmZpZ3VyYWJsZSIsIl9hIiwib3JpZ2luYWxQcm9taXNlIiwiUHJvbWlzZSIsIm9yaWdpbmFsUHJvbWlzZVRoZW4iLCJwcm90b3R5cGUiLCJ0aGVuIiwib3JpZ2luYWxQcm9taXNlUmVqZWN0IiwicmVqZWN0IiwiYmluZCIsIm5ld1Byb21pc2UiLCJleGVjdXRvciIsInByb21pc2VSZXNvbHZlZFdpdGgiLCJyZXNvbHZlIiwicHJvbWlzZVJlamVjdGVkV2l0aCIsInJlYXNvbiIsIlBlcmZvcm1Qcm9taXNlVGhlbiIsInByb21pc2UiLCJvbkZ1bGZpbGxlZCIsIm9uUmVqZWN0ZWQiLCJjYWxsIiwidXBvblByb21pc2UiLCJ1cG9uRnVsZmlsbG1lbnQiLCJ1cG9uUmVqZWN0aW9uIiwidHJhbnNmb3JtUHJvbWlzZVdpdGgiLCJmdWxmaWxsbWVudEhhbmRsZXIiLCJyZWplY3Rpb25IYW5kbGVyIiwic2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSIsIl9xdWV1ZU1pY3JvdGFzayIsImNhbGxiYWNrIiwicXVldWVNaWNyb3Rhc2siLCJyZXNvbHZlZFByb21pc2UiLCJjYiIsInJlZmxlY3RDYWxsIiwiRiIsIlYiLCJhcmdzIiwiVHlwZUVycm9yIiwiRnVuY3Rpb24iLCJhcHBseSIsInByb21pc2VDYWxsIiwiUVVFVUVfTUFYX0FSUkFZX1NJWkUiLCJTaW1wbGVRdWV1ZSIsImNvbnN0cnVjdG9yIiwiX2N1cnNvciIsIl9zaXplIiwiX2Zyb250IiwiX2VsZW1lbnRzIiwiX25leHQiLCJfYmFjayIsImxlbmd0aCIsInB1c2giLCJlbGVtZW50Iiwib2xkQmFjayIsIm5ld0JhY2siLCJzaGlmdCIsIm9sZEZyb250IiwibmV3RnJvbnQiLCJvbGRDdXJzb3IiLCJuZXdDdXJzb3IiLCJlbGVtZW50cyIsImZvckVhY2giLCJpIiwibm9kZSIsInBlZWsiLCJmcm9udCIsImN1cnNvciIsIkFib3J0U3RlcHMiLCJFcnJvclN0ZXBzIiwiQ2FuY2VsU3RlcHMiLCJQdWxsU3RlcHMiLCJSZWxlYXNlU3RlcHMiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplIiwicmVhZGVyIiwic3RyZWFtIiwiX293bmVyUmVhZGFibGVTdHJlYW0iLCJfcmVhZGVyIiwiX3N0YXRlIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplIiwiZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQiLCJfc3RvcmVkRXJyb3IiLCJSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwiLCJSZWFkYWJsZVN0cmVhbUNhbmNlbCIsIlJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY1JlbGVhc2UiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsImRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkIiwiX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciIsInJlYWRlckxvY2tFeGNlcHRpb24iLCJfY2xvc2VkUHJvbWlzZSIsIl9jbG9zZWRQcm9taXNlX3Jlc29sdmUiLCJfY2xvc2VkUHJvbWlzZV9yZWplY3QiLCJkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJOdW1iZXJJc0Zpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiTWF0aFRydW5jIiwiTWF0aCIsInRydW5jIiwidiIsImNlaWwiLCJmbG9vciIsImlzRGljdGlvbmFyeSIsImFzc2VydERpY3Rpb25hcnkiLCJvYmoiLCJjb250ZXh0IiwiYXNzZXJ0RnVuY3Rpb24iLCJpc09iamVjdCIsImFzc2VydE9iamVjdCIsImFzc2VydFJlcXVpcmVkQXJndW1lbnQiLCJwb3NpdGlvbiIsImFzc2VydFJlcXVpcmVkRmllbGQiLCJmaWVsZCIsImNvbnZlcnRVbnJlc3RyaWN0ZWREb3VibGUiLCJjZW5zb3JOZWdhdGl2ZVplcm8iLCJpbnRlZ2VyUGFydCIsImNvbnZlcnRVbnNpZ25lZExvbmdMb25nV2l0aEVuZm9yY2VSYW5nZSIsImxvd2VyQm91bmQiLCJ1cHBlckJvdW5kIiwiTUFYX1NBRkVfSU5URUdFUiIsImFzc2VydFJlYWRhYmxlU3RyZWFtIiwiSXNSZWFkYWJsZVN0cmVhbSIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0IiwicmVhZFJlcXVlc3QiLCJfcmVhZFJlcXVlc3RzIiwiUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3QiLCJjaHVuayIsImRvbmUiLCJfY2xvc2VTdGVwcyIsIl9jaHVua1N0ZXBzIiwiUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMiLCJSZWFkYWJsZVN0cmVhbUhhc0RlZmF1bHRSZWFkZXIiLCJJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciIsIklzUmVhZGFibGVTdHJlYW1Mb2NrZWQiLCJjbG9zZWQiLCJkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsImNhbmNlbCIsInJlYWQiLCJyZXNvbHZlUHJvbWlzZSIsInJlamVjdFByb21pc2UiLCJfZXJyb3JTdGVwcyIsImUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkIiwicmVsZWFzZUxvY2siLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWxlYXNlIiwiZGVmaW5lUHJvcGVydGllcyIsImVudW1lcmFibGUiLCJ0b1N0cmluZ1RhZyIsImhhc093blByb3BlcnR5IiwiX2Rpc3R1cmJlZCIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlckVycm9yUmVhZFJlcXVlc3RzIiwicmVhZFJlcXVlc3RzIiwiQXN5bmNJdGVyYXRvclByb3RvdHlwZSIsImdldFByb3RvdHlwZU9mIiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9ySW1wbCIsInByZXZlbnRDYW5jZWwiLCJfb25nb2luZ1Byb21pc2UiLCJfaXNGaW5pc2hlZCIsIl9wcmV2ZW50Q2FuY2VsIiwibmV4dCIsIm5leHRTdGVwcyIsIl9uZXh0U3RlcHMiLCJyZXR1cm4iLCJyZXR1cm5TdGVwcyIsIl9yZXR1cm5TdGVwcyIsInJlc3VsdCIsIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSIsIklzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yIiwic3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJfYXN5bmNJdGVyYXRvckltcGwiLCJzZXRQcm90b3R5cGVPZiIsIkFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJpbXBsIiwiY3JlYXRlIiwiTnVtYmVySXNOYU4iLCJpc05hTiIsIkNyZWF0ZUFycmF5RnJvbUxpc3QiLCJzbGljZSIsIkNvcHlEYXRhQmxvY2tCeXRlcyIsImRlc3QiLCJkZXN0T2Zmc2V0Iiwic3JjIiwic3JjT2Zmc2V0IiwibiIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJUcmFuc2ZlckFycmF5QnVmZmVyIiwiTyIsInRyYW5zZmVyIiwiYnVmZmVyIiwic3RydWN0dXJlZENsb25lIiwiSXNEZXRhY2hlZEJ1ZmZlciIsImRldGFjaGVkIiwiYnl0ZUxlbmd0aCIsIkFycmF5QnVmZmVyU2xpY2UiLCJiZWdpbiIsImVuZCIsIkFycmF5QnVmZmVyIiwiR2V0TWV0aG9kIiwicmVjZWl2ZXIiLCJwcm9wIiwiZnVuYyIsIlN0cmluZyIsIkNyZWF0ZUFzeW5jRnJvbVN5bmNJdGVyYXRvciIsInN5bmNJdGVyYXRvclJlY29yZCIsInN5bmNJdGVyYWJsZSIsImFzeW5jSXRlcmF0b3IiLCJuZXh0TWV0aG9kIiwiR2V0SXRlcmF0b3IiLCJoaW50IiwibWV0aG9kIiwic3luY01ldGhvZCIsIkl0ZXJhdG9yTmV4dCIsIml0ZXJhdG9yUmVjb3JkIiwiSXRlcmF0b3JDb21wbGV0ZSIsIml0ZXJSZXN1bHQiLCJCb29sZWFuIiwiSXRlcmF0b3JWYWx1ZSIsIklzTm9uTmVnYXRpdmVOdW1iZXIiLCJDbG9uZUFzVWludDhBcnJheSIsImJ5dGVPZmZzZXQiLCJEZXF1ZXVlVmFsdWUiLCJjb250YWluZXIiLCJwYWlyIiwiX3F1ZXVlIiwiX3F1ZXVlVG90YWxTaXplIiwic2l6ZSIsIkVucXVldWVWYWx1ZVdpdGhTaXplIiwiSW5maW5pdHkiLCJSYW5nZUVycm9yIiwiUGVla1F1ZXVlVmFsdWUiLCJSZXNldFF1ZXVlIiwiaXNEYXRhVmlld0NvbnN0cnVjdG9yIiwiY3RvciIsIkRhdGFWaWV3IiwiaXNEYXRhVmlldyIsInZpZXciLCJhcnJheUJ1ZmZlclZpZXdFbGVtZW50U2l6ZSIsIkJZVEVTX1BFUl9FTEVNRU5UIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIklzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsImJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbiIsIl92aWV3IiwicmVzcG9uZCIsImJ5dGVzV3JpdHRlbiIsIl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kIiwicmVzcG9uZFdpdGhOZXdWaWV3IiwiaXNWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3VmlldyIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIiLCJieW9iUmVxdWVzdCIsIklzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciIsImJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXRCWU9CUmVxdWVzdCIsImRlc2lyZWRTaXplIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplIiwiY2xvc2UiLCJfY2xvc2VSZXF1ZXN0ZWQiLCJzdGF0ZSIsIl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlIiwiZW5xdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlIiwiZXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJQZW5kaW5nUHVsbEludG9zIiwiX2NhbmNlbEFsZ29yaXRobSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFJlYWRSZXF1ZXN0RnJvbVF1ZXVlIiwiYXV0b0FsbG9jYXRlQ2h1bmtTaXplIiwiX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZSIsImJ1ZmZlckUiLCJwdWxsSW50b0Rlc2NyaXB0b3IiLCJidWZmZXJCeXRlTGVuZ3RoIiwiYnl0ZXNGaWxsZWQiLCJtaW5pbXVtRmlsbCIsImVsZW1lbnRTaXplIiwidmlld0NvbnN0cnVjdG9yIiwicmVhZGVyVHlwZSIsIl9wZW5kaW5nUHVsbEludG9zIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJmaXJzdFB1bGxJbnRvIiwiY29udHJvbGxlciIsInNob3VsZFB1bGwiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJfcHVsbGluZyIsIl9wdWxsQWdhaW4iLCJwdWxsUHJvbWlzZSIsIl9wdWxsQWxnb3JpdGhtIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckludmFsaWRhdGVCWU9CUmVxdWVzdCIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IiLCJmaWxsZWRWaWV3IiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZSIsIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2xvbmVkQ2h1bmtUb1F1ZXVlIiwiY2xvbmVkQ2h1bmsiLCJjbG9uZUUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZURldGFjaGVkUHVsbEludG9Ub1F1ZXVlIiwiZmlyc3REZXNjcmlwdG9yIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZpbGxQdWxsSW50b0Rlc2NyaXB0b3JGcm9tUXVldWUiLCJtYXhCeXRlc1RvQ29weSIsIm1pbiIsIm1heEJ5dGVzRmlsbGVkIiwidG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyIsInJlYWR5IiwicmVtYWluZGVyQnl0ZXMiLCJtYXhBbGlnbmVkQnl0ZXMiLCJxdWV1ZSIsImhlYWRPZlF1ZXVlIiwiYnl0ZXNUb0NvcHkiLCJkZXN0U3RhcnQiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbiIsIlJlYWRhYmxlU3RyZWFtQ2xvc2UiLCJfYnlvYlJlcXVlc3QiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHJvY2Vzc1B1bGxJbnRvRGVzY3JpcHRvcnNVc2luZ1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NSZWFkUmVxdWVzdHNVc2luZ1F1ZXVlIiwiUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclB1bGxJbnRvIiwicmVhZEludG9SZXF1ZXN0IiwiUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3QiLCJlbXB0eVZpZXciLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluQ2xvc2VkU3RhdGUiLCJSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRJbnRvUmVxdWVzdHMiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZSIsInJlbWFpbmRlclNpemUiLCJSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEludGVybmFsIiwiZGVzY3JpcHRvciIsIl9zdGFydGVkIiwiZmlyc3RQZW5kaW5nUHVsbEludG8iLCJ0cmFuc2ZlcnJlZEJ1ZmZlciIsInRyYW5zZmVycmVkVmlldyIsIlJlYWRhYmxlU3RyZWFtRXJyb3IiLCJlbnRyeSIsIlNldFVwUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCIsIl9zdHJhdGVneUhXTSIsInZpZXdCeXRlTGVuZ3RoIiwiU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyIiwic3RhcnRBbGdvcml0aG0iLCJwdWxsQWxnb3JpdGhtIiwiY2FuY2VsQWxnb3JpdGhtIiwiaGlnaFdhdGVyTWFyayIsInN0YXJ0UmVzdWx0IiwiciIsIlNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlIiwidW5kZXJseWluZ0J5dGVTb3VyY2UiLCJzdGFydCIsInB1bGwiLCJyZXF1ZXN0IiwiY29udmVydFJlYWRlck9wdGlvbnMiLCJvcHRpb25zIiwibW9kZSIsImNvbnZlcnRSZWFkYWJsZVN0cmVhbVJlYWRlck1vZGUiLCJjb252ZXJ0QnlvYlJlYWRPcHRpb25zIiwiQWNxdWlyZVJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlciIsIl9yZWFkSW50b1JlcXVlc3RzIiwiSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIiLCJieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsInJhd09wdGlvbnMiLCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkIiwiUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyUmVsZWFzZSIsIlJlYWRhYmxlU3RyZWFtQllPQlJlYWRlckVycm9yUmVhZEludG9SZXF1ZXN0cyIsInJlYWRJbnRvUmVxdWVzdHMiLCJFeHRyYWN0SGlnaFdhdGVyTWFyayIsInN0cmF0ZWd5IiwiZGVmYXVsdEhXTSIsIkV4dHJhY3RTaXplQWxnb3JpdGhtIiwiY29udmVydFF1ZXVpbmdTdHJhdGVneSIsImluaXQiLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5U2l6ZSIsImNvbnZlcnRVbmRlcmx5aW5nU2luayIsIm9yaWdpbmFsIiwiYWJvcnQiLCJ0eXBlIiwid3JpdGUiLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtBYm9ydENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTaW5rQ2xvc2VDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU2lua1N0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VW5kZXJseWluZ1NpbmtXcml0ZUNhbGxiYWNrIiwiYXNzZXJ0V3JpdGFibGVTdHJlYW0iLCJJc1dyaXRhYmxlU3RyZWFtIiwiaXNBYm9ydFNpZ25hbCIsImFib3J0ZWQiLCJzdXBwb3J0c0Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsImNyZWF0ZUFib3J0Q29udHJvbGxlciIsIldyaXRhYmxlU3RyZWFtIiwicmF3VW5kZXJseWluZ1NpbmsiLCJyYXdTdHJhdGVneSIsInVuZGVybHlpbmdTaW5rIiwiSW5pdGlhbGl6ZVdyaXRhYmxlU3RyZWFtIiwic2l6ZUFsZ29yaXRobSIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayIsImxvY2tlZCIsInN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMiIsIklzV3JpdGFibGVTdHJlYW1Mb2NrZWQiLCJXcml0YWJsZVN0cmVhbUFib3J0IiwiV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQiLCJXcml0YWJsZVN0cmVhbUNsb3NlIiwiZ2V0V3JpdGVyIiwiQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciIsIkNyZWF0ZVdyaXRhYmxlU3RyZWFtIiwid3JpdGVBbGdvcml0aG0iLCJjbG9zZUFsZ29yaXRobSIsImFib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIlNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIl93cml0ZXIiLCJfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyIiwiX3dyaXRlUmVxdWVzdHMiLCJfaW5GbGlnaHRXcml0ZVJlcXVlc3QiLCJfY2xvc2VSZXF1ZXN0IiwiX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0IiwiX3BlbmRpbmdBYm9ydFJlcXVlc3QiLCJfYmFja3ByZXNzdXJlIiwiX2Fib3J0UmVhc29uIiwiX2Fib3J0Q29udHJvbGxlciIsIl9wcm9taXNlIiwid2FzQWxyZWFkeUVycm9yaW5nIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX3JlYXNvbiIsIl93YXNBbHJlYWR5RXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3JpbmciLCJjbG9zZVJlcXVlc3QiLCJ3cml0ZXIiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0Iiwid3JpdGVSZXF1ZXN0IiwiV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbiIsIldyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3JpbmciLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVSZWFkeVByb21pc2VSZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtSGFzT3BlcmF0aW9uTWFya2VkSW5GbGlnaHQiLCJzdG9yZWRFcnJvciIsIldyaXRhYmxlU3RyZWFtUmVqZWN0Q2xvc2VBbmRDbG9zZWRQcm9taXNlSWZOZWVkZWQiLCJhYm9ydFJlcXVlc3QiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0V3JpdGVXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2UiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUiLCJXcml0YWJsZVN0cmVhbUZpbmlzaEluRmxpZ2h0Q2xvc2VXaXRoRXJyb3IiLCJXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodCIsIldyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCIsIldyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlIiwiYmFja3ByZXNzdXJlIiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0IiwiX293bmVyV3JpdGFibGVTdHJlYW0iLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSIsImRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZWplY3RlZCIsImRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQiLCJkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIiLCJkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbiIsImRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUiLCJfcmVhZHlQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJDbG9zZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJFbnN1cmVDbG9zZWRQcm9taXNlUmVqZWN0ZWQiLCJfY2xvc2VkUHJvbWlzZVN0YXRlIiwiZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNldFRvUmVqZWN0ZWQiLCJfcmVhZHlQcm9taXNlU3RhdGUiLCJkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVqZWN0IiwiZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSIsInJlbGVhc2VkRXJyb3IiLCJjaHVua1NpemUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlIiwiY2xvc2VTZW50aW5lbCIsImFib3J0UmVhc29uIiwiSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDIiLCJzaWduYWwiLCJfY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yIiwiX2Fib3J0QWxnb3JpdGhtIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyIsIl9zdHJhdGVneVNpemVBbGdvcml0aG0iLCJfd3JpdGVBbGdvcml0aG0iLCJfY2xvc2VBbGdvcml0aG0iLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlIiwic3RhcnRQcm9taXNlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkIiwiY2h1bmtTaXplRSIsIldyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkIiwiZW5xdWV1ZUUiLCJXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc0Nsb3NlIiwiV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NXcml0ZSIsInNpbmtDbG9zZVByb21pc2UiLCJzaW5rV3JpdGVQcm9taXNlIiwiX3JlYWR5UHJvbWlzZV9yZXNvbHZlIiwiX3JlYWR5UHJvbWlzZV9yZWplY3QiLCJnZXRHbG9iYWxzIiwiZ2xvYmFscyIsImlzRE9NRXhjZXB0aW9uQ29uc3RydWN0b3IiLCJnZXRGcm9tR2xvYmFsIiwiRE9NRXhjZXB0aW9uIiwiY3JlYXRlUG9seWZpbGwiLCJtZXNzYWdlIiwiRXJyb3IiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIndyaXRhYmxlIiwiUmVhZGFibGVTdHJlYW1QaXBlVG8iLCJzb3VyY2UiLCJwcmV2ZW50Q2xvc2UiLCJwcmV2ZW50QWJvcnQiLCJzaHV0dGluZ0Rvd24iLCJjdXJyZW50V3JpdGUiLCJhY3Rpb25zIiwic2h1dGRvd25XaXRoQWN0aW9uIiwiYWxsIiwibWFwIiwiYWN0aW9uIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBpcGVMb29wIiwicmVzb2x2ZUxvb3AiLCJyZWplY3RMb29wIiwicGlwZVN0ZXAiLCJyZXNvbHZlUmVhZCIsInJlamVjdFJlYWQiLCJpc09yQmVjb21lc0Vycm9yZWQiLCJzaHV0ZG93biIsImlzT3JCZWNvbWVzQ2xvc2VkIiwiZGVzdENsb3NlZCIsIndhaXRGb3JXcml0ZXNUb0ZpbmlzaCIsIm9sZEN1cnJlbnRXcml0ZSIsIm9yaWdpbmFsSXNFcnJvciIsIm9yaWdpbmFsRXJyb3IiLCJkb1RoZVJlc3QiLCJmaW5hbGl6ZSIsIm5ld0Vycm9yIiwiaXNFcnJvciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uJDEiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvciIsIlJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtIiwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyU2hvdWxkQ2FsbFB1bGwiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlIiwiU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyIiwiU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UiLCJ1bmRlcmx5aW5nU291cmNlIiwiUmVhZGFibGVTdHJlYW1UZWUiLCJjbG9uZUZvckJyYW5jaDIiLCJSZWFkYWJsZUJ5dGVTdHJlYW1UZWUiLCJSZWFkYWJsZVN0cmVhbURlZmF1bHRUZWUiLCJyZWFkaW5nIiwicmVhZEFnYWluIiwiY2FuY2VsZWQxIiwiY2FuY2VsZWQyIiwicmVhc29uMSIsInJlYXNvbjIiLCJicmFuY2gxIiwiYnJhbmNoMiIsInJlc29sdmVDYW5jZWxQcm9taXNlIiwiY2FuY2VsUHJvbWlzZSIsImNodW5rMSIsImNodW5rMiIsImNhbmNlbDFBbGdvcml0aG0iLCJjb21wb3NpdGVSZWFzb24iLCJjYW5jZWxSZXN1bHQiLCJjYW5jZWwyQWxnb3JpdGhtIiwiQ3JlYXRlUmVhZGFibGVTdHJlYW0iLCJyZWFkQWdhaW5Gb3JCcmFuY2gxIiwicmVhZEFnYWluRm9yQnJhbmNoMiIsImZvcndhcmRSZWFkZXJFcnJvciIsInRoaXNSZWFkZXIiLCJwdWxsV2l0aERlZmF1bHRSZWFkZXIiLCJwdWxsMUFsZ29yaXRobSIsInB1bGwyQWxnb3JpdGhtIiwicHVsbFdpdGhCWU9CUmVhZGVyIiwiZm9yQnJhbmNoMiIsImJ5b2JCcmFuY2giLCJvdGhlckJyYW5jaCIsImJ5b2JDYW5jZWxlZCIsIm90aGVyQ2FuY2VsZWQiLCJDcmVhdGVSZWFkYWJsZUJ5dGVTdHJlYW0iLCJpc1JlYWRhYmxlU3RyZWFtTGlrZSIsImdldFJlYWRlciIsIlJlYWRhYmxlU3RyZWFtRnJvbSIsIlJlYWRhYmxlU3RyZWFtRnJvbURlZmF1bHRSZWFkZXIiLCJSZWFkYWJsZVN0cmVhbUZyb21JdGVyYWJsZSIsImFzeW5jSXRlcmFibGUiLCJuZXh0UmVzdWx0IiwibmV4dFByb21pc2UiLCJyZXR1cm5NZXRob2QiLCJyZXR1cm5SZXN1bHQiLCJyZXR1cm5Qcm9taXNlIiwicmVhZFByb21pc2UiLCJyZWFkUmVzdWx0IiwiY29udmVydFVuZGVybHlpbmdEZWZhdWx0T3JCeXRlU291cmNlIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VDYW5jZWxDYWxsYmFjayIsImNvbnZlcnRVbmRlcmx5aW5nU291cmNlUHVsbENhbGxiYWNrIiwiY29udmVydFVuZGVybHlpbmdTb3VyY2VTdGFydENhbGxiYWNrIiwiY29udmVydFJlYWRhYmxlU3RyZWFtVHlwZSIsImNvbnZlcnRJdGVyYXRvck9wdGlvbnMiLCJjb252ZXJ0UGlwZU9wdGlvbnMiLCJhc3NlcnRBYm9ydFNpZ25hbCIsImNvbnZlcnRSZWFkYWJsZVdyaXRhYmxlUGFpciIsInJlYWRhYmxlIiwiUmVhZGFibGVTdHJlYW0iLCJyYXdVbmRlcmx5aW5nU291cmNlIiwiSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtIiwic3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxIiwicGlwZVRocm91Z2giLCJyYXdUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJwaXBlVG8iLCJkZXN0aW5hdGlvbiIsInRlZSIsImJyYW5jaGVzIiwidmFsdWVzIiwiZnJvbSIsInNvdXJjZUNhbmNlbFByb21pc2UiLCJjb252ZXJ0UXVldWluZ1N0cmF0ZWd5SW5pdCIsImJ5dGVMZW5ndGhTaXplRnVuY3Rpb24iLCJCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwiX2J5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3lIaWdoV2F0ZXJNYXJrIiwiSXNCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5IiwiYnl0ZUxlbmd0aEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjb3VudFNpemVGdW5jdGlvbiIsIkNvdW50UXVldWluZ1N0cmF0ZWd5IiwiX2NvdW50UXVldWluZ1N0cmF0ZWd5SGlnaFdhdGVyTWFyayIsIklzQ291bnRRdWV1aW5nU3RyYXRlZ3kiLCJjb3VudEJyYW5kQ2hlY2tFeGNlcHRpb24iLCJjb252ZXJ0VHJhbnNmb3JtZXIiLCJmbHVzaCIsInJlYWRhYmxlVHlwZSIsIndyaXRhYmxlVHlwZSIsImNvbnZlcnRUcmFuc2Zvcm1lckNhbmNlbENhbGxiYWNrIiwiY29udmVydFRyYW5zZm9ybWVyRmx1c2hDYWxsYmFjayIsImNvbnZlcnRUcmFuc2Zvcm1lclN0YXJ0Q2FsbGJhY2siLCJjb252ZXJ0VHJhbnNmb3JtZXJUcmFuc2Zvcm1DYWxsYmFjayIsIlRyYW5zZm9ybVN0cmVhbSIsInJhd1RyYW5zZm9ybWVyIiwicmF3V3JpdGFibGVTdHJhdGVneSIsInJhd1JlYWRhYmxlU3RyYXRlZ3kiLCJ3cml0YWJsZVN0cmF0ZWd5IiwicmVhZGFibGVTdHJhdGVneSIsInRyYW5zZm9ybWVyIiwicmVhZGFibGVIaWdoV2F0ZXJNYXJrIiwicmVhZGFibGVTaXplQWxnb3JpdGhtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwid3JpdGFibGVTaXplQWxnb3JpdGhtIiwic3RhcnRQcm9taXNlX3Jlc29sdmUiLCJJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtIiwiU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lciIsIl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyIiwiSXNUcmFuc2Zvcm1TdHJlYW0iLCJzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uIiwiX3JlYWRhYmxlIiwiX3dyaXRhYmxlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0iLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U291cmNlQ2FuY2VsQWxnb3JpdGhtIiwiX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UiLCJfYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZV9yZXNvbHZlIiwiVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlIiwiVHJhbnNmb3JtU3RyZWFtRXJyb3IiLCJUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMiLCJUcmFuc2Zvcm1TdHJlYW1VbmJsb2NrV3JpdGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlciIsIklzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24iLCJyZWFkYWJsZUNvbnRyb2xsZXIiLCJfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZSIsIlRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IiLCJ0ZXJtaW5hdGUiLCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclRlcm1pbmF0ZSIsIlNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIiLCJ0cmFuc2Zvcm1BbGdvcml0aG0iLCJmbHVzaEFsZ29yaXRobSIsIl90cmFuc2Zvcm1BbGdvcml0aG0iLCJfZmx1c2hBbGdvcml0aG0iLCJfZmluaXNoUHJvbWlzZSIsIl9maW5pc2hQcm9taXNlX3Jlc29sdmUiLCJfZmluaXNoUHJvbWlzZV9yZWplY3QiLCJ0cmFuc2Zvcm1SZXN1bHRFIiwiVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQZXJmb3JtVHJhbnNmb3JtIiwidHJhbnNmb3JtUHJvbWlzZSIsImJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UiLCJkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZWplY3QiLCJkZWZhdWx0Q29udHJvbGxlckZpbmlzaFByb21pc2VSZXNvbHZlIiwiZmx1c2hQcm9taXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/web-streams-polyfill/dist/ponyfill.es2018.js\n");

/***/ })

};
;