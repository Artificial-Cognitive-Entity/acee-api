"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/popmotion";
exports.ids = ["vendor-chunks/popmotion"];
exports.modules = {

/***/ "(ssr)/./node_modules/popmotion/dist/popmotion.cjs.js":
/*!******************************************************!*\
  !*** ./node_modules/popmotion/dist/popmotion.cjs.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar tslib = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\nvar heyListen = __webpack_require__(/*! hey-listen */ \"(ssr)/./node_modules/hey-listen/dist/hey-listen.es.js\");\nvar styleValueTypes = __webpack_require__(/*! style-value-types */ \"(ssr)/./node_modules/style-value-types/dist/valueTypes.cjs.js\");\nvar sync = __webpack_require__(/*! framesync */ \"(ssr)/./node_modules/framesync/dist/framesync.cjs.js\");\nfunction _interopDefaultLegacy(e) {\n    return e && typeof e === \"object\" && \"default\" in e ? e : {\n        \"default\": e\n    };\n}\nvar sync__default = /*#__PURE__*/ _interopDefaultLegacy(sync);\nconst clamp = (min, max, v)=>Math.min(Math.max(v, min), max);\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {\n    let envelope;\n    let derivative;\n    heyListen.warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = (undampedFreq)=>{\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - a / b * c;\n        };\n        derivative = (undampedFreq)=>{\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return factor * ((d - e) * f) / g;\n        };\n    } else {\n        envelope = (undampedFreq)=>{\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq)=>{\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration\n        };\n    } else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for(let i = 1; i < rootIterations; i++){\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\nconst durationKeys = [\n    \"duration\",\n    \"bounce\"\n];\nconst physicsKeys = [\n    \"stiffness\",\n    \"damping\",\n    \"mass\"\n];\nfunction isSpringType(options, keys) {\n    return keys.some((key)=>options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false\n    }, options);\n    if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {\n            velocity: 0.0,\n            mass: 1.0\n        });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = tslib.__rest(_a, [\n        \"from\",\n        \"to\",\n        \"restSpeed\",\n        \"restDelta\"\n    ]);\n    const state = {\n        done: false,\n        value: from\n    };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t)=>{\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n            };\n            resolveVelocity = (t)=>{\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n            };\n        } else if (dampingRatio === 1) {\n            resolveSpring = (t)=>to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n        } else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t)=>{\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t)=>{\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            } else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: ()=>{\n            velocity = -velocity;\n            [from, to] = [\n                to,\n                from\n            ];\n            createSpring();\n        }\n    };\n}\nspring.needsInterpolation = (a, b)=>typeof a === \"string\" || typeof b === \"string\";\nconst zero = (_t)=>0;\nconst progress = (from, to, value)=>{\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\nconst mix = (from, to, progress)=>-progress * from + progress * to + from;\nfunction hueToRgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    } else {\n        const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha\n    };\n}\nconst mixLinearColor = (from, to, v)=>{\n    const fromExpo = from * from;\n    const toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nconst colorTypes = [\n    styleValueTypes.hex,\n    styleValueTypes.rgba,\n    styleValueTypes.hsla\n];\nconst getColorType = (v)=>colorTypes.find((type)=>type.test(v));\nconst notAnimatable = (color)=>`'${color}' is not an animatable color. Use the equivalent color code instead.`;\nconst mixColor = (from, to)=>{\n    let fromColorType = getColorType(from);\n    let toColorType = getColorType(to);\n    heyListen.invariant(!!fromColorType, notAnimatable(from));\n    heyListen.invariant(!!toColorType, notAnimatable(to));\n    let fromColor = fromColorType.parse(from);\n    let toColor = toColorType.parse(to);\n    if (fromColorType === styleValueTypes.hsla) {\n        fromColor = hslaToRgba(fromColor);\n        fromColorType = styleValueTypes.rgba;\n    }\n    if (toColorType === styleValueTypes.hsla) {\n        toColor = hslaToRgba(toColor);\n        toColorType = styleValueTypes.rgba;\n    }\n    const blended = Object.assign({}, fromColor);\n    return (v)=>{\n        for(const key in blended){\n            if (key !== \"alpha\") {\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\nconst zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nconst isNum = (v)=>typeof v === \"number\";\nconst combineFunctions = (a, b)=>(v)=>b(a(v));\nconst pipe = (...transformers)=>transformers.reduce(combineFunctions);\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v)=>mix(origin, target, v);\n    } else if (styleValueTypes.color.test(origin)) {\n        return mixColor(origin, target);\n    } else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to)=>{\n    const output = [\n        ...from\n    ];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i)=>getMixer(fromThis, to[i]));\n    return (v)=>{\n        for(let i = 0; i < numValues; i++){\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target)=>{\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for(const key in output){\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v)=>{\n        for(const key in blendValue){\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    const parsed = styleValueTypes.complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for(let i = 0; i < numValues; i++){\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        } else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            } else {\n                numRGB++;\n            }\n        }\n    }\n    return {\n        parsed,\n        numNumbers,\n        numRGB,\n        numHSL\n    };\n}\nconst mixComplex = (origin, target)=>{\n    const template = styleValueTypes.complex.createTransformer(target);\n    const originStats = analyse(origin);\n    const targetStats = analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    } else {\n        heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p)=>`${p > 0 ? target : origin}`;\n    }\n};\nconst mixNumber = (from, to)=>(p)=>mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \"number\") {\n        return mixNumber;\n    } else if (typeof v === \"string\") {\n        if (styleValueTypes.color.test(v)) {\n            return mixColor;\n        } else {\n            return mixComplex;\n        }\n    } else if (Array.isArray(v)) {\n        return mixArray;\n    } else if (typeof v === \"object\") {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for(let i = 0; i < numMixers; i++){\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n    return (v)=>mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n    const inputLength = input.length;\n    const lastInputIndex = inputLength - 1;\n    return (v)=>{\n        let mixerIndex = 0;\n        let foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        } else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            let i = 1;\n            for(; i < inputLength; i++){\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    heyListen.invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n    heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\");\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n    return isClamp ? (v)=>interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\nconst reverseEasing = (easing)=>(p)=>1 - easing(1 - p);\nconst mirrorEasing = (easing)=>(p)=>p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\nconst createExpoIn = (power)=>(p)=>Math.pow(p, power);\nconst createBackIn = (power)=>(p)=>p * p * ((power + 1) * p - power);\nconst createAnticipate = (power)=>{\n    const backEasing = createBackIn(power);\n    return (p)=>(p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nconst linear = (p)=>p;\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\nconst circIn = (p)=>1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\nconst bounceOut = (p)=>{\n    if (p === 1 || p === 0) return p;\n    const p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\nconst bounceIn = reverseEasing(bounceOut);\nconst bounceInOut = (p)=>p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\nfunction defaultEasing(values, easing) {\n    return values.map(()=>easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    const numValues = values.length;\n    return values.map((_value, i)=>i !== 0 ? i / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o)=>o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300 }) {\n    const state = {\n        done: false,\n        value: from\n    };\n    const values = Array.isArray(to) ? to : [\n        from,\n        to\n    ];\n    const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t)=>{\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: ()=>{\n            values.reverse();\n            interpolator = createInterpolator();\n        }\n    };\n}\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {\n    const state = {\n        done: false,\n        value: from\n    };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal) amplitude = target - from;\n    return {\n        next: (t)=>{\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: ()=>{}\n    };\n}\nconst types = {\n    keyframes,\n    spring,\n    decay\n};\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    } else if (types[config.type]) {\n        return types[config.type];\n    }\n    const keys = new Set(Object.keys(config));\n    if (keys.has(\"ease\") || keys.has(\"duration\") && !keys.has(\"dampingRatio\")) {\n        return keyframes;\n    } else if (keys.has(\"dampingRatio\") || keys.has(\"stiffness\") || keys.has(\"mass\") || keys.has(\"damping\") || keys.has(\"restSpeed\") || keys.has(\"restDelta\")) {\n        return spring;\n    }\n    return keyframes;\n}\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\nconst framesync = (update)=>{\n    const passTimestamp = ({ delta })=>update(delta);\n    return {\n        start: ()=>sync__default[\"default\"].update(passTimestamp, true),\n        stop: ()=>sync.cancelSync.update(passTimestamp)\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = \"loop\", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = tslib.__rest(_a, [\n        \"from\",\n        \"autoplay\",\n        \"driver\",\n        \"elapsed\",\n        \"repeat\",\n        \"repeatType\",\n        \"repeatDelay\",\n        \"onPlay\",\n        \"onStop\",\n        \"onComplete\",\n        \"onRepeat\",\n        \"onUpdate\"\n    ]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([\n            0,\n            100\n        ], [\n            from,\n            to\n        ], {\n            clamp: false\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), {\n        from,\n        to\n    }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        } else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\") animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback) delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            } else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: ()=>{\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        }\n    };\n}\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return min !== undefined && v < min || max !== undefined && v > max;\n    }\n    function boundaryNearest(v) {\n        if (min === undefined) return max;\n        if (max === undefined) return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), {\n            driver,\n            onUpdate: (v)=>{\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            },\n            onComplete,\n            onStop\n        }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({\n            type: \"spring\",\n            stiffness: bounceStiffness,\n            damping: bounceDamping,\n            restDelta\n        }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({\n            from,\n            velocity,\n            to: boundaryNearest(from)\n        });\n    } else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\") target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v)=>{\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\n            if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n                startSpring({\n                    from: v,\n                    to: boundary,\n                    velocity\n                });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined\n        });\n    }\n    return {\n        stop: ()=>currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n    };\n}\nconst radiansToDegrees = (radians)=>radians * 180 / Math.PI;\nconst angle = (a, b = zeroPoint)=>radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\nconst applyOffset = (from, to)=>{\n    let hasReceivedFrom = true;\n    if (to === undefined) {\n        to = from;\n        hasReceivedFrom = false;\n    }\n    return (v)=>{\n        if (hasReceivedFrom) {\n            return v - from + to;\n        } else {\n            from = v;\n            hasReceivedFrom = true;\n            return to;\n        }\n    };\n};\nconst identity = (v)=>v;\nconst createAttractor = (alterDisplacement = identity)=>(constant, origin, v)=>{\n        const displacement = origin - v;\n        const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n        return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n    };\nconst attract = createAttractor();\nconst attractExpo = createAttractor(Math.sqrt);\nconst degreesToRadians = (degrees)=>degrees * Math.PI / 180;\nconst isPoint = (point)=>point.hasOwnProperty(\"x\") && point.hasOwnProperty(\"y\");\nconst isPoint3D = (point)=>isPoint(point) && point.hasOwnProperty(\"z\");\nconst distance1D = (a, b)=>Math.abs(a - b);\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    } else if (isPoint(a) && isPoint(b)) {\n        const xDelta = distance1D(a.x, b.x);\n        const yDelta = distance1D(a.y, b.y);\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\nconst pointFromVector = (origin, angle, distance)=>{\n    angle = degreesToRadians(angle);\n    return {\n        x: distance * Math.cos(angle) + origin.x,\n        y: distance * Math.sin(angle) + origin.y\n    };\n};\nconst toDecimal = (num, precision = 2)=>{\n    precision = Math.pow(10, precision);\n    return Math.round(num * precision) / precision;\n};\nconst smoothFrame = (prevValue, nextValue, duration, smoothing = 0)=>toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));\nconst smooth = (strength = 50)=>{\n    let previousValue = 0;\n    let lastUpdated = 0;\n    return (v)=>{\n        const currentFramestamp = sync.getFrameData().timestamp;\n        const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n        const newValue = timeDelta ? smoothFrame(previousValue, v, timeDelta, strength) : previousValue;\n        lastUpdated = currentFramestamp;\n        previousValue = newValue;\n        return newValue;\n    };\n};\nconst snap = (points)=>{\n    if (typeof points === \"number\") {\n        return (v)=>Math.round(v / points) * points;\n    } else {\n        let i = 0;\n        const numPoints = points.length;\n        return (v)=>{\n            let lastDistance = Math.abs(points[0] - v);\n            for(i = 1; i < numPoints; i++){\n                const point = points[i];\n                const distance = Math.abs(point - v);\n                if (distance === 0) return point;\n                if (distance > lastDistance) return points[i - 1];\n                if (i === numPoints - 1) return point;\n                lastDistance = distance;\n            }\n        };\n    }\n};\nfunction velocityPerFrame(xps, frameDuration) {\n    return xps / (1000 / frameDuration);\n}\nconst wrap = (min, max, v)=>{\n    const rangeSize = max - min;\n    return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\nconst a = (a1, a2)=>1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2)=>3.0 * a2 - 6.0 * a1;\nconst c = (a1)=>3.0 * a1;\nconst calcBezier = (t, a1, a2)=>((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2)=>3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        } else {\n            aA = currentT;\n        }\n    }while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for(let i = 0; i < newtonIterations; ++i){\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2) return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for(let i = 0; i < kSplineTableSize; ++i){\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for(; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample){\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        } else if (initialSlope === 0.0) {\n            return guessForT;\n        } else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t)=>t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\nconst steps = (steps, direction = \"end\")=>(progress)=>{\n        progress = direction === \"end\" ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n        const expanded = progress * steps;\n        const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n        return clamp(0, 1, rounded / steps);\n    };\nexports.angle = angle;\nexports.animate = animate;\nexports.anticipate = anticipate;\nexports.applyOffset = applyOffset;\nexports.attract = attract;\nexports.attractExpo = attractExpo;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.bounceIn = bounceIn;\nexports.bounceInOut = bounceInOut;\nexports.bounceOut = bounceOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.createAnticipate = createAnticipate;\nexports.createAttractor = createAttractor;\nexports.createBackIn = createBackIn;\nexports.createExpoIn = createExpoIn;\nexports.cubicBezier = cubicBezier;\nexports.decay = decay;\nexports.degreesToRadians = degreesToRadians;\nexports.distance = distance;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isPoint = isPoint;\nexports.isPoint3D = isPoint3D;\nexports.keyframes = keyframes;\nexports.linear = linear;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixColor = mixColor;\nexports.mixComplex = mixComplex;\nexports.pipe = pipe;\nexports.pointFromVector = pointFromVector;\nexports.progress = progress;\nexports.radiansToDegrees = radiansToDegrees;\nexports.reverseEasing = reverseEasing;\nexports.smooth = smooth;\nexports.smoothFrame = smoothFrame;\nexports.snap = snap;\nexports.spring = spring;\nexports.steps = steps;\nexports.toDecimal = toDecimal;\nexports.velocityPerFrame = velocityPerFrame;\nexports.velocityPerSecond = velocityPerSecond;\nexports.wrap = wrap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvcG9wbW90aW9uLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxRQUFRQyxtQkFBT0EsQ0FBQztBQUNwQixJQUFJQyxZQUFZRCxtQkFBT0EsQ0FBQztBQUN4QixJQUFJRSxrQkFBa0JGLG1CQUFPQSxDQUFDO0FBQzlCLElBQUlHLE9BQU9ILG1CQUFPQSxDQUFDO0FBRW5CLFNBQVNJLHNCQUF1QkMsQ0FBQztJQUFJLE9BQU9BLEtBQUssT0FBT0EsTUFBTSxZQUFZLGFBQWFBLElBQUlBLElBQUk7UUFBRSxXQUFXQTtJQUFFO0FBQUc7QUFFakgsSUFBSUMsZ0JBQWdCLFdBQVcsR0FBRUYsc0JBQXNCRDtBQUV2RCxNQUFNSSxRQUFRLENBQUNDLEtBQUtDLEtBQUtDLElBQU1DLEtBQUtILEdBQUcsQ0FBQ0csS0FBS0YsR0FBRyxDQUFDQyxHQUFHRixNQUFNQztBQUUxRCxNQUFNRyxVQUFVO0FBQ2hCLE1BQU1DLGNBQWM7QUFDcEIsTUFBTUMsY0FBYztBQUNwQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLGFBQWE7QUFDbkIsU0FBU0MsV0FBVyxFQUFFQyxXQUFXLEdBQUcsRUFBRUMsU0FBUyxJQUFJLEVBQUVDLFdBQVcsQ0FBQyxFQUFFQyxPQUFPLENBQUMsRUFBRztJQUMxRSxJQUFJQztJQUNKLElBQUlDO0lBQ0p0QixVQUFVdUIsT0FBTyxDQUFDTixZQUFZSixjQUFjLE1BQU07SUFDbEQsSUFBSVcsZUFBZSxJQUFJTjtJQUN2Qk0sZUFBZWxCLE1BQU1RLFlBQVlDLFlBQVlTO0lBQzdDUCxXQUFXWCxNQUFNTSxhQUFhQyxhQUFhSSxXQUFXO0lBQ3RELElBQUlPLGVBQWUsR0FBRztRQUNsQkgsV0FBVyxDQUFDSTtZQUNSLE1BQU1DLG1CQUFtQkQsZUFBZUQ7WUFDeEMsTUFBTUcsUUFBUUQsbUJBQW1CVDtZQUNqQyxNQUFN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O0FBQzNCdlQsZ0JBQWdCLEdBQUc4VDtBQUNuQjlULGNBQWMsR0FBRzZNO0FBQ2pCN00saUJBQWlCLEdBQUcrTTtBQUNwQi9NLGVBQWUsR0FBRzhNO0FBQ2xCOU0sZUFBZSxHQUFHMlI7QUFDbEIzUixtQkFBbUIsR0FBRzJMO0FBQ3RCM0wsZUFBZSxHQUFHeVQ7QUFDbEJ6VCxpQkFBaUIsR0FBRzRUO0FBQ3BCNVQsaUJBQWlCLEdBQUd1TztBQUNwQnZPLGNBQWMsR0FBRzRNO0FBQ2pCNU0sb0JBQW9CLEdBQUdrTTtBQUN2QmxNLFdBQVcsR0FBR21HO0FBQ2RuRyxnQkFBZ0IsR0FBRzZIO0FBQ25CN0gsa0JBQWtCLEdBQUdrSjtBQUNyQmxKLFlBQVksR0FBRzRJO0FBQ2Y1SSx1QkFBdUIsR0FBR2tVO0FBQzFCbFUsZ0JBQWdCLEdBQUdpRztBQUNuQmpHLHdCQUF3QixHQUFHd1M7QUFDM0J4UyxxQkFBcUIsR0FBR2dNO0FBQ3hCaE0sY0FBYyxHQUFHMFU7QUFDakIxVSxtQkFBbUIsR0FBR3NVO0FBQ3RCdFUsWUFBWSxHQUFHa1Y7QUFDZmxWLGNBQWMsR0FBR2dFO0FBQ2pCaEUsYUFBYSxHQUFHMlg7QUFDaEIzWCxpQkFBaUIsR0FBR21VO0FBQ3BCblUsd0JBQXdCLEdBQUdzVjtBQUMzQnRWLHlCQUF5QixHQUFHeVI7QUFDNUJ6UixZQUFZLEdBQUd3ViIsInNvdXJjZXMiOlsid2VicGFjazovL2FjZWUtcHJvdG8tb25lLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L3BvcG1vdGlvbi5janMuanM/NmM3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG52YXIgaGV5TGlzdGVuID0gcmVxdWlyZSgnaGV5LWxpc3RlbicpO1xudmFyIHN0eWxlVmFsdWVUeXBlcyA9IHJlcXVpcmUoJ3N0eWxlLXZhbHVlLXR5cGVzJyk7XG52YXIgc3luYyA9IHJlcXVpcmUoJ2ZyYW1lc3luYycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIHN5bmNfX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BEZWZhdWx0TGVnYWN5KHN5bmMpO1xuXG5jb25zdCBjbGFtcCA9IChtaW4sIG1heCwgdikgPT4gTWF0aC5taW4oTWF0aC5tYXgodiwgbWluKSwgbWF4KTtcblxuY29uc3Qgc2FmZU1pbiA9IDAuMDAxO1xuY29uc3QgbWluRHVyYXRpb24gPSAwLjAxO1xuY29uc3QgbWF4RHVyYXRpb24gPSAxMC4wO1xuY29uc3QgbWluRGFtcGluZyA9IDAuMDU7XG5jb25zdCBtYXhEYW1waW5nID0gMTtcbmZ1bmN0aW9uIGZpbmRTcHJpbmcoeyBkdXJhdGlvbiA9IDgwMCwgYm91bmNlID0gMC4yNSwgdmVsb2NpdHkgPSAwLCBtYXNzID0gMSwgfSkge1xuICAgIGxldCBlbnZlbG9wZTtcbiAgICBsZXQgZGVyaXZhdGl2ZTtcbiAgICBoZXlMaXN0ZW4ud2FybmluZyhkdXJhdGlvbiA8PSBtYXhEdXJhdGlvbiAqIDEwMDAsIFwiU3ByaW5nIGR1cmF0aW9uIG11c3QgYmUgMTAgc2Vjb25kcyBvciBsZXNzXCIpO1xuICAgIGxldCBkYW1waW5nUmF0aW8gPSAxIC0gYm91bmNlO1xuICAgIGRhbXBpbmdSYXRpbyA9IGNsYW1wKG1pbkRhbXBpbmcsIG1heERhbXBpbmcsIGRhbXBpbmdSYXRpbyk7XG4gICAgZHVyYXRpb24gPSBjbGFtcChtaW5EdXJhdGlvbiwgbWF4RHVyYXRpb24sIGR1cmF0aW9uIC8gMTAwMCk7XG4gICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHBvbmVudGlhbERlY2F5ID0gdW5kYW1wZWRGcmVxICogZGFtcGluZ1JhdGlvO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBhID0gZXhwb25lbnRpYWxEZWNheSAtIHZlbG9jaXR5O1xuICAgICAgICAgICAgY29uc3QgYiA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEZyZXEsIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBjID0gTWF0aC5leHAoLWRlbHRhKTtcbiAgICAgICAgICAgIHJldHVybiBzYWZlTWluIC0gKGEgLyBiKSAqIGM7XG4gICAgICAgIH07XG4gICAgICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHBvbmVudGlhbERlY2F5ID0gdW5kYW1wZWRGcmVxICogZGFtcGluZ1JhdGlvO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBleHBvbmVudGlhbERlY2F5ICogZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBkID0gZGVsdGEgKiB2ZWxvY2l0eSArIHZlbG9jaXR5O1xuICAgICAgICAgICAgY29uc3QgZSA9IE1hdGgucG93KGRhbXBpbmdSYXRpbywgMikgKiBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBmID0gTWF0aC5leHAoLWRlbHRhKTtcbiAgICAgICAgICAgIGNvbnN0IGcgPSBjYWxjQW5ndWxhckZyZXEoTWF0aC5wb3codW5kYW1wZWRGcmVxLCAyKSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGZhY3RvciA9IC1lbnZlbG9wZSh1bmRhbXBlZEZyZXEpICsgc2FmZU1pbiA+IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gKGZhY3RvciAqICgoZCAtIGUpICogZikpIC8gZztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IE1hdGguZXhwKC11bmRhbXBlZEZyZXEgKiBkdXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBiID0gKHVuZGFtcGVkRnJlcSAtIHZlbG9jaXR5KSAqIGR1cmF0aW9uICsgMTtcbiAgICAgICAgICAgIHJldHVybiAtc2FmZU1pbiArIGEgKiBiO1xuICAgICAgICB9O1xuICAgICAgICBkZXJpdmF0aXZlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYSA9IE1hdGguZXhwKC11bmRhbXBlZEZyZXEgKiBkdXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBiID0gKHZlbG9jaXR5IC0gdW5kYW1wZWRGcmVxKSAqIChkdXJhdGlvbiAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiBhICogYjtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgaW5pdGlhbEd1ZXNzID0gNSAvIGR1cmF0aW9uO1xuICAgIGNvbnN0IHVuZGFtcGVkRnJlcSA9IGFwcHJveGltYXRlUm9vdChlbnZlbG9wZSwgZGVyaXZhdGl2ZSwgaW5pdGlhbEd1ZXNzKTtcbiAgICBkdXJhdGlvbiA9IGR1cmF0aW9uICogMTAwMDtcbiAgICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzOiAxMDAsXG4gICAgICAgICAgICBkYW1waW5nOiAxMCxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RpZmZuZXNzID0gTWF0aC5wb3codW5kYW1wZWRGcmVxLCAyKSAqIG1hc3M7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGlmZm5lc3MsXG4gICAgICAgICAgICBkYW1waW5nOiBkYW1waW5nUmF0aW8gKiAyICogTWF0aC5zcXJ0KG1hc3MgKiBzdGlmZm5lc3MpLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3Qgcm9vdEl0ZXJhdGlvbnMgPSAxMjtcbmZ1bmN0aW9uIGFwcHJveGltYXRlUm9vdChlbnZlbG9wZSwgZGVyaXZhdGl2ZSwgaW5pdGlhbEd1ZXNzKSB7XG4gICAgbGV0IHJlc3VsdCA9IGluaXRpYWxHdWVzcztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHJvb3RJdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0IC0gZW52ZWxvcGUocmVzdWx0KSAvIGRlcml2YXRpdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEZyZXEsIGRhbXBpbmdSYXRpbykge1xuICAgIHJldHVybiB1bmRhbXBlZEZyZXEgKiBNYXRoLnNxcnQoMSAtIGRhbXBpbmdSYXRpbyAqIGRhbXBpbmdSYXRpbyk7XG59XG5cbmNvbnN0IGR1cmF0aW9uS2V5cyA9IFtcImR1cmF0aW9uXCIsIFwiYm91bmNlXCJdO1xuY29uc3QgcGh5c2ljc0tleXMgPSBbXCJzdGlmZm5lc3NcIiwgXCJkYW1waW5nXCIsIFwibWFzc1wiXTtcbmZ1bmN0aW9uIGlzU3ByaW5nVHlwZShvcHRpb25zLCBrZXlzKSB7XG4gICAgcmV0dXJuIGtleXMuc29tZSgoa2V5KSA9PiBvcHRpb25zW2tleV0gIT09IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBsZXQgc3ByaW5nT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oeyB2ZWxvY2l0eTogMC4wLCBzdGlmZm5lc3M6IDEwMCwgZGFtcGluZzogMTAsIG1hc3M6IDEuMCwgaXNSZXNvbHZlZEZyb21EdXJhdGlvbjogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgaWYgKCFpc1NwcmluZ1R5cGUob3B0aW9ucywgcGh5c2ljc0tleXMpICYmXG4gICAgICAgIGlzU3ByaW5nVHlwZShvcHRpb25zLCBkdXJhdGlvbktleXMpKSB7XG4gICAgICAgIGNvbnN0IGRlcml2ZWQgPSBmaW5kU3ByaW5nKG9wdGlvbnMpO1xuICAgICAgICBzcHJpbmdPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNwcmluZ09wdGlvbnMpLCBkZXJpdmVkKSwgeyB2ZWxvY2l0eTogMC4wLCBtYXNzOiAxLjAgfSk7XG4gICAgICAgIHNwcmluZ09wdGlvbnMuaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzcHJpbmdPcHRpb25zO1xufVxuZnVuY3Rpb24gc3ByaW5nKF9hKSB7XG4gICAgdmFyIHsgZnJvbSA9IDAuMCwgdG8gPSAxLjAsIHJlc3RTcGVlZCA9IDIsIHJlc3REZWx0YSB9ID0gX2EsIG9wdGlvbnMgPSB0c2xpYi5fX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJ0b1wiLCBcInJlc3RTcGVlZFwiLCBcInJlc3REZWx0YVwiXSk7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICAgIGxldCB7IHN0aWZmbmVzcywgZGFtcGluZywgbWFzcywgdmVsb2NpdHksIGR1cmF0aW9uLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uLCB9ID0gZ2V0U3ByaW5nT3B0aW9ucyhvcHRpb25zKTtcbiAgICBsZXQgcmVzb2x2ZVNwcmluZyA9IHplcm87XG4gICAgbGV0IHJlc29sdmVWZWxvY2l0eSA9IHplcm87XG4gICAgZnVuY3Rpb24gY3JlYXRlU3ByaW5nKCkge1xuICAgICAgICBjb25zdCBpbml0aWFsVmVsb2NpdHkgPSB2ZWxvY2l0eSA/IC0odmVsb2NpdHkgLyAxMDAwKSA6IDAuMDtcbiAgICAgICAgY29uc3QgaW5pdGlhbERlbHRhID0gdG8gLSBmcm9tO1xuICAgICAgICBjb25zdCBkYW1waW5nUmF0aW8gPSBkYW1waW5nIC8gKDIgKiBNYXRoLnNxcnQoc3RpZmZuZXNzICogbWFzcykpO1xuICAgICAgICBjb25zdCB1bmRhbXBlZEFuZ3VsYXJGcmVxID0gTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpIC8gMTAwMDtcbiAgICAgICAgaWYgKHJlc3REZWx0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN0RGVsdGEgPSBNYXRoLm1pbihNYXRoLmFicyh0byAtIGZyb20pIC8gMTAwLCAwLjQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgICAgICBjb25zdCBhbmd1bGFyRnJlcSA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEFuZ3VsYXJGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAodG8gLVxuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoKChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRnJlcSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqIE1hdGguY29zKGFuZ3VsYXJGcmVxICogdCkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlVmVsb2NpdHkgPSAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGRhbXBpbmdSYXRpbyAqXG4gICAgICAgICAgICAgICAgICAgIHVuZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICgoTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckZyZXEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSkgLVxuICAgICAgICAgICAgICAgICAgICBlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSkgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYW1waW5nUmF0aW8gPT09IDEpIHtcbiAgICAgICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4gdG8gLVxuICAgICAgICAgICAgICAgIE1hdGguZXhwKC11bmRhbXBlZEFuZ3VsYXJGcmVxICogdCkgKlxuICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbERlbHRhICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsVmVsb2NpdHkgKyB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkYW1wZWRBbmd1bGFyRnJlcSA9IHVuZGFtcGVkQW5ndWxhckZyZXEgKiBNYXRoLnNxcnQoZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvIC0gMSk7XG4gICAgICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJlcUZvclQgPSBNYXRoLm1pbihkYW1wZWRBbmd1bGFyRnJlcSAqIHQsIDMwMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0byAtXG4gICAgICAgICAgICAgICAgICAgIChlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAoKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luaChmcmVxRm9yVCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBlZEFuZ3VsYXJGcmVxICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3NoKGZyZXFGb3JUKSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBlZEFuZ3VsYXJGcmVxKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU3ByaW5nKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSByZXNvbHZlU3ByaW5nKHQpO1xuICAgICAgICAgICAgaWYgKCFpc1Jlc29sdmVkRnJvbUR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0gcmVzb2x2ZVZlbG9jaXR5KHQpICogMTAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQgPSBNYXRoLmFicyhjdXJyZW50VmVsb2NpdHkpIDw9IHJlc3RTcGVlZDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkID0gTWF0aC5hYnModG8gLSBjdXJyZW50KSA8PSByZXN0RGVsdGE7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCAmJiBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0byA6IGN1cnJlbnQ7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gLXZlbG9jaXR5O1xuICAgICAgICAgICAgW2Zyb20sIHRvXSA9IFt0bywgZnJvbV07XG4gICAgICAgICAgICBjcmVhdGVTcHJpbmcoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuc3ByaW5nLm5lZWRzSW50ZXJwb2xhdGlvbiA9IChhLCBiKSA9PiB0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYiA9PT0gXCJzdHJpbmdcIjtcbmNvbnN0IHplcm8gPSAoX3QpID0+IDA7XG5cbmNvbnN0IHByb2dyZXNzID0gKGZyb20sIHRvLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHRvRnJvbURpZmZlcmVuY2UgPSB0byAtIGZyb207XG4gICAgcmV0dXJuIHRvRnJvbURpZmZlcmVuY2UgPT09IDAgPyAxIDogKHZhbHVlIC0gZnJvbSkgLyB0b0Zyb21EaWZmZXJlbmNlO1xufTtcblxuY29uc3QgbWl4ID0gKGZyb20sIHRvLCBwcm9ncmVzcykgPT4gLXByb2dyZXNzICogZnJvbSArIHByb2dyZXNzICogdG8gKyBmcm9tO1xuXG5mdW5jdGlvbiBodWVUb1JnYihwLCBxLCB0KSB7XG4gICAgaWYgKHQgPCAwKVxuICAgICAgICB0ICs9IDE7XG4gICAgaWYgKHQgPiAxKVxuICAgICAgICB0IC09IDE7XG4gICAgaWYgKHQgPCAxIC8gNilcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgaWYgKHQgPCAxIC8gMilcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgaWYgKHQgPCAyIC8gMylcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaHNsYVRvUmdiYSh7IGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYSB9KSB7XG4gICAgaHVlIC89IDM2MDtcbiAgICBzYXR1cmF0aW9uIC89IDEwMDtcbiAgICBsaWdodG5lc3MgLz0gMTAwO1xuICAgIGxldCByZWQgPSAwO1xuICAgIGxldCBncmVlbiA9IDA7XG4gICAgbGV0IGJsdWUgPSAwO1xuICAgIGlmICghc2F0dXJhdGlvbikge1xuICAgICAgICByZWQgPSBncmVlbiA9IGJsdWUgPSBsaWdodG5lc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBxID0gbGlnaHRuZXNzIDwgMC41XG4gICAgICAgICAgICA/IGxpZ2h0bmVzcyAqICgxICsgc2F0dXJhdGlvbilcbiAgICAgICAgICAgIDogbGlnaHRuZXNzICsgc2F0dXJhdGlvbiAtIGxpZ2h0bmVzcyAqIHNhdHVyYXRpb247XG4gICAgICAgIGNvbnN0IHAgPSAyICogbGlnaHRuZXNzIC0gcTtcbiAgICAgICAgcmVkID0gaHVlVG9SZ2IocCwgcSwgaHVlICsgMSAvIDMpO1xuICAgICAgICBncmVlbiA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSk7XG4gICAgICAgIGJsdWUgPSBodWVUb1JnYihwLCBxLCBodWUgLSAxIC8gMyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZDogTWF0aC5yb3VuZChyZWQgKiAyNTUpLFxuICAgICAgICBncmVlbjogTWF0aC5yb3VuZChncmVlbiAqIDI1NSksXG4gICAgICAgIGJsdWU6IE1hdGgucm91bmQoYmx1ZSAqIDI1NSksXG4gICAgICAgIGFscGhhLFxuICAgIH07XG59XG5cbmNvbnN0IG1peExpbmVhckNvbG9yID0gKGZyb20sIHRvLCB2KSA9PiB7XG4gICAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgICBjb25zdCB0b0V4cG8gPSB0byAqIHRvO1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5tYXgoMCwgdiAqICh0b0V4cG8gLSBmcm9tRXhwbykgKyBmcm9tRXhwbykpO1xufTtcbmNvbnN0IGNvbG9yVHlwZXMgPSBbc3R5bGVWYWx1ZVR5cGVzLmhleCwgc3R5bGVWYWx1ZVR5cGVzLnJnYmEsIHN0eWxlVmFsdWVUeXBlcy5oc2xhXTtcbmNvbnN0IGdldENvbG9yVHlwZSA9ICh2KSA9PiBjb2xvclR5cGVzLmZpbmQoKHR5cGUpID0+IHR5cGUudGVzdCh2KSk7XG5jb25zdCBub3RBbmltYXRhYmxlID0gKGNvbG9yKSA9PiBgJyR7Y29sb3J9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gO1xuY29uc3QgbWl4Q29sb3IgPSAoZnJvbSwgdG8pID0+IHtcbiAgICBsZXQgZnJvbUNvbG9yVHlwZSA9IGdldENvbG9yVHlwZShmcm9tKTtcbiAgICBsZXQgdG9Db2xvclR5cGUgPSBnZXRDb2xvclR5cGUodG8pO1xuICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoISFmcm9tQ29sb3JUeXBlLCBub3RBbmltYXRhYmxlKGZyb20pKTtcbiAgICBoZXlMaXN0ZW4uaW52YXJpYW50KCEhdG9Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUodG8pKTtcbiAgICBsZXQgZnJvbUNvbG9yID0gZnJvbUNvbG9yVHlwZS5wYXJzZShmcm9tKTtcbiAgICBsZXQgdG9Db2xvciA9IHRvQ29sb3JUeXBlLnBhcnNlKHRvKTtcbiAgICBpZiAoZnJvbUNvbG9yVHlwZSA9PT0gc3R5bGVWYWx1ZVR5cGVzLmhzbGEpIHtcbiAgICAgICAgZnJvbUNvbG9yID0gaHNsYVRvUmdiYShmcm9tQ29sb3IpO1xuICAgICAgICBmcm9tQ29sb3JUeXBlID0gc3R5bGVWYWx1ZVR5cGVzLnJnYmE7XG4gICAgfVxuICAgIGlmICh0b0NvbG9yVHlwZSA9PT0gc3R5bGVWYWx1ZVR5cGVzLmhzbGEpIHtcbiAgICAgICAgdG9Db2xvciA9IGhzbGFUb1JnYmEodG9Db2xvcik7XG4gICAgICAgIHRvQ29sb3JUeXBlID0gc3R5bGVWYWx1ZVR5cGVzLnJnYmE7XG4gICAgfVxuICAgIGNvbnN0IGJsZW5kZWQgPSBPYmplY3QuYXNzaWduKHt9LCBmcm9tQ29sb3IpO1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcImFscGhhXCIpIHtcbiAgICAgICAgICAgICAgICBibGVuZGVkW2tleV0gPSBtaXhMaW5lYXJDb2xvcihmcm9tQ29sb3Jba2V5XSwgdG9Db2xvcltrZXldLCB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBibGVuZGVkLmFscGhhID0gbWl4KGZyb21Db2xvci5hbHBoYSwgdG9Db2xvci5hbHBoYSwgdik7XG4gICAgICAgIHJldHVybiBmcm9tQ29sb3JUeXBlLnRyYW5zZm9ybShibGVuZGVkKTtcbiAgICB9O1xufTtcblxuY29uc3QgemVyb1BvaW50ID0ge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICB6OiAwXG59O1xuY29uc3QgaXNOdW0gPSAodikgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInO1xuXG5jb25zdCBjb21iaW5lRnVuY3Rpb25zID0gKGEsIGIpID0+ICh2KSA9PiBiKGEodikpO1xuY29uc3QgcGlwZSA9ICguLi50cmFuc2Zvcm1lcnMpID0+IHRyYW5zZm9ybWVycy5yZWR1Y2UoY29tYmluZUZ1bmN0aW9ucyk7XG5cbmZ1bmN0aW9uIGdldE1peGVyKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgaWYgKGlzTnVtKG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuICh2KSA9PiBtaXgob3JpZ2luLCB0YXJnZXQsIHYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHlsZVZhbHVlVHlwZXMuY29sb3IudGVzdChvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBtaXhDb2xvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbWl4Q29tcGxleChvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxufVxuY29uc3QgbWl4QXJyYXkgPSAoZnJvbSwgdG8pID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBbLi4uZnJvbV07XG4gICAgY29uc3QgbnVtVmFsdWVzID0gb3V0cHV0Lmxlbmd0aDtcbiAgICBjb25zdCBibGVuZFZhbHVlID0gZnJvbS5tYXAoKGZyb21UaGlzLCBpKSA9PiBnZXRNaXhlcihmcm9tVGhpcywgdG9baV0pKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gYmxlbmRWYWx1ZVtpXSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59O1xuY29uc3QgbWl4T2JqZWN0ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcmlnaW4pLCB0YXJnZXQpO1xuICAgIGNvbnN0IGJsZW5kVmFsdWUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICAgICAgaWYgKG9yaWdpbltrZXldICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxlbmRWYWx1ZVtrZXldID0gZ2V0TWl4ZXIob3JpZ2luW2tleV0sIHRhcmdldFtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYmxlbmRWYWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBibGVuZFZhbHVlW2tleV0odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufTtcbmZ1bmN0aW9uIGFuYWx5c2UodmFsdWUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBzdHlsZVZhbHVlVHlwZXMuY29tcGxleC5wYXJzZSh2YWx1ZSk7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gcGFyc2VkLmxlbmd0aDtcbiAgICBsZXQgbnVtTnVtYmVycyA9IDA7XG4gICAgbGV0IG51bVJHQiA9IDA7XG4gICAgbGV0IG51bUhTTCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICBpZiAobnVtTnVtYmVycyB8fCB0eXBlb2YgcGFyc2VkW2ldID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBudW1OdW1iZXJzKys7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2VkW2ldLmh1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbnVtSFNMKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBudW1SR0IrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBwYXJzZWQsIG51bU51bWJlcnMsIG51bVJHQiwgbnVtSFNMIH07XG59XG5jb25zdCBtaXhDb21wbGV4ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3QgdGVtcGxhdGUgPSBzdHlsZVZhbHVlVHlwZXMuY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcih0YXJnZXQpO1xuICAgIGNvbnN0IG9yaWdpblN0YXRzID0gYW5hbHlzZShvcmlnaW4pO1xuICAgIGNvbnN0IHRhcmdldFN0YXRzID0gYW5hbHlzZSh0YXJnZXQpO1xuICAgIGNvbnN0IGNhbkludGVycG9sYXRlID0gb3JpZ2luU3RhdHMubnVtSFNMID09PSB0YXJnZXRTdGF0cy5udW1IU0wgJiZcbiAgICAgICAgb3JpZ2luU3RhdHMubnVtUkdCID09PSB0YXJnZXRTdGF0cy5udW1SR0IgJiZcbiAgICAgICAgb3JpZ2luU3RhdHMubnVtTnVtYmVycyA+PSB0YXJnZXRTdGF0cy5udW1OdW1iZXJzO1xuICAgIGlmIChjYW5JbnRlcnBvbGF0ZSkge1xuICAgICAgICByZXR1cm4gcGlwZShtaXhBcnJheShvcmlnaW5TdGF0cy5wYXJzZWQsIHRhcmdldFN0YXRzLnBhcnNlZCksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGhleUxpc3Rlbi53YXJuaW5nKHRydWUsIGBDb21wbGV4IHZhbHVlcyAnJHtvcmlnaW59JyBhbmQgJyR7dGFyZ2V0fScgdG9vIGRpZmZlcmVudCB0byBtaXguIEVuc3VyZSBhbGwgY29sb3JzIGFyZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgdGhhdCBlYWNoIGNvbnRhaW5zIHRoZSBzYW1lIHF1YW50aXR5IG9mIG51bWJlciBhbmQgY29sb3IgdmFsdWVzLiBGYWxsaW5nIGJhY2sgdG8gaW5zdGFudCB0cmFuc2l0aW9uLmApO1xuICAgICAgICByZXR1cm4gKHApID0+IGAke3AgPiAwID8gdGFyZ2V0IDogb3JpZ2lufWA7XG4gICAgfVxufTtcblxuY29uc3QgbWl4TnVtYmVyID0gKGZyb20sIHRvKSA9PiAocCkgPT4gbWl4KGZyb20sIHRvLCBwKTtcbmZ1bmN0aW9uIGRldGVjdE1peGVyRmFjdG9yeSh2KSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbWl4TnVtYmVyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHN0eWxlVmFsdWVUeXBlcy5jb2xvci50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4Q29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWl4Q29tcGxleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHJldHVybiBtaXhBcnJheTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBtaXhPYmplY3Q7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgY3VzdG9tTWl4ZXIpIHtcbiAgICBjb25zdCBtaXhlcnMgPSBbXTtcbiAgICBjb25zdCBtaXhlckZhY3RvcnkgPSBjdXN0b21NaXhlciB8fCBkZXRlY3RNaXhlckZhY3Rvcnkob3V0cHV0WzBdKTtcbiAgICBjb25zdCBudW1NaXhlcnMgPSBvdXRwdXQubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU1peGVyczsgaSsrKSB7XG4gICAgICAgIGxldCBtaXhlciA9IG1peGVyRmFjdG9yeShvdXRwdXRbaV0sIG91dHB1dFtpICsgMV0pO1xuICAgICAgICBpZiAoZWFzZSkge1xuICAgICAgICAgICAgY29uc3QgZWFzaW5nRnVuY3Rpb24gPSBBcnJheS5pc0FycmF5KGVhc2UpID8gZWFzZVtpXSA6IGVhc2U7XG4gICAgICAgICAgICBtaXhlciA9IHBpcGUoZWFzaW5nRnVuY3Rpb24sIG1peGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtaXhlcnMucHVzaChtaXhlcik7XG4gICAgfVxuICAgIHJldHVybiBtaXhlcnM7XG59XG5mdW5jdGlvbiBmYXN0SW50ZXJwb2xhdGUoW2Zyb20sIHRvXSwgW21peGVyXSkge1xuICAgIHJldHVybiAodikgPT4gbWl4ZXIocHJvZ3Jlc3MoZnJvbSwgdG8sIHYpKTtcbn1cbmZ1bmN0aW9uIHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKSB7XG4gICAgY29uc3QgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgY29uc3QgbGFzdElucHV0SW5kZXggPSBpbnB1dExlbmd0aCAtIDE7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGxldCBtaXhlckluZGV4ID0gMDtcbiAgICAgICAgbGV0IGZvdW5kTWl4ZXJJbmRleCA9IGZhbHNlO1xuICAgICAgICBpZiAodiA8PSBpbnB1dFswXSkge1xuICAgICAgICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID49IGlucHV0W2xhc3RJbnB1dEluZGV4XSkge1xuICAgICAgICAgICAgbWl4ZXJJbmRleCA9IGxhc3RJbnB1dEluZGV4IC0gMTtcbiAgICAgICAgICAgIGZvdW5kTWl4ZXJJbmRleCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmb3VuZE1peGVySW5kZXgpIHtcbiAgICAgICAgICAgIGxldCBpID0gMTtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgaW5wdXRMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dFtpXSA+IHYgfHwgaSA9PT0gbGFzdElucHV0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWl4ZXJJbmRleCA9IGkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2dyZXNzSW5SYW5nZSA9IHByb2dyZXNzKGlucHV0W21peGVySW5kZXhdLCBpbnB1dFttaXhlckluZGV4ICsgMV0sIHYpO1xuICAgICAgICByZXR1cm4gbWl4ZXJzW21peGVySW5kZXhdKHByb2dyZXNzSW5SYW5nZSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBvdXRwdXQsIHsgY2xhbXA6IGlzQ2xhbXAgPSB0cnVlLCBlYXNlLCBtaXhlciB9ID0ge30pIHtcbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBoZXlMaXN0ZW4uaW52YXJpYW50KGlucHV0TGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoLCAnQm90aCBpbnB1dCBhbmQgb3V0cHV0IHJhbmdlcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIGhleUxpc3Rlbi5pbnZhcmlhbnQoIWVhc2UgfHwgIUFycmF5LmlzQXJyYXkoZWFzZSkgfHwgZWFzZS5sZW5ndGggPT09IGlucHV0TGVuZ3RoIC0gMSwgJ0FycmF5IG9mIGVhc2luZyBmdW5jdGlvbnMgbXVzdCBiZSBvZiBsZW5ndGggYGlucHV0Lmxlbmd0aCAtIDFgLCBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0cmFuc2l0aW9ucyAqKmJldHdlZW4qKiB0aGUgZGVmaW5lZCB2YWx1ZXMuJyk7XG4gICAgaWYgKGlucHV0WzBdID4gaW5wdXRbaW5wdXRMZW5ndGggLSAxXSkge1xuICAgICAgICBpbnB1dCA9IFtdLmNvbmNhdChpbnB1dCk7XG4gICAgICAgIG91dHB1dCA9IFtdLmNvbmNhdChvdXRwdXQpO1xuICAgICAgICBpbnB1dC5yZXZlcnNlKCk7XG4gICAgICAgIG91dHB1dC5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGNvbnN0IG1peGVycyA9IGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIG1peGVyKTtcbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSBpbnB1dExlbmd0aCA9PT0gMlxuICAgICAgICA/IGZhc3RJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKVxuICAgICAgICA6IHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKTtcbiAgICByZXR1cm4gaXNDbGFtcFxuICAgICAgICA/ICh2KSA9PiBpbnRlcnBvbGF0b3IoY2xhbXAoaW5wdXRbMF0sIGlucHV0W2lucHV0TGVuZ3RoIC0gMV0sIHYpKVxuICAgICAgICA6IGludGVycG9sYXRvcjtcbn1cblxuY29uc3QgcmV2ZXJzZUVhc2luZyA9IGVhc2luZyA9PiBwID0+IDEgLSBlYXNpbmcoMSAtIHApO1xuY29uc3QgbWlycm9yRWFzaW5nID0gZWFzaW5nID0+IHAgPT4gcCA8PSAwLjUgPyBlYXNpbmcoMiAqIHApIC8gMiA6ICgyIC0gZWFzaW5nKDIgKiAoMSAtIHApKSkgLyAyO1xuY29uc3QgY3JlYXRlRXhwb0luID0gKHBvd2VyKSA9PiBwID0+IE1hdGgucG93KHAsIHBvd2VyKTtcbmNvbnN0IGNyZWF0ZUJhY2tJbiA9IChwb3dlcikgPT4gcCA9PiBwICogcCAqICgocG93ZXIgKyAxKSAqIHAgLSBwb3dlcik7XG5jb25zdCBjcmVhdGVBbnRpY2lwYXRlID0gKHBvd2VyKSA9PiB7XG4gICAgY29uc3QgYmFja0Vhc2luZyA9IGNyZWF0ZUJhY2tJbihwb3dlcik7XG4gICAgcmV0dXJuIHAgPT4gKHAgKj0gMikgPCAxXG4gICAgICAgID8gMC41ICogYmFja0Vhc2luZyhwKVxuICAgICAgICA6IDAuNSAqICgyIC0gTWF0aC5wb3coMiwgLTEwICogKHAgLSAxKSkpO1xufTtcblxuY29uc3QgREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEggPSAxLjUyNTtcbmNvbnN0IEJPVU5DRV9GSVJTVF9USFJFU0hPTEQgPSA0LjAgLyAxMS4wO1xuY29uc3QgQk9VTkNFX1NFQ09ORF9USFJFU0hPTEQgPSA4LjAgLyAxMS4wO1xuY29uc3QgQk9VTkNFX1RISVJEX1RIUkVTSE9MRCA9IDkuMCAvIDEwLjA7XG5jb25zdCBsaW5lYXIgPSBwID0+IHA7XG5jb25zdCBlYXNlSW4gPSBjcmVhdGVFeHBvSW4oMik7XG5jb25zdCBlYXNlT3V0ID0gcmV2ZXJzZUVhc2luZyhlYXNlSW4pO1xuY29uc3QgZWFzZUluT3V0ID0gbWlycm9yRWFzaW5nKGVhc2VJbik7XG5jb25zdCBjaXJjSW4gPSBwID0+IDEgLSBNYXRoLnNpbihNYXRoLmFjb3MocCkpO1xuY29uc3QgY2lyY091dCA9IHJldmVyc2VFYXNpbmcoY2lyY0luKTtcbmNvbnN0IGNpcmNJbk91dCA9IG1pcnJvckVhc2luZyhjaXJjT3V0KTtcbmNvbnN0IGJhY2tJbiA9IGNyZWF0ZUJhY2tJbihERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCk7XG5jb25zdCBiYWNrT3V0ID0gcmV2ZXJzZUVhc2luZyhiYWNrSW4pO1xuY29uc3QgYmFja0luT3V0ID0gbWlycm9yRWFzaW5nKGJhY2tJbik7XG5jb25zdCBhbnRpY2lwYXRlID0gY3JlYXRlQW50aWNpcGF0ZShERUZBVUxUX09WRVJTSE9PVF9TVFJFTkdUSCk7XG5jb25zdCBjYSA9IDQzNTYuMCAvIDM2MS4wO1xuY29uc3QgY2IgPSAzNTQ0Mi4wIC8gMTgwNS4wO1xuY29uc3QgY2MgPSAxNjA2MS4wIC8gMTgwNS4wO1xuY29uc3QgYm91bmNlT3V0ID0gKHApID0+IHtcbiAgICBpZiAocCA9PT0gMSB8fCBwID09PSAwKVxuICAgICAgICByZXR1cm4gcDtcbiAgICBjb25zdCBwMiA9IHAgKiBwO1xuICAgIHJldHVybiBwIDwgQk9VTkNFX0ZJUlNUX1RIUkVTSE9MRFxuICAgICAgICA/IDcuNTYyNSAqIHAyXG4gICAgICAgIDogcCA8IEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEXG4gICAgICAgICAgICA/IDkuMDc1ICogcDIgLSA5LjkgKiBwICsgMy40XG4gICAgICAgICAgICA6IHAgPCBCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEXG4gICAgICAgICAgICAgICAgPyBjYSAqIHAyIC0gY2IgKiBwICsgY2NcbiAgICAgICAgICAgICAgICA6IDEwLjggKiBwICogcCAtIDIwLjUyICogcCArIDEwLjcyO1xufTtcbmNvbnN0IGJvdW5jZUluID0gcmV2ZXJzZUVhc2luZyhib3VuY2VPdXQpO1xuY29uc3QgYm91bmNlSW5PdXQgPSAocCkgPT4gcCA8IDAuNVxuICAgID8gMC41ICogKDEuMCAtIGJvdW5jZU91dCgxLjAgLSBwICogMi4wKSlcbiAgICA6IDAuNSAqIGJvdW5jZU91dChwICogMi4wIC0gMS4wKSArIDAuNTtcblxuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2luZykge1xuICAgIHJldHVybiB2YWx1ZXMubWFwKCgpID0+IGVhc2luZyB8fCBlYXNlSW5PdXQpLnNwbGljZSgwLCB2YWx1ZXMubGVuZ3RoIC0gMSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0T2Zmc2V0KHZhbHVlcykge1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IHZhbHVlcy5sZW5ndGg7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKF92YWx1ZSwgaSkgPT4gaSAhPT0gMCA/IGkgLyAobnVtVmFsdWVzIC0gMSkgOiAwKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGZyb20gPSAwLCB0byA9IDEsIGVhc2UsIG9mZnNldCwgZHVyYXRpb24gPSAzMDAsIH0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gICAgY29uc3QgdmFsdWVzID0gQXJyYXkuaXNBcnJheSh0bykgPyB0byA6IFtmcm9tLCB0b107XG4gICAgY29uc3QgdGltZXMgPSBjb252ZXJ0T2Zmc2V0VG9UaW1lcyhvZmZzZXQgJiYgb2Zmc2V0Lmxlbmd0aCA9PT0gdmFsdWVzLmxlbmd0aFxuICAgICAgICA/IG9mZnNldFxuICAgICAgICA6IGRlZmF1bHRPZmZzZXQodmFsdWVzKSwgZHVyYXRpb24pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludGVycG9sYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYXRlKHRpbWVzLCB2YWx1ZXMsIHtcbiAgICAgICAgICAgIGVhc2U6IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlIDogZGVmYXVsdEVhc2luZyh2YWx1ZXMsIGVhc2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IGludGVycG9sYXRvciA9IGNyZWF0ZUludGVycG9sYXRvcigpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICh0KSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IGludGVycG9sYXRvcih0KTtcbiAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICB2YWx1ZXMucmV2ZXJzZSgpO1xuICAgICAgICAgICAgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVjYXkoeyB2ZWxvY2l0eSA9IDAsIGZyb20gPSAwLCBwb3dlciA9IDAuOCwgdGltZUNvbnN0YW50ID0gMzUwLCByZXN0RGVsdGEgPSAwLjUsIG1vZGlmeVRhcmdldCwgfSkge1xuICAgIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgICBsZXQgYW1wbGl0dWRlID0gcG93ZXIgKiB2ZWxvY2l0eTtcbiAgICBjb25zdCBpZGVhbCA9IGZyb20gKyBhbXBsaXR1ZGU7XG4gICAgY29uc3QgdGFyZ2V0ID0gbW9kaWZ5VGFyZ2V0ID09PSB1bmRlZmluZWQgPyBpZGVhbCA6IG1vZGlmeVRhcmdldChpZGVhbCk7XG4gICAgaWYgKHRhcmdldCAhPT0gaWRlYWwpXG4gICAgICAgIGFtcGxpdHVkZSA9IHRhcmdldCAtIGZyb207XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gLWFtcGxpdHVkZSAqIE1hdGguZXhwKC10IC8gdGltZUNvbnN0YW50KTtcbiAgICAgICAgICAgIHN0YXRlLmRvbmUgPSAhKGRlbHRhID4gcmVzdERlbHRhIHx8IGRlbHRhIDwgLXJlc3REZWx0YSk7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0YXJnZXQgOiB0YXJnZXQgKyBkZWx0YTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxpcFRhcmdldDogKCkgPT4geyB9LFxuICAgIH07XG59XG5cbmNvbnN0IHR5cGVzID0geyBrZXlmcmFtZXMsIHNwcmluZywgZGVjYXkgfTtcbmZ1bmN0aW9uIGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zKGNvbmZpZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy50bykpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lcztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZXNbY29uZmlnLnR5cGVdKSB7XG4gICAgICAgIHJldHVybiB0eXBlc1tjb25maWcudHlwZV07XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGNvbmZpZykpO1xuICAgIGlmIChrZXlzLmhhcyhcImVhc2VcIikgfHxcbiAgICAgICAgKGtleXMuaGFzKFwiZHVyYXRpb25cIikgJiYgIWtleXMuaGFzKFwiZGFtcGluZ1JhdGlvXCIpKSkge1xuICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXlzLmhhcyhcImRhbXBpbmdSYXRpb1wiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcInN0aWZmbmVzc1wiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcIm1hc3NcIikgfHxcbiAgICAgICAga2V5cy5oYXMoXCJkYW1waW5nXCIpIHx8XG4gICAgICAgIGtleXMuaGFzKFwicmVzdFNwZWVkXCIpIHx8XG4gICAgICAgIGtleXMuaGFzKFwicmVzdERlbHRhXCIpKSB7XG4gICAgICAgIHJldHVybiBzcHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBrZXlmcmFtZXM7XG59XG5cbmZ1bmN0aW9uIGxvb3BFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSA9IDApIHtcbiAgICByZXR1cm4gZWxhcHNlZCAtIGR1cmF0aW9uIC0gZGVsYXk7XG59XG5mdW5jdGlvbiByZXZlcnNlRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkgPSAwLCBpc0ZvcndhcmRQbGF5YmFjayA9IHRydWUpIHtcbiAgICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2tcbiAgICAgICAgPyBsb29wRWxhcHNlZChkdXJhdGlvbiArIC1lbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkpXG4gICAgICAgIDogZHVyYXRpb24gLSAoZWxhcHNlZCAtIGR1cmF0aW9uKSArIGRlbGF5O1xufVxuZnVuY3Rpb24gaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSwgaXNGb3J3YXJkUGxheWJhY2spIHtcbiAgICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBlbGFwc2VkID49IGR1cmF0aW9uICsgZGVsYXkgOiBlbGFwc2VkIDw9IC1kZWxheTtcbn1cblxuY29uc3QgZnJhbWVzeW5jID0gKHVwZGF0ZSkgPT4ge1xuICAgIGNvbnN0IHBhc3NUaW1lc3RhbXAgPSAoeyBkZWx0YSB9KSA9PiB1cGRhdGUoZGVsdGEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAoKSA9PiBzeW5jX19kZWZhdWx0W1wiZGVmYXVsdFwiXS51cGRhdGUocGFzc1RpbWVzdGFtcCwgdHJ1ZSksXG4gICAgICAgIHN0b3A6ICgpID0+IHN5bmMuY2FuY2VsU3luYy51cGRhdGUocGFzc1RpbWVzdGFtcCksXG4gICAgfTtcbn07XG5mdW5jdGlvbiBhbmltYXRlKF9hKSB7XG4gICAgdmFyIF9iLCBfYztcbiAgICB2YXIgeyBmcm9tLCBhdXRvcGxheSA9IHRydWUsIGRyaXZlciA9IGZyYW1lc3luYywgZWxhcHNlZCA9IDAsIHJlcGVhdDogcmVwZWF0TWF4ID0gMCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiLCByZXBlYXREZWxheSA9IDAsIG9uUGxheSwgb25TdG9wLCBvbkNvbXBsZXRlLCBvblJlcGVhdCwgb25VcGRhdGUgfSA9IF9hLCBvcHRpb25zID0gdHNsaWIuX19yZXN0KF9hLCBbXCJmcm9tXCIsIFwiYXV0b3BsYXlcIiwgXCJkcml2ZXJcIiwgXCJlbGFwc2VkXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0VHlwZVwiLCBcInJlcGVhdERlbGF5XCIsIFwib25QbGF5XCIsIFwib25TdG9wXCIsIFwib25Db21wbGV0ZVwiLCBcIm9uUmVwZWF0XCIsIFwib25VcGRhdGVcIl0pO1xuICAgIGxldCB7IHRvIH0gPSBvcHRpb25zO1xuICAgIGxldCBkcml2ZXJDb250cm9scztcbiAgICBsZXQgcmVwZWF0Q291bnQgPSAwO1xuICAgIGxldCBjb21wdXRlZER1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICBsZXQgbGF0ZXN0O1xuICAgIGxldCBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgbGV0IGlzRm9yd2FyZFBsYXliYWNrID0gdHJ1ZTtcbiAgICBsZXQgaW50ZXJwb2xhdGVGcm9tTnVtYmVyO1xuICAgIGNvbnN0IGFuaW1hdG9yID0gZGV0ZWN0QW5pbWF0aW9uRnJvbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKChfYyA9IChfYiA9IGFuaW1hdG9yKS5uZWVkc0ludGVycG9sYXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBmcm9tLCB0bykpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVGcm9tTnVtYmVyID0gaW50ZXJwb2xhdGUoWzAsIDEwMF0sIFtmcm9tLCB0b10sIHtcbiAgICAgICAgICAgIGNsYW1wOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGZyb20gPSAwO1xuICAgICAgICB0byA9IDEwMDtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gYW5pbWF0b3IoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBmcm9tLCB0byB9KSk7XG4gICAgZnVuY3Rpb24gcmVwZWF0KCkge1xuICAgICAgICByZXBlYXRDb3VudCsrO1xuICAgICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJyZXZlcnNlXCIpIHtcbiAgICAgICAgICAgIGlzRm9yd2FyZFBsYXliYWNrID0gcmVwZWF0Q291bnQgJSAyID09PSAwO1xuICAgICAgICAgICAgZWxhcHNlZCA9IHJldmVyc2VFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGFwc2VkID0gbG9vcEVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXkpO1xuICAgICAgICAgICAgaWYgKHJlcGVhdFR5cGUgPT09IFwibWlycm9yXCIpXG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uLmZsaXBUYXJnZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgICAgIG9uUmVwZWF0ICYmIG9uUmVwZWF0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGUoZGVsdGEpIHtcbiAgICAgICAgaWYgKCFpc0ZvcndhcmRQbGF5YmFjaylcbiAgICAgICAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgICAgICBlbGFwc2VkICs9IGRlbHRhO1xuICAgICAgICBpZiAoIWlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYW5pbWF0aW9uLm5leHQoTWF0aC5tYXgoMCwgZWxhcHNlZCkpO1xuICAgICAgICAgICAgbGF0ZXN0ID0gc3RhdGUudmFsdWU7XG4gICAgICAgICAgICBpZiAoaW50ZXJwb2xhdGVGcm9tTnVtYmVyKVxuICAgICAgICAgICAgICAgIGxhdGVzdCA9IGludGVycG9sYXRlRnJvbU51bWJlcihsYXRlc3QpO1xuICAgICAgICAgICAgaXNDb21wbGV0ZSA9IGlzRm9yd2FyZFBsYXliYWNrID8gc3RhdGUuZG9uZSA6IGVsYXBzZWQgPD0gMDtcbiAgICAgICAgfVxuICAgICAgICBvblVwZGF0ZSA9PT0gbnVsbCB8fCBvblVwZGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25VcGRhdGUobGF0ZXN0KTtcbiAgICAgICAgaWYgKGlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIGlmIChyZXBlYXRDb3VudCA9PT0gMClcbiAgICAgICAgICAgICAgICBjb21wdXRlZER1cmF0aW9uICE9PSBudWxsICYmIGNvbXB1dGVkRHVyYXRpb24gIT09IHZvaWQgMCA/IGNvbXB1dGVkRHVyYXRpb24gOiAoY29tcHV0ZWREdXJhdGlvbiA9IGVsYXBzZWQpO1xuICAgICAgICAgICAgaWYgKHJlcGVhdENvdW50IDwgcmVwZWF0TWF4KSB7XG4gICAgICAgICAgICAgICAgaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGNvbXB1dGVkRHVyYXRpb24sIHJlcGVhdERlbGF5LCBpc0ZvcndhcmRQbGF5YmFjaykgJiYgcmVwZWF0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgIG9uUGxheSA9PT0gbnVsbCB8fCBvblBsYXkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUGxheSgpO1xuICAgICAgICBkcml2ZXJDb250cm9scyA9IGRyaXZlcih1cGRhdGUpO1xuICAgICAgICBkcml2ZXJDb250cm9scy5zdGFydCgpO1xuICAgIH1cbiAgICBhdXRvcGxheSAmJiBwbGF5KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgb25TdG9wID09PSBudWxsIHx8IG9uU3RvcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25TdG9wKCk7XG4gICAgICAgICAgICBkcml2ZXJDb250cm9scy5zdG9wKCk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gdmVsb2NpdHlQZXJTZWNvbmQodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZnJhbWVEdXJhdGlvbiA/IHZlbG9jaXR5ICogKDEwMDAgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG59XG5cbmZ1bmN0aW9uIGluZXJ0aWEoeyBmcm9tID0gMCwgdmVsb2NpdHkgPSAwLCBtaW4sIG1heCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDc1MCwgYm91bmNlU3RpZmZuZXNzID0gNTAwLCBib3VuY2VEYW1waW5nID0gMTAsIHJlc3REZWx0YSA9IDEsIG1vZGlmeVRhcmdldCwgZHJpdmVyLCBvblVwZGF0ZSwgb25Db21wbGV0ZSwgb25TdG9wLCB9KSB7XG4gICAgbGV0IGN1cnJlbnRBbmltYXRpb247XG4gICAgZnVuY3Rpb24gaXNPdXRPZkJvdW5kcyh2KSB7XG4gICAgICAgIHJldHVybiAobWluICE9PSB1bmRlZmluZWQgJiYgdiA8IG1pbikgfHwgKG1heCAhPT0gdW5kZWZpbmVkICYmIHYgPiBtYXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZGFyeU5lYXJlc3Qodikge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobWluIC0gdikgPCBNYXRoLmFicyhtYXggLSB2KSA/IG1pbiA6IG1heDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24ob3B0aW9ucykge1xuICAgICAgICBjdXJyZW50QW5pbWF0aW9uID09PSBudWxsIHx8IGN1cnJlbnRBbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRyaXZlciwgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZSh2KTtcbiAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB2KTtcbiAgICAgICAgICAgIH0sIG9uQ29tcGxldGUsXG4gICAgICAgICAgICBvblN0b3AgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFNwcmluZyhvcHRpb25zKSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInNwcmluZ1wiLCBzdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcywgZGFtcGluZzogYm91bmNlRGFtcGluZywgcmVzdERlbHRhIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGlzT3V0T2ZCb3VuZHMoZnJvbSkpIHtcbiAgICAgICAgc3RhcnRTcHJpbmcoeyBmcm9tLCB2ZWxvY2l0eSwgdG86IGJvdW5kYXJ5TmVhcmVzdChmcm9tKSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBwb3dlciAqIHZlbG9jaXR5ICsgZnJvbTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZnlUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICB0YXJnZXQgPSBtb2RpZnlUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYm91bmRhcnkgPSBib3VuZGFyeU5lYXJlc3QodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IGJvdW5kYXJ5ID09PSBtaW4gPyAtMSA6IDE7XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgY29uc3QgY2hlY2tCb3VuZGFyeSA9ICh2KSA9PiB7XG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZCh2IC0gcHJldiwgc3luYy5nZXRGcmFtZURhdGEoKS5kZWx0YSk7XG4gICAgICAgICAgICBpZiAoKGhlYWRpbmcgPT09IDEgJiYgdiA+IGJvdW5kYXJ5KSB8fFxuICAgICAgICAgICAgICAgIChoZWFkaW5nID09PSAtMSAmJiB2IDwgYm91bmRhcnkpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRTcHJpbmcoeyBmcm9tOiB2LCB0bzogYm91bmRhcnksIHZlbG9jaXR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdGFydEFuaW1hdGlvbih7XG4gICAgICAgICAgICB0eXBlOiBcImRlY2F5XCIsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdmVsb2NpdHksXG4gICAgICAgICAgICB0aW1lQ29uc3RhbnQsXG4gICAgICAgICAgICBwb3dlcixcbiAgICAgICAgICAgIHJlc3REZWx0YSxcbiAgICAgICAgICAgIG1vZGlmeVRhcmdldCxcbiAgICAgICAgICAgIG9uVXBkYXRlOiBpc091dE9mQm91bmRzKHRhcmdldCkgPyBjaGVja0JvdW5kYXJ5IDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogKCkgPT4gY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50QW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50QW5pbWF0aW9uLnN0b3AoKSxcbiAgICB9O1xufVxuXG5jb25zdCByYWRpYW5zVG9EZWdyZWVzID0gKHJhZGlhbnMpID0+IChyYWRpYW5zICogMTgwKSAvIE1hdGguUEk7XG5cbmNvbnN0IGFuZ2xlID0gKGEsIGIgPSB6ZXJvUG9pbnQpID0+IHJhZGlhbnNUb0RlZ3JlZXMoTWF0aC5hdGFuMihiLnkgLSBhLnksIGIueCAtIGEueCkpO1xuXG5jb25zdCBhcHBseU9mZnNldCA9IChmcm9tLCB0bykgPT4ge1xuICAgIGxldCBoYXNSZWNlaXZlZEZyb20gPSB0cnVlO1xuICAgIGlmICh0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRvID0gZnJvbTtcbiAgICAgICAgaGFzUmVjZWl2ZWRGcm9tID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBpZiAoaGFzUmVjZWl2ZWRGcm9tKSB7XG4gICAgICAgICAgICByZXR1cm4gdiAtIGZyb20gKyB0bztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSB2O1xuICAgICAgICAgICAgaGFzUmVjZWl2ZWRGcm9tID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5jb25zdCBpZGVudGl0eSA9ICh2KSA9PiB2O1xuY29uc3QgY3JlYXRlQXR0cmFjdG9yID0gKGFsdGVyRGlzcGxhY2VtZW50ID0gaWRlbnRpdHkpID0+IChjb25zdGFudCwgb3JpZ2luLCB2KSA9PiB7XG4gICAgY29uc3QgZGlzcGxhY2VtZW50ID0gb3JpZ2luIC0gdjtcbiAgICBjb25zdCBzcHJpbmdNb2RpZmllZERpc3BsYWNlbWVudCA9IC0oMCAtIGNvbnN0YW50ICsgMSkgKiAoMCAtIGFsdGVyRGlzcGxhY2VtZW50KE1hdGguYWJzKGRpc3BsYWNlbWVudCkpKTtcbiAgICByZXR1cm4gZGlzcGxhY2VtZW50IDw9IDBcbiAgICAgICAgPyBvcmlnaW4gKyBzcHJpbmdNb2RpZmllZERpc3BsYWNlbWVudFxuICAgICAgICA6IG9yaWdpbiAtIHNwcmluZ01vZGlmaWVkRGlzcGxhY2VtZW50O1xufTtcbmNvbnN0IGF0dHJhY3QgPSBjcmVhdGVBdHRyYWN0b3IoKTtcbmNvbnN0IGF0dHJhY3RFeHBvID0gY3JlYXRlQXR0cmFjdG9yKE1hdGguc3FydCk7XG5cbmNvbnN0IGRlZ3JlZXNUb1JhZGlhbnMgPSAoZGVncmVlcykgPT4gKGRlZ3JlZXMgKiBNYXRoLlBJKSAvIDE4MDtcblxuY29uc3QgaXNQb2ludCA9IChwb2ludCkgPT4gcG9pbnQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBwb2ludC5oYXNPd25Qcm9wZXJ0eSgneScpO1xuXG5jb25zdCBpc1BvaW50M0QgPSAocG9pbnQpID0+IGlzUG9pbnQocG9pbnQpICYmIHBvaW50Lmhhc093blByb3BlcnR5KCd6Jyk7XG5cbmNvbnN0IGRpc3RhbmNlMUQgPSAoYSwgYikgPT4gTWF0aC5hYnMoYSAtIGIpO1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIGlmIChpc051bShhKSAmJiBpc051bShiKSkge1xuICAgICAgICByZXR1cm4gZGlzdGFuY2UxRChhLCBiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQb2ludChhKSAmJiBpc1BvaW50KGIpKSB7XG4gICAgICAgIGNvbnN0IHhEZWx0YSA9IGRpc3RhbmNlMUQoYS54LCBiLngpO1xuICAgICAgICBjb25zdCB5RGVsdGEgPSBkaXN0YW5jZTFEKGEueSwgYi55KTtcbiAgICAgICAgY29uc3QgekRlbHRhID0gaXNQb2ludDNEKGEpICYmIGlzUG9pbnQzRChiKSA/IGRpc3RhbmNlMUQoYS56LCBiLnopIDogMDtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh4RGVsdGEsIDIpICsgTWF0aC5wb3coeURlbHRhLCAyKSArIE1hdGgucG93KHpEZWx0YSwgMikpO1xuICAgIH1cbn1cblxuY29uc3QgcG9pbnRGcm9tVmVjdG9yID0gKG9yaWdpbiwgYW5nbGUsIGRpc3RhbmNlKSA9PiB7XG4gICAgYW5nbGUgPSBkZWdyZWVzVG9SYWRpYW5zKGFuZ2xlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKSArIG9yaWdpbi54LFxuICAgICAgICB5OiBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKSArIG9yaWdpbi55XG4gICAgfTtcbn07XG5cbmNvbnN0IHRvRGVjaW1hbCA9IChudW0sIHByZWNpc2lvbiA9IDIpID0+IHtcbiAgICBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xufTtcblxuY29uc3Qgc21vb3RoRnJhbWUgPSAocHJldlZhbHVlLCBuZXh0VmFsdWUsIGR1cmF0aW9uLCBzbW9vdGhpbmcgPSAwKSA9PiB0b0RlY2ltYWwocHJldlZhbHVlICtcbiAgICAoZHVyYXRpb24gKiAobmV4dFZhbHVlIC0gcHJldlZhbHVlKSkgLyBNYXRoLm1heChzbW9vdGhpbmcsIGR1cmF0aW9uKSk7XG5cbmNvbnN0IHNtb290aCA9IChzdHJlbmd0aCA9IDUwKSA9PiB7XG4gICAgbGV0IHByZXZpb3VzVmFsdWUgPSAwO1xuICAgIGxldCBsYXN0VXBkYXRlZCA9IDA7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRGcmFtZXN0YW1wID0gc3luYy5nZXRGcmFtZURhdGEoKS50aW1lc3RhbXA7XG4gICAgICAgIGNvbnN0IHRpbWVEZWx0YSA9IGN1cnJlbnRGcmFtZXN0YW1wICE9PSBsYXN0VXBkYXRlZCA/IGN1cnJlbnRGcmFtZXN0YW1wIC0gbGFzdFVwZGF0ZWQgOiAwO1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRpbWVEZWx0YVxuICAgICAgICAgICAgPyBzbW9vdGhGcmFtZShwcmV2aW91c1ZhbHVlLCB2LCB0aW1lRGVsdGEsIHN0cmVuZ3RoKVxuICAgICAgICAgICAgOiBwcmV2aW91c1ZhbHVlO1xuICAgICAgICBsYXN0VXBkYXRlZCA9IGN1cnJlbnRGcmFtZXN0YW1wO1xuICAgICAgICBwcmV2aW91c1ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgICB9O1xufTtcblxuY29uc3Qgc25hcCA9IChwb2ludHMpID0+IHtcbiAgICBpZiAodHlwZW9mIHBvaW50cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuICh2KSA9PiBNYXRoLnJvdW5kKHYgLyBwb2ludHMpICogcG9pbnRzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBudW1Qb2ludHMgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgICAgIGxldCBsYXN0RGlzdGFuY2UgPSBNYXRoLmFicyhwb2ludHNbMF0gLSB2KTtcbiAgICAgICAgICAgIGZvciAoaSA9IDE7IGkgPCBudW1Qb2ludHM7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMocG9pbnQgLSB2KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBsYXN0RGlzdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwb2ludHNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSBudW1Qb2ludHMgLSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgICAgICAgICAgbGFzdERpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufTtcblxuZnVuY3Rpb24gdmVsb2NpdHlQZXJGcmFtZSh4cHMsIGZyYW1lRHVyYXRpb24pIHtcbiAgICByZXR1cm4geHBzIC8gKDEwMDAgLyBmcmFtZUR1cmF0aW9uKTtcbn1cblxuY29uc3Qgd3JhcCA9IChtaW4sIG1heCwgdikgPT4ge1xuICAgIGNvbnN0IHJhbmdlU2l6ZSA9IG1heCAtIG1pbjtcbiAgICByZXR1cm4gKCgoKHYgLSBtaW4pICUgcmFuZ2VTaXplKSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUpICsgbWluO1xufTtcblxuY29uc3QgYSA9IChhMSwgYTIpID0+IDEuMCAtIDMuMCAqIGEyICsgMy4wICogYTE7XG5jb25zdCBiID0gKGExLCBhMikgPT4gMy4wICogYTIgLSA2LjAgKiBhMTtcbmNvbnN0IGMgPSAoYTEpID0+IDMuMCAqIGExO1xuY29uc3QgY2FsY0JlemllciA9ICh0LCBhMSwgYTIpID0+ICgoYShhMSwgYTIpICogdCArIGIoYTEsIGEyKSkgKiB0ICsgYyhhMSkpICogdDtcbmNvbnN0IGdldFNsb3BlID0gKHQsIGExLCBhMikgPT4gMy4wICogYShhMSwgYTIpICogdCAqIHQgKyAyLjAgKiBiKGExLCBhMikgKiB0ICsgYyhhMSk7XG5jb25zdCBzdWJkaXZpc2lvblByZWNpc2lvbiA9IDAuMDAwMDAwMTtcbmNvbnN0IHN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyA9IDEwO1xuZnVuY3Rpb24gYmluYXJ5U3ViZGl2aWRlKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gICAgbGV0IGN1cnJlbnRYO1xuICAgIGxldCBjdXJyZW50VDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZG8ge1xuICAgICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICAgIGFCID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhQSA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoTWF0aC5hYnMoY3VycmVudFgpID4gc3ViZGl2aXNpb25QcmVjaXNpb24gJiZcbiAgICAgICAgKytpIDwgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zKTtcbiAgICByZXR1cm4gY3VycmVudFQ7XG59XG5jb25zdCBuZXd0b25JdGVyYXRpb25zID0gODtcbmNvbnN0IG5ld3Rvbk1pblNsb3BlID0gMC4wMDE7XG5mdW5jdGlvbiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgYUd1ZXNzVCwgbVgxLCBtWDIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld3Rvbkl0ZXJhdGlvbnM7ICsraSkge1xuICAgICAgICBjb25zdCBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICAgICAgICAgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFggPSBjYWxjQmV6aWVyKGFHdWVzc1QsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuICAgIH1cbiAgICByZXR1cm4gYUd1ZXNzVDtcbn1cbmNvbnN0IGtTcGxpbmVUYWJsZVNpemUgPSAxMTtcbmNvbnN0IGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcbmZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIGlmIChtWDEgPT09IG1ZMSAmJiBtWDIgPT09IG1ZMilcbiAgICAgICAgcmV0dXJuIGxpbmVhcjtcbiAgICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga1NwbGluZVRhYmxlU2l6ZTsgKytpKSB7XG4gICAgICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRURm9yWChhWCkge1xuICAgICAgICBsZXQgaW50ZXJ2YWxTdGFydCA9IDAuMDtcbiAgICAgICAgbGV0IGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgICAgICBjb25zdCBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG4gICAgICAgIGZvciAoOyBjdXJyZW50U2FtcGxlICE9PSBsYXN0U2FtcGxlICYmIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgICAgICBpbnRlcnZhbFN0YXJ0ICs9IGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICAtLWN1cnJlbnRTYW1wbGU7XG4gICAgICAgIGNvbnN0IGRpc3QgPSAoYVggLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC9cbiAgICAgICAgICAgIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICAgICAgY29uc3QgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IG5ld3Rvbk1pblNsb3BlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluaXRpYWxTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3Vlc3NGb3JUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAodCkgPT4gdCA9PT0gMCB8fCB0ID09PSAxID8gdCA6IGNhbGNCZXppZXIoZ2V0VEZvclgodCksIG1ZMSwgbVkyKTtcbn1cblxuY29uc3Qgc3RlcHMgPSAoc3RlcHMsIGRpcmVjdGlvbiA9ICdlbmQnKSA9PiAocHJvZ3Jlc3MpID0+IHtcbiAgICBwcm9ncmVzcyA9XG4gICAgICAgIGRpcmVjdGlvbiA9PT0gJ2VuZCcgPyBNYXRoLm1pbihwcm9ncmVzcywgMC45OTkpIDogTWF0aC5tYXgocHJvZ3Jlc3MsIDAuMDAxKTtcbiAgICBjb25zdCBleHBhbmRlZCA9IHByb2dyZXNzICogc3RlcHM7XG4gICAgY29uc3Qgcm91bmRlZCA9IGRpcmVjdGlvbiA9PT0gJ2VuZCcgPyBNYXRoLmZsb29yKGV4cGFuZGVkKSA6IE1hdGguY2VpbChleHBhbmRlZCk7XG4gICAgcmV0dXJuIGNsYW1wKDAsIDEsIHJvdW5kZWQgLyBzdGVwcyk7XG59O1xuXG5leHBvcnRzLmFuZ2xlID0gYW5nbGU7XG5leHBvcnRzLmFuaW1hdGUgPSBhbmltYXRlO1xuZXhwb3J0cy5hbnRpY2lwYXRlID0gYW50aWNpcGF0ZTtcbmV4cG9ydHMuYXBwbHlPZmZzZXQgPSBhcHBseU9mZnNldDtcbmV4cG9ydHMuYXR0cmFjdCA9IGF0dHJhY3Q7XG5leHBvcnRzLmF0dHJhY3RFeHBvID0gYXR0cmFjdEV4cG87XG5leHBvcnRzLmJhY2tJbiA9IGJhY2tJbjtcbmV4cG9ydHMuYmFja0luT3V0ID0gYmFja0luT3V0O1xuZXhwb3J0cy5iYWNrT3V0ID0gYmFja091dDtcbmV4cG9ydHMuYm91bmNlSW4gPSBib3VuY2VJbjtcbmV4cG9ydHMuYm91bmNlSW5PdXQgPSBib3VuY2VJbk91dDtcbmV4cG9ydHMuYm91bmNlT3V0ID0gYm91bmNlT3V0O1xuZXhwb3J0cy5jaXJjSW4gPSBjaXJjSW47XG5leHBvcnRzLmNpcmNJbk91dCA9IGNpcmNJbk91dDtcbmV4cG9ydHMuY2lyY091dCA9IGNpcmNPdXQ7XG5leHBvcnRzLmNsYW1wID0gY2xhbXA7XG5leHBvcnRzLmNyZWF0ZUFudGljaXBhdGUgPSBjcmVhdGVBbnRpY2lwYXRlO1xuZXhwb3J0cy5jcmVhdGVBdHRyYWN0b3IgPSBjcmVhdGVBdHRyYWN0b3I7XG5leHBvcnRzLmNyZWF0ZUJhY2tJbiA9IGNyZWF0ZUJhY2tJbjtcbmV4cG9ydHMuY3JlYXRlRXhwb0luID0gY3JlYXRlRXhwb0luO1xuZXhwb3J0cy5jdWJpY0JlemllciA9IGN1YmljQmV6aWVyO1xuZXhwb3J0cy5kZWNheSA9IGRlY2F5O1xuZXhwb3J0cy5kZWdyZWVzVG9SYWRpYW5zID0gZGVncmVlc1RvUmFkaWFucztcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZWFzZUluID0gZWFzZUluO1xuZXhwb3J0cy5lYXNlSW5PdXQgPSBlYXNlSW5PdXQ7XG5leHBvcnRzLmVhc2VPdXQgPSBlYXNlT3V0O1xuZXhwb3J0cy5pbmVydGlhID0gaW5lcnRpYTtcbmV4cG9ydHMuaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcbmV4cG9ydHMuaXNQb2ludCA9IGlzUG9pbnQ7XG5leHBvcnRzLmlzUG9pbnQzRCA9IGlzUG9pbnQzRDtcbmV4cG9ydHMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuZXhwb3J0cy5saW5lYXIgPSBsaW5lYXI7XG5leHBvcnRzLm1pcnJvckVhc2luZyA9IG1pcnJvckVhc2luZztcbmV4cG9ydHMubWl4ID0gbWl4O1xuZXhwb3J0cy5taXhDb2xvciA9IG1peENvbG9yO1xuZXhwb3J0cy5taXhDb21wbGV4ID0gbWl4Q29tcGxleDtcbmV4cG9ydHMucGlwZSA9IHBpcGU7XG5leHBvcnRzLnBvaW50RnJvbVZlY3RvciA9IHBvaW50RnJvbVZlY3RvcjtcbmV4cG9ydHMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbmV4cG9ydHMucmFkaWFuc1RvRGVncmVlcyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG5leHBvcnRzLnJldmVyc2VFYXNpbmcgPSByZXZlcnNlRWFzaW5nO1xuZXhwb3J0cy5zbW9vdGggPSBzbW9vdGg7XG5leHBvcnRzLnNtb290aEZyYW1lID0gc21vb3RoRnJhbWU7XG5leHBvcnRzLnNuYXAgPSBzbmFwO1xuZXhwb3J0cy5zcHJpbmcgPSBzcHJpbmc7XG5leHBvcnRzLnN0ZXBzID0gc3RlcHM7XG5leHBvcnRzLnRvRGVjaW1hbCA9IHRvRGVjaW1hbDtcbmV4cG9ydHMudmVsb2NpdHlQZXJGcmFtZSA9IHZlbG9jaXR5UGVyRnJhbWU7XG5leHBvcnRzLnZlbG9jaXR5UGVyU2Vjb25kID0gdmVsb2NpdHlQZXJTZWNvbmQ7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwidHNsaWIiLCJyZXF1aXJlIiwiaGV5TGlzdGVuIiwic3R5bGVWYWx1ZVR5cGVzIiwic3luYyIsIl9pbnRlcm9wRGVmYXVsdExlZ2FjeSIsImUiLCJzeW5jX19kZWZhdWx0IiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJ2IiwiTWF0aCIsInNhZmVNaW4iLCJtaW5EdXJhdGlvbiIsIm1heER1cmF0aW9uIiwibWluRGFtcGluZyIsIm1heERhbXBpbmciLCJmaW5kU3ByaW5nIiwiZHVyYXRpb24iLCJib3VuY2UiLCJ2ZWxvY2l0eSIsIm1hc3MiLCJlbnZlbG9wZSIsImRlcml2YXRpdmUiLCJ3YXJuaW5nIiwiZGFtcGluZ1JhdGlvIiwidW5kYW1wZWRGcmVxIiwiZXhwb25lbnRpYWxEZWNheSIsImRlbHRhIiwiYSIsImIiLCJjYWxjQW5ndWxhckZyZXEiLCJjIiwiZXhwIiwiZCIsInBvdyIsImYiLCJnIiwiZmFjdG9yIiwiaW5pdGlhbEd1ZXNzIiwiYXBwcm94aW1hdGVSb290IiwiaXNOYU4iLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwic3FydCIsInJvb3RJdGVyYXRpb25zIiwicmVzdWx0IiwiaSIsImR1cmF0aW9uS2V5cyIsInBoeXNpY3NLZXlzIiwiaXNTcHJpbmdUeXBlIiwib3B0aW9ucyIsImtleXMiLCJzb21lIiwia2V5IiwidW5kZWZpbmVkIiwiZ2V0U3ByaW5nT3B0aW9ucyIsInNwcmluZ09wdGlvbnMiLCJhc3NpZ24iLCJpc1Jlc29sdmVkRnJvbUR1cmF0aW9uIiwiZGVyaXZlZCIsInNwcmluZyIsIl9hIiwiZnJvbSIsInRvIiwicmVzdFNwZWVkIiwicmVzdERlbHRhIiwiX19yZXN0Iiwic3RhdGUiLCJkb25lIiwicmVzb2x2ZVNwcmluZyIsInplcm8iLCJyZXNvbHZlVmVsb2NpdHkiLCJjcmVhdGVTcHJpbmciLCJpbml0aWFsVmVsb2NpdHkiLCJpbml0aWFsRGVsdGEiLCJ1bmRhbXBlZEFuZ3VsYXJGcmVxIiwiYWJzIiwiYW5ndWxhckZyZXEiLCJ0Iiwic2luIiwiY29zIiwiZGFtcGVkQW5ndWxhckZyZXEiLCJmcmVxRm9yVCIsInNpbmgiLCJjb3NoIiwibmV4dCIsImN1cnJlbnQiLCJjdXJyZW50VmVsb2NpdHkiLCJpc0JlbG93VmVsb2NpdHlUaHJlc2hvbGQiLCJpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkIiwiZmxpcFRhcmdldCIsIm5lZWRzSW50ZXJwb2xhdGlvbiIsIl90IiwicHJvZ3Jlc3MiLCJ0b0Zyb21EaWZmZXJlbmNlIiwibWl4IiwiaHVlVG9SZ2IiLCJwIiwicSIsImhzbGFUb1JnYmEiLCJodWUiLCJzYXR1cmF0aW9uIiwibGlnaHRuZXNzIiwiYWxwaGEiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJyb3VuZCIsIm1peExpbmVhckNvbG9yIiwiZnJvbUV4cG8iLCJ0b0V4cG8iLCJjb2xvclR5cGVzIiwiaGV4IiwicmdiYSIsImhzbGEiLCJnZXRDb2xvclR5cGUiLCJmaW5kIiwidHlwZSIsInRlc3QiLCJub3RBbmltYXRhYmxlIiwiY29sb3IiLCJtaXhDb2xvciIsImZyb21Db2xvclR5cGUiLCJ0b0NvbG9yVHlwZSIsImludmFyaWFudCIsImZyb21Db2xvciIsInBhcnNlIiwidG9Db2xvciIsImJsZW5kZWQiLCJ0cmFuc2Zvcm0iLCJ6ZXJvUG9pbnQiLCJ4IiwieSIsInoiLCJpc051bSIsImNvbWJpbmVGdW5jdGlvbnMiLCJwaXBlIiwidHJhbnNmb3JtZXJzIiwicmVkdWNlIiwiZ2V0TWl4ZXIiLCJvcmlnaW4iLCJ0YXJnZXQiLCJtaXhDb21wbGV4IiwibWl4QXJyYXkiLCJvdXRwdXQiLCJudW1WYWx1ZXMiLCJsZW5ndGgiLCJibGVuZFZhbHVlIiwibWFwIiwiZnJvbVRoaXMiLCJtaXhPYmplY3QiLCJhbmFseXNlIiwicGFyc2VkIiwiY29tcGxleCIsIm51bU51bWJlcnMiLCJudW1SR0IiLCJudW1IU0wiLCJ0ZW1wbGF0ZSIsImNyZWF0ZVRyYW5zZm9ybWVyIiwib3JpZ2luU3RhdHMiLCJ0YXJnZXRTdGF0cyIsImNhbkludGVycG9sYXRlIiwibWl4TnVtYmVyIiwiZGV0ZWN0TWl4ZXJGYWN0b3J5IiwiQXJyYXkiLCJpc0FycmF5IiwiY3JlYXRlTWl4ZXJzIiwiZWFzZSIsImN1c3RvbU1peGVyIiwibWl4ZXJzIiwibWl4ZXJGYWN0b3J5IiwibnVtTWl4ZXJzIiwibWl4ZXIiLCJlYXNpbmdGdW5jdGlvbiIsInB1c2giLCJmYXN0SW50ZXJwb2xhdGUiLCJzbG93SW50ZXJwb2xhdGUiLCJpbnB1dCIsImlucHV0TGVuZ3RoIiwibGFzdElucHV0SW5kZXgiLCJtaXhlckluZGV4IiwiZm91bmRNaXhlckluZGV4IiwicHJvZ3Jlc3NJblJhbmdlIiwiaW50ZXJwb2xhdGUiLCJpc0NsYW1wIiwiY29uY2F0IiwicmV2ZXJzZSIsImludGVycG9sYXRvciIsInJldmVyc2VFYXNpbmciLCJlYXNpbmciLCJtaXJyb3JFYXNpbmciLCJjcmVhdGVFeHBvSW4iLCJwb3dlciIsImNyZWF0ZUJhY2tJbiIsImNyZWF0ZUFudGljaXBhdGUiLCJiYWNrRWFzaW5nIiwiREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgiLCJCT1VOQ0VfRklSU1RfVEhSRVNIT0xEIiwiQk9VTkNFX1NFQ09ORF9USFJFU0hPTEQiLCJCT1VOQ0VfVEhJUkRfVEhSRVNIT0xEIiwibGluZWFyIiwiZWFzZUluIiwiZWFzZU91dCIsImVhc2VJbk91dCIsImNpcmNJbiIsImFjb3MiLCJjaXJjT3V0IiwiY2lyY0luT3V0IiwiYmFja0luIiwiYmFja091dCIsImJhY2tJbk91dCIsImFudGljaXBhdGUiLCJjYSIsImNiIiwiY2MiLCJib3VuY2VPdXQiLCJwMiIsImJvdW5jZUluIiwiYm91bmNlSW5PdXQiLCJkZWZhdWx0RWFzaW5nIiwidmFsdWVzIiwic3BsaWNlIiwiZGVmYXVsdE9mZnNldCIsIl92YWx1ZSIsImNvbnZlcnRPZmZzZXRUb1RpbWVzIiwib2Zmc2V0IiwibyIsImtleWZyYW1lcyIsInRpbWVzIiwiY3JlYXRlSW50ZXJwb2xhdG9yIiwiZGVjYXkiLCJ0aW1lQ29uc3RhbnQiLCJtb2RpZnlUYXJnZXQiLCJhbXBsaXR1ZGUiLCJpZGVhbCIsInR5cGVzIiwiZGV0ZWN0QW5pbWF0aW9uRnJvbU9wdGlvbnMiLCJjb25maWciLCJTZXQiLCJoYXMiLCJsb29wRWxhcHNlZCIsImVsYXBzZWQiLCJkZWxheSIsInJldmVyc2VFbGFwc2VkIiwiaXNGb3J3YXJkUGxheWJhY2siLCJoYXNSZXBlYXREZWxheUVsYXBzZWQiLCJmcmFtZXN5bmMiLCJ1cGRhdGUiLCJwYXNzVGltZXN0YW1wIiwic3RhcnQiLCJzdG9wIiwiY2FuY2VsU3luYyIsImFuaW1hdGUiLCJfYiIsIl9jIiwiYXV0b3BsYXkiLCJkcml2ZXIiLCJyZXBlYXQiLCJyZXBlYXRNYXgiLCJyZXBlYXRUeXBlIiwicmVwZWF0RGVsYXkiLCJvblBsYXkiLCJvblN0b3AiLCJvbkNvbXBsZXRlIiwib25SZXBlYXQiLCJvblVwZGF0ZSIsImRyaXZlckNvbnRyb2xzIiwicmVwZWF0Q291bnQiLCJjb21wdXRlZER1cmF0aW9uIiwibGF0ZXN0IiwiaXNDb21wbGV0ZSIsImludGVycG9sYXRlRnJvbU51bWJlciIsImFuaW1hdG9yIiwiY2FsbCIsImFuaW1hdGlvbiIsImNvbXBsZXRlIiwicGxheSIsInZlbG9jaXR5UGVyU2Vjb25kIiwiZnJhbWVEdXJhdGlvbiIsImluZXJ0aWEiLCJib3VuY2VTdGlmZm5lc3MiLCJib3VuY2VEYW1waW5nIiwiY3VycmVudEFuaW1hdGlvbiIsImlzT3V0T2ZCb3VuZHMiLCJib3VuZGFyeU5lYXJlc3QiLCJzdGFydEFuaW1hdGlvbiIsInN0YXJ0U3ByaW5nIiwiYm91bmRhcnkiLCJoZWFkaW5nIiwicHJldiIsImNoZWNrQm91bmRhcnkiLCJnZXRGcmFtZURhdGEiLCJyYWRpYW5zVG9EZWdyZWVzIiwicmFkaWFucyIsIlBJIiwiYW5nbGUiLCJhdGFuMiIsImFwcGx5T2Zmc2V0IiwiaGFzUmVjZWl2ZWRGcm9tIiwiaWRlbnRpdHkiLCJjcmVhdGVBdHRyYWN0b3IiLCJhbHRlckRpc3BsYWNlbWVudCIsImNvbnN0YW50IiwiZGlzcGxhY2VtZW50Iiwic3ByaW5nTW9kaWZpZWREaXNwbGFjZW1lbnQiLCJhdHRyYWN0IiwiYXR0cmFjdEV4cG8iLCJkZWdyZWVzVG9SYWRpYW5zIiwiZGVncmVlcyIsImlzUG9pbnQiLCJwb2ludCIsImhhc093blByb3BlcnR5IiwiaXNQb2ludDNEIiwiZGlzdGFuY2UxRCIsImRpc3RhbmNlIiwieERlbHRhIiwieURlbHRhIiwiekRlbHRhIiwicG9pbnRGcm9tVmVjdG9yIiwidG9EZWNpbWFsIiwibnVtIiwicHJlY2lzaW9uIiwic21vb3RoRnJhbWUiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJzbW9vdGhpbmciLCJzbW9vdGgiLCJzdHJlbmd0aCIsInByZXZpb3VzVmFsdWUiLCJsYXN0VXBkYXRlZCIsImN1cnJlbnRGcmFtZXN0YW1wIiwidGltZXN0YW1wIiwidGltZURlbHRhIiwibmV3VmFsdWUiLCJzbmFwIiwicG9pbnRzIiwibnVtUG9pbnRzIiwibGFzdERpc3RhbmNlIiwidmVsb2NpdHlQZXJGcmFtZSIsInhwcyIsIndyYXAiLCJyYW5nZVNpemUiLCJhMSIsImEyIiwiY2FsY0JlemllciIsImdldFNsb3BlIiwic3ViZGl2aXNpb25QcmVjaXNpb24iLCJzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwibmV3dG9uSXRlcmF0aW9ucyIsIm5ld3Rvbk1pblNsb3BlIiwibmV3dG9uUmFwaHNvbkl0ZXJhdGUiLCJhR3Vlc3NUIiwiY3VycmVudFNsb3BlIiwia1NwbGluZVRhYmxlU2l6ZSIsImtTYW1wbGVTdGVwU2l6ZSIsImN1YmljQmV6aWVyIiwibVkxIiwibVkyIiwic2FtcGxlVmFsdWVzIiwiRmxvYXQzMkFycmF5IiwiZ2V0VEZvclgiLCJpbnRlcnZhbFN0YXJ0IiwiY3VycmVudFNhbXBsZSIsImxhc3RTYW1wbGUiLCJkaXN0IiwiZ3Vlc3NGb3JUIiwiaW5pdGlhbFNsb3BlIiwic3RlcHMiLCJkaXJlY3Rpb24iLCJleHBhbmRlZCIsInJvdW5kZWQiLCJmbG9vciIsImNlaWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/popmotion/dist/popmotion.cjs.js\n");

/***/ })

};
;