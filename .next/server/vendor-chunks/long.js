/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/long";
exports.ids = ["vendor-chunks/long"];
exports.modules = {

/***/ "(rsc)/./node_modules/long/umd/index.js":
/*!****************************************!*\
  !*** ./node_modules/long/umd/index.js ***!
  \****************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// GENERATED FILE. DO NOT EDIT.\nvar Long = function(exports1) {\n    \"use strict\";\n    Object.defineProperty(exports1, \"__esModule\", {\n        value: true\n    });\n    exports1.default = void 0;\n    /**\n   * @license\n   * Copyright 2009 The Closure Library Authors\n   * Copyright 2020 Daniel Wirtz / The long.js Authors.\n   *\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   *\n   *     http://www.apache.org/licenses/LICENSE-2.0\n   *\n   * Unless required by applicable law or agreed to in writing, software\n   * distributed under the License is distributed on an \"AS IS\" BASIS,\n   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   * See the License for the specific language governing permissions and\n   * limitations under the License.\n   *\n   * SPDX-License-Identifier: Apache-2.0\n   */ // WebAssembly optimizations to do native i64 multiplication and divide\n    var wasm = null;\n    try {\n        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n            0,\n            97,\n            115,\n            109,\n            1,\n            0,\n            0,\n            0,\n            1,\n            13,\n            2,\n            96,\n            0,\n            1,\n            127,\n            96,\n            4,\n            127,\n            127,\n            127,\n            127,\n            1,\n            127,\n            3,\n            7,\n            6,\n            0,\n            1,\n            1,\n            1,\n            1,\n            1,\n            6,\n            6,\n            1,\n            127,\n            1,\n            65,\n            0,\n            11,\n            7,\n            50,\n            6,\n            3,\n            109,\n            117,\n            108,\n            0,\n            1,\n            5,\n            100,\n            105,\n            118,\n            95,\n            115,\n            0,\n            2,\n            5,\n            100,\n            105,\n            118,\n            95,\n            117,\n            0,\n            3,\n            5,\n            114,\n            101,\n            109,\n            95,\n            115,\n            0,\n            4,\n            5,\n            114,\n            101,\n            109,\n            95,\n            117,\n            0,\n            5,\n            8,\n            103,\n            101,\n            116,\n            95,\n            104,\n            105,\n            103,\n            104,\n            0,\n            0,\n            10,\n            191,\n            1,\n            6,\n            4,\n            0,\n            35,\n            0,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            126,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            127,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            128,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            129,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            130,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11\n        ])), {}).exports;\n    } catch (e) {}\n    /**\n   * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n   *  See the from* functions below for more convenient ways of constructing Longs.\n   * @exports Long\n   * @class A Long class for representing a 64 bit two's-complement integer value.\n   * @param {number} low The low (signed) 32 bits of the long\n   * @param {number} high The high (signed) 32 bits of the long\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @constructor\n   */ function Long(low, high, unsigned) {\n        /**\n     * The low 32 bits as a signed value.\n     * @type {number}\n     */ this.low = low | 0;\n        /**\n     * The high 32 bits as a signed value.\n     * @type {number}\n     */ this.high = high | 0;\n        /**\n     * Whether unsigned or not.\n     * @type {boolean}\n     */ this.unsigned = !!unsigned;\n    } // The internal representation of a long is the two given signed, 32-bit values.\n    // We use 32-bit pieces because these are the size of integers on which\n    // Javascript performs bit-operations.  For operations like addition and\n    // multiplication, we split each number into 16 bit pieces, which can easily be\n    // multiplied within Javascript's floating-point representation without overflow\n    // or change in sign.\n    //\n    // In the algorithms below, we frequently reduce the negative case to the\n    // positive case by negating the input(s) and then post-processing the result.\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n    // a positive number, it overflows back into a negative).  Not handling this\n    // case would often result in infinite recursion.\n    //\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n    // methods on which they depend.\n    /**\n   * An indicator used to reliably determine if an object is a Long or not.\n   * @type {boolean}\n   * @const\n   * @private\n   */ Long.prototype.__isLong__;\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\n        value: true\n    });\n    /**\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   * @inner\n   */ function isLong(obj) {\n        return (obj && obj[\"__isLong__\"]) === true;\n    }\n    /**\n   * @function\n   * @param {*} value number\n   * @returns {number}\n   * @inner\n   */ function ctz32(value) {\n        var c = Math.clz32(value & -value);\n        return value ? 31 - c : c;\n    }\n    /**\n   * Tests if the specified object is a Long.\n   * @function\n   * @param {*} obj Object\n   * @returns {boolean}\n   */ Long.isLong = isLong;\n    /**\n   * A cache of the Long representations of small integer values.\n   * @type {!Object}\n   * @inner\n   */ var INT_CACHE = {};\n    /**\n   * A cache of the Long representations of small unsigned integer values.\n   * @type {!Object}\n   * @inner\n   */ var UINT_CACHE = {};\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromInt(value, unsigned) {\n        var obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    /**\n   * Returns a Long representing the given 32 bit integer value.\n   * @function\n   * @param {number} value The 32 bit integer in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromInt = fromInt;\n    /**\n   * @param {number} value\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? UZERO : ZERO;\n        if (unsigned) {\n            if (value < 0) return UZERO;\n            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n        }\n        if (value < 0) return fromNumber(-value, unsigned).neg();\n        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    /**\n   * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n   * @function\n   * @param {number} value The number in question\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromNumber = fromNumber;\n    /**\n   * @param {number} lowBits\n   * @param {number} highBits\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    /**\n   * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n   *  assumed to use 32 bits.\n   * @function\n   * @param {number} lowBits The low 32 bits\n   * @param {number} highBits The high 32 bits\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromBits = fromBits;\n    /**\n   * @function\n   * @param {number} base\n   * @param {number} exponent\n   * @returns {number}\n   * @inner\n   */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n    /**\n   * @param {string} str\n   * @param {(boolean|number)=} unsigned\n   * @param {number=} radix\n   * @returns {!Long}\n   * @inner\n   */ function fromString(str, unsigned, radix) {\n        if (str.length === 0) throw Error(\"empty string\");\n        if (typeof unsigned === \"number\") {\n            // For goog.math.long compatibility\n            radix = unsigned;\n            unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        var p;\n        if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n        else if (p === 0) {\n            return fromString(str.substring(1), unsigned, radix).neg();\n        } // Do several (8) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\n        var result = ZERO;\n        for(var i = 0; i < str.length; i += 8){\n            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                var power = fromNumber(pow_dbl(radix, size));\n                result = result.mul(power).add(fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    /**\n   * Returns a Long representation of the given string, written using the specified radix.\n   * @function\n   * @param {string} str The textual representation of the Long\n   * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n   * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n   * @returns {!Long} The corresponding Long value\n   */ Long.fromString = fromString;\n    /**\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n   * @param {boolean=} unsigned\n   * @returns {!Long}\n   * @inner\n   */ function fromValue(val, unsigned) {\n        if (typeof val === \"number\") return fromNumber(val, unsigned);\n        if (typeof val === \"string\") return fromString(val, unsigned); // Throws for non-objects, converts non-instanceof Long:\n        return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    /**\n   * Converts the specified value to a Long using the appropriate from* function for its type.\n   * @function\n   * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {!Long}\n   */ Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n    // no runtime penalty for these.\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_16_DBL = 1 << 16;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_24_DBL = 1 << 24;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    /**\n   * @type {number}\n   * @const\n   * @inner\n   */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    /**\n   * @type {!Long}\n   * @const\n   * @inner\n   */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ZERO = fromInt(0);\n    /**\n   * Signed zero.\n   * @type {!Long}\n   */ Long.ZERO = ZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UZERO = fromInt(0, true);\n    /**\n   * Unsigned zero.\n   * @type {!Long}\n   */ Long.UZERO = UZERO;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var ONE = fromInt(1);\n    /**\n   * Signed one.\n   * @type {!Long}\n   */ Long.ONE = ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var UONE = fromInt(1, true);\n    /**\n   * Unsigned one.\n   * @type {!Long}\n   */ Long.UONE = UONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var NEG_ONE = fromInt(-1);\n    /**\n   * Signed negative one.\n   * @type {!Long}\n   */ Long.NEG_ONE = NEG_ONE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n    /**\n   * Maximum signed value.\n   * @type {!Long}\n   */ Long.MAX_VALUE = MAX_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n    /**\n   * Maximum unsigned value.\n   * @type {!Long}\n   */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    /**\n   * @type {!Long}\n   * @inner\n   */ var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n    /**\n   * Minimum signed value.\n   * @type {!Long}\n   */ Long.MIN_VALUE = MIN_VALUE;\n    /**\n   * @alias Long.prototype\n   * @inner\n   */ var LongPrototype = Long.prototype;\n    /**\n   * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toInt = function toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    /**\n   * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.toNumber = function toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    /**\n   * Converts the Long to a string written in the specified radix.\n   * @this {!Long}\n   * @param {number=} radix Radix (2-36), defaults to 10\n   * @returns {string}\n   * @override\n   * @throws {RangeError} If `radix` is out of range\n   */ LongPrototype.toString = function toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            // Unsigned Longs are never negative\n            if (this.eq(MIN_VALUE)) {\n                // We need to change the Long value before it can be negated, so we remove\n                // the bottom-most digit in this base and then recurse to do the rest.\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        } // Do several (6) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n        var result = \"\";\n        while(true){\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) return digits + result;\n            else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    };\n    /**\n   * Gets the high 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed high bits\n   */ LongPrototype.getHighBits = function getHighBits() {\n        return this.high;\n    };\n    /**\n   * Gets the high 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned high bits\n   */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n        return this.high >>> 0;\n    };\n    /**\n   * Gets the low 32 bits as a signed integer.\n   * @this {!Long}\n   * @returns {number} Signed low bits\n   */ LongPrototype.getLowBits = function getLowBits() {\n        return this.low;\n    };\n    /**\n   * Gets the low 32 bits as an unsigned integer.\n   * @this {!Long}\n   * @returns {number} Unsigned low bits\n   */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n        return this.low >>> 0;\n    };\n    /**\n   * Gets the number of bits needed to represent the absolute value of this Long.\n   * @this {!Long}\n   * @returns {number}\n   */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n        if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        var val = this.high != 0 ? this.high : this.low;\n        for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;\n        return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    /**\n   * Tests if this Long's value equals zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isZero = function isZero() {\n        return this.high === 0 && this.low === 0;\n    };\n    /**\n   * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n   * @returns {boolean}\n   */ LongPrototype.eqz = LongPrototype.isZero;\n    /**\n   * Tests if this Long's value is negative.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isNegative = function isNegative() {\n        return !this.unsigned && this.high < 0;\n    };\n    /**\n   * Tests if this Long's value is positive or zero.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isPositive = function isPositive() {\n        return this.unsigned || this.high >= 0;\n    };\n    /**\n   * Tests if this Long's value is odd.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isOdd = function isOdd() {\n        return (this.low & 1) === 1;\n    };\n    /**\n   * Tests if this Long's value is even.\n   * @this {!Long}\n   * @returns {boolean}\n   */ LongPrototype.isEven = function isEven() {\n        return (this.low & 1) === 0;\n    };\n    /**\n   * Tests if this Long's value equals the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.equals = function equals(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    };\n    /**\n   * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.eq = LongPrototype.equals;\n    /**\n   * Tests if this Long's value differs from the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.notEquals = function notEquals(other) {\n        return !this.eq(/* validates */ other);\n    };\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.neq = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ne = LongPrototype.notEquals;\n    /**\n   * Tests if this Long's value is less than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThan = function lessThan(other) {\n        return this.comp(/* validates */ other) < 0;\n    };\n    /**\n   * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lt = LongPrototype.lessThan;\n    /**\n   * Tests if this Long's value is less than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n        return this.comp(/* validates */ other) <= 0;\n    };\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.le = LongPrototype.lessThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThan = function greaterThan(other) {\n        return this.comp(/* validates */ other) > 0;\n    };\n    /**\n   * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gt = LongPrototype.greaterThan;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n        return this.comp(/* validates */ other) >= 0;\n    };\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    /**\n   * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {boolean}\n   */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    /**\n   * Compares this Long's value with the specified's.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.compare = function compare(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.eq(other)) return 0;\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    /**\n   * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n   * @function\n   * @param {!Long|number|string} other Other value\n   * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n   *  if the given one is greater\n   */ LongPrototype.comp = LongPrototype.compare;\n    /**\n   * Negates this Long's value.\n   * @this {!Long}\n   * @returns {!Long} Negated Long\n   */ LongPrototype.negate = function negate() {\n        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n        return this.not().add(ONE);\n    };\n    /**\n   * Negates this Long's value. This is an alias of {@link Long#negate}.\n   * @function\n   * @returns {!Long} Negated Long\n   */ LongPrototype.neg = LongPrototype.negate;\n    /**\n   * Returns the sum of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} addend Addend\n   * @returns {!Long} Sum\n   */ LongPrototype.add = function add(addend) {\n        if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = addend.high >>> 16;\n        var b32 = addend.high & 0xFFFF;\n        var b16 = addend.low >>> 16;\n        var b00 = addend.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 + b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the difference of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.subtract = function subtract(subtrahend) {\n        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    };\n    /**\n   * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n   * @function\n   * @param {!Long|number|string} subtrahend Subtrahend\n   * @returns {!Long} Difference\n   */ LongPrototype.sub = LongPrototype.subtract;\n    /**\n   * Returns the product of this and the specified Long.\n   * @this {!Long}\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.multiply = function multiply(multiplier) {\n        if (this.isZero()) return this;\n        if (!isLong(multiplier)) multiplier = fromValue(multiplier); // use wasm support if present\n        if (wasm) {\n            var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n        // We can skip products that would overflow.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xFFFF;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xFFFF;\n        var b48 = multiplier.high >>> 16;\n        var b32 = multiplier.high & 0xFFFF;\n        var b16 = multiplier.low >>> 16;\n        var b00 = multiplier.low & 0xFFFF;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xFFFF;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xFFFF;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xFFFF;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xFFFF;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n   * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n   * @function\n   * @param {!Long|number|string} multiplier Multiplier\n   * @returns {!Long} Product\n   */ LongPrototype.mul = LongPrototype.multiply;\n    /**\n   * Returns this Long divided by the specified. The result is signed if this Long is signed or\n   *  unsigned if this Long is unsigned.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.divide = function divide(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        if (divisor.isZero()) throw Error(\"division by zero\"); // use wasm support if present\n        if (wasm) {\n            // guard against signed division overflow: the largest\n            // negative number / -1 would be 1 larger than the largest\n            // positive number, due to two's complement.\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                // be consistent with non-wasm code path\n                return this;\n            }\n            var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n        var approx, rem, res;\n        if (!this.unsigned) {\n            // This section is only relevant for signed longs and is derived from the\n            // closure library as a whole.\n            if (this.eq(MIN_VALUE)) {\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n                else if (divisor.eq(MIN_VALUE)) return ONE;\n                else {\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                    var halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(ZERO)) {\n                        return divisor.isNegative() ? ONE : NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = ZERO;\n        } else {\n            // The algorithm below has not been made for unsigned longs. It's therefore\n            // required to take special care of the MSB prior to running it.\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return UZERO;\n            if (divisor.gt(this.shru(1))) return UONE;\n            res = UZERO;\n        } // Repeat the following until the remainder is less than other:  find a\n        // floating-point that approximates remainder / other *from below*, add this\n        // into the result, and subtract it from the remainder.  It is critical that\n        // the approximate value is less than or equal to the real value so that the\n        // remainder never becomes negative.\n        rem = this;\n        while(rem.gte(divisor)){\n            // Approximate the result of division. This may be a little greater or\n            // smaller than the actual value.\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or\n            // the smallest non-fractional digit, whichever is larger.\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note\n            // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            } // We know the answer can't be zero... and actually, zero would cause\n            // infinite recursion since we would make no progress.\n            if (approxRes.isZero()) approxRes = ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    };\n    /**\n   * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Quotient\n   */ LongPrototype.div = LongPrototype.divide;\n    /**\n   * Returns this Long modulo the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.modulo = function modulo(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor); // use wasm support if present\n        if (wasm) {\n            var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    };\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.mod = LongPrototype.modulo;\n    /**\n   * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n   * @function\n   * @param {!Long|number|string} divisor Divisor\n   * @returns {!Long} Remainder\n   */ LongPrototype.rem = LongPrototype.modulo;\n    /**\n   * Returns the bitwise NOT of this Long.\n   * @this {!Long}\n   * @returns {!Long}\n   */ LongPrototype.not = function not() {\n        return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    /**\n   * Returns count leading zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countLeadingZeros = function countLeadingZeros() {\n        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    /**\n   * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.clz = LongPrototype.countLeadingZeros;\n    /**\n   * Returns count trailing zeros of this Long.\n   * @this {!Long}\n   * @returns {!number}\n   */ LongPrototype.countTrailingZeros = function countTrailingZeros() {\n        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n    };\n    /**\n   * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n   * @function\n   * @param {!Long}\n   * @returns {!number}\n   */ LongPrototype.ctz = LongPrototype.countTrailingZeros;\n    /**\n   * Returns the bitwise AND of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.and = function and(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise OR of this Long and the specified.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.or = function or(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    /**\n   * Returns the bitwise XOR of this Long and the given one.\n   * @this {!Long}\n   * @param {!Long|number|string} other Other Long\n   * @returns {!Long}\n   */ LongPrototype.xor = function xor(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftLeft = function shiftLeft(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shl = LongPrototype.shiftLeft;\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRight = function shiftRight(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr = LongPrototype.shiftRight;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Shifted Long\n   */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    /**\n   * Returns this Long with bits rotated to the left by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateLeft = function rotateLeft(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotl = LongPrototype.rotateLeft;\n    /**\n   * Returns this Long with bits rotated to the right by the given amount.\n   * @this {!Long}\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotateRight = function rotateRight(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n    };\n    /**\n   * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n   * @function\n   * @param {number|!Long} numBits Number of bits\n   * @returns {!Long} Rotated Long\n   */ LongPrototype.rotr = LongPrototype.rotateRight;\n    /**\n   * Converts this Long to signed.\n   * @this {!Long}\n   * @returns {!Long} Signed long\n   */ LongPrototype.toSigned = function toSigned() {\n        if (!this.unsigned) return this;\n        return fromBits(this.low, this.high, false);\n    };\n    /**\n   * Converts this Long to unsigned.\n   * @this {!Long}\n   * @returns {!Long} Unsigned long\n   */ LongPrototype.toUnsigned = function toUnsigned() {\n        if (this.unsigned) return this;\n        return fromBits(this.low, this.high, true);\n    };\n    /**\n   * Converts this Long to its byte representation.\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @this {!Long}\n   * @returns {!Array.<number>} Byte representation\n   */ LongPrototype.toBytes = function toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    /**\n   * Converts this Long to its little endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Little endian byte representation\n   */ LongPrototype.toBytesLE = function toBytesLE() {\n        var hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    };\n    /**\n   * Converts this Long to its big endian byte representation.\n   * @this {!Long}\n   * @returns {!Array.<number>} Big endian byte representation\n   */ LongPrototype.toBytesBE = function toBytesBE() {\n        var hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    };\n    /**\n   * Creates a Long from its byte representation.\n   * @param {!Array.<number>} bytes Byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @param {boolean=} le Whether little or big endian, defaults to big endian\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    };\n    /**\n   * Creates a Long from its little endian byte representation.\n   * @param {!Array.<number>} bytes Little endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    /**\n   * Creates a Long from its big endian byte representation.\n   * @param {!Array.<number>} bytes Big endian byte representation\n   * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n   * @returns {Long} The corresponding Long value\n   */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    var _default = Long;\n    exports1.default = _default;\n    return \"default\" in exports1 ? exports1.default : exports1;\n}({});\nif (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n    return Long;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\nelse {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsK0ZBQStCO0FBQy9CLElBQUlBLE9BQU8sU0FBVUMsUUFBTztJQUMxQjtJQUVBQyxPQUFPQyxjQUFjLENBQUNGLFVBQVMsY0FBYztRQUMzQ0csT0FBTztJQUNUO0lBQ0FILFNBQVFJLE9BQU8sR0FBRyxLQUFLO0lBRXZCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkMsR0FDRCx1RUFBdUU7SUFDdkUsSUFBSUMsT0FBTztJQUVYLElBQUk7UUFDRkEsT0FBTyxJQUFJQyxZQUFZQyxRQUFRLENBQUMsSUFBSUQsWUFBWUUsTUFBTSxDQUFDLElBQUlDLFdBQVc7WUFBQztZQUFHO1lBQUk7WUFBSztZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSztZQUFHO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSztZQUFHO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSztZQUFHO1lBQUc7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUs7WUFBRztZQUFHO1lBQUc7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSztZQUFHO1lBQUc7WUFBSTtZQUFLO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBSTtZQUFHO1lBQUk7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBRztZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFHO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUc7WUFBSztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFJO1lBQUc7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUc7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBRztZQUFLO1lBQUk7WUFBSTtZQUFLO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFHO1lBQUs7WUFBSTtZQUFJO1lBQUs7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUk7WUFBSztZQUFLO1lBQUk7WUFBRztZQUFJO1lBQUc7WUFBSztTQUFHLElBQUksQ0FBQyxHQUFHVCxPQUFPO0lBQ3J0QyxFQUFFLE9B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Q2xELEVBQUcsQ0FBQztBQUNKLElBQUksSUFBMEMsRUFBRW9MLGlDQUFPLEVBQUUsbUNBQUU7SUFBYSxPQUFPckw7QUFBTSxDQUFDO0FBQUEsa0dBQUM7S0FDbEYsRUFBcUZBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYWNlZS1wcm90by1vbmUvLi9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanM/ZGM0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBHRU5FUkFURUQgRklMRS4gRE8gTk9UIEVESVQuXG52YXIgTG9uZyA9IChmdW5jdGlvbihleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuICBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbiAgfSk7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgXG4gIC8qKlxuICAgKiBAbGljZW5zZVxuICAgKiBDb3B5cmlnaHQgMjAwOSBUaGUgQ2xvc3VyZSBMaWJyYXJ5IEF1dGhvcnNcbiAgICogQ29weXJpZ2h0IDIwMjAgRGFuaWVsIFdpcnR6IC8gVGhlIGxvbmcuanMgQXV0aG9ycy5cbiAgICpcbiAgICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICpcbiAgICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICAgKlxuICAgKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gICAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gICAqXG4gICAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gICAqL1xuICAvLyBXZWJBc3NlbWJseSBvcHRpbWl6YXRpb25zIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxuICB2YXIgd2FzbSA9IG51bGw7XG4gIFxuICB0cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xuICB9IGNhdGNoIChlKSB7Ly8gbm8gd2FzbSBzdXBwb3J0IDooXG4gIH1cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gICAqICBTZWUgdGhlIGZyb20qIGZ1bmN0aW9ucyBiZWxvdyBmb3IgbW9yZSBjb252ZW5pZW50IHdheXMgb2YgY29uc3RydWN0aW5nIExvbmdzLlxuICAgKiBAZXhwb3J0cyBMb25nXG4gICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3cgVGhlIGxvdyAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoIFRoZSBoaWdoIChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIFxuICBcbiAgZnVuY3Rpb24gTG9uZyhsb3csIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sb3cgPSBsb3cgfCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgXG4gICAgdGhpcy5oaWdoID0gaGlnaCB8IDA7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB1bnNpZ25lZCBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gIFxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICB9IC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4gIC8vIFdlIHVzZSAzMi1iaXQgcGllY2VzIGJlY2F1c2UgdGhlc2UgYXJlIHRoZSBzaXplIG9mIGludGVnZXJzIG9uIHdoaWNoXG4gIC8vIEphdmFzY3JpcHQgcGVyZm9ybXMgYml0LW9wZXJhdGlvbnMuICBGb3Igb3BlcmF0aW9ucyBsaWtlIGFkZGl0aW9uIGFuZFxuICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4gIC8vIG11bHRpcGxpZWQgd2l0aGluIEphdmFzY3JpcHQncyBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiB3aXRob3V0IG92ZXJmbG93XG4gIC8vIG9yIGNoYW5nZSBpbiBzaWduLlxuICAvL1xuICAvLyBJbiB0aGUgYWxnb3JpdGhtcyBiZWxvdywgd2UgZnJlcXVlbnRseSByZWR1Y2UgdGhlIG5lZ2F0aXZlIGNhc2UgdG8gdGhlXG4gIC8vIHBvc2l0aXZlIGNhc2UgYnkgbmVnYXRpbmcgdGhlIGlucHV0KHMpIGFuZCB0aGVuIHBvc3QtcHJvY2Vzc2luZyB0aGUgcmVzdWx0LlxuICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbiAgLy8gKC0yXjYzKSBiZWNhdXNlIC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFIChzaW5jZSAyXjYzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBhc1xuICAvLyBhIHBvc2l0aXZlIG51bWJlciwgaXQgb3ZlcmZsb3dzIGJhY2sgaW50byBhIG5lZ2F0aXZlKS4gIE5vdCBoYW5kbGluZyB0aGlzXG4gIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy9cbiAgLy8gQ29tbW9uIGNvbnN0YW50IHZhbHVlcyBaRVJPLCBPTkUsIE5FR19PTkUsIGV0Yy4gYXJlIGRlZmluZWQgYmVsb3cgdGhlIGZyb20qXG4gIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG4gIFxuICAvKipcbiAgICogQW4gaW5kaWNhdG9yIHVzZWQgdG8gcmVsaWFibHkgZGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIExvbmcgb3Igbm90LlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGNvbnN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBcbiAgXG4gIExvbmcucHJvdG90eXBlLl9faXNMb25nX187XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxuICB9KTtcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyp9IG9iaiBPYmplY3RcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGlzTG9uZyhvYmopIHtcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgbnVtYmVyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIFxuICBmdW5jdGlvbiBjdHozMih2YWx1ZSkge1xuICAgIHZhciBjID0gTWF0aC5jbHozMih2YWx1ZSAmIC12YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYztcbiAgfVxuICAvKipcbiAgICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBMb25nLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmlzTG9uZyA9IGlzTG9uZztcbiAgLyoqXG4gICAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIElOVF9DQUNIRSA9IHt9O1xuICAvKipcbiAgICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXG4gICAqIEB0eXBlIHshT2JqZWN0fVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICB2YXIgb2JqLCBjYWNoZWRPYmosIGNhY2hlO1xuICBcbiAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgIHZhbHVlID4+Pj0gMDtcbiAgXG4gICAgICBpZiAoY2FjaGUgPSAwIDw9IHZhbHVlICYmIHZhbHVlIDwgMjU2KSB7XG4gICAgICAgIGNhY2hlZE9iaiA9IFVJTlRfQ0FDSEVbdmFsdWVdO1xuICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgfVxuICBcbiAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICAgIGlmIChjYWNoZSkgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSB8PSAwO1xuICBcbiAgICAgIGlmIChjYWNoZSA9IC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpIHtcbiAgICAgICAgY2FjaGVkT2JqID0gSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgIH1cbiAgXG4gICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XG4gICAgICBpZiAoY2FjaGUpIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiAzMiBiaXQgaW50ZWdlciB2YWx1ZS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tSW50ID0gZnJvbUludDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICBcbiAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgIGlmICh2YWx1ZSA8IDApIHJldHVybiBVWkVSTztcbiAgICAgIGlmICh2YWx1ZSA+PSBUV09fUFdSXzY0X0RCTCkgcmV0dXJuIE1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIDw9IC1UV09fUFdSXzYzX0RCTCkgcmV0dXJuIE1JTl9WQUxVRTtcbiAgICAgIGlmICh2YWx1ZSArIDEgPj0gVFdPX1BXUl82M19EQkwpIHJldHVybiBNQVhfVkFMVUU7XG4gICAgfVxuICBcbiAgICBpZiAodmFsdWUgPCAwKSByZXR1cm4gZnJvbU51bWJlcigtdmFsdWUsIHVuc2lnbmVkKS5uZWcoKTtcbiAgICByZXR1cm4gZnJvbUJpdHModmFsdWUgJSBUV09fUFdSXzMyX0RCTCB8IDAsIHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwgfCAwLCB1bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gdmFsdWUsIHByb3ZpZGVkIHRoYXQgaXQgaXMgYSBmaW5pdGUgbnVtYmVyLiBPdGhlcndpc2UsIHplcm8gaXMgcmV0dXJuZWQuXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2hCaXRzXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICAgKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CaXRzID0gZnJvbUJpdHM7XG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhc2VcbiAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBwb3dfZGJsID0gTWF0aC5wb3c7IC8vIFVzZWQgNCB0aW1lcyAoNCo4IHRvIDE1KzQpXG4gIFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZFxuICAgKiBAcGFyYW0ge251bWJlcj19IHJhZGl4XG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSAwKSB0aHJvdyBFcnJvcignZW1wdHkgc3RyaW5nJyk7XG4gIFxuICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxuICAgICAgcmFkaXggPSB1bnNpZ25lZDtcbiAgICAgIHVuc2lnbmVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICB9XG4gIFxuICAgIGlmIChzdHIgPT09IFwiTmFOXCIgfHwgc3RyID09PSBcIkluZmluaXR5XCIgfHwgc3RyID09PSBcIitJbmZpbml0eVwiIHx8IHN0ciA9PT0gXCItSW5maW5pdHlcIikgcmV0dXJuIHVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgaWYgKHJhZGl4IDwgMiB8fCAzNiA8IHJhZGl4KSB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xuICAgIHZhciBwO1xuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMCkgdGhyb3cgRXJyb3IoJ2ludGVyaW9yIGh5cGhlbicpO2Vsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgIHJldHVybiBmcm9tU3RyaW5nKHN0ci5zdWJzdHJpbmcoMSksIHVuc2lnbmVkLCByYWRpeCkubmVnKCk7XG4gICAgfSAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gIFxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcbiAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgIHZhciBzaXplID0gTWF0aC5taW4oOCwgc3RyLmxlbmd0aCAtIGkpLFxuICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgXG4gICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHJhZGl4VG9Qb3dlcik7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIHN0cmluZywgd3JpdHRlbiB1c2luZyB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0ciBUaGUgdGV4dHVhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgTG9uZ1xuICAgKiBAcGFyYW0geyhib29sZWFufG51bWJlcik9fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICovXG4gIFxuICBcbiAgTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gZnJvbU51bWJlcih2YWwsIHVuc2lnbmVkKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHJldHVybiBmcm9tU3RyaW5nKHZhbCwgdW5zaWduZWQpOyAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICBcbiAgICByZXR1cm4gZnJvbUJpdHModmFsLmxvdywgdmFsLmhpZ2gsIHR5cGVvZiB1bnNpZ25lZCA9PT0gJ2Jvb2xlYW4nID8gdW5zaWduZWQgOiB2YWwudW5zaWduZWQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWwgVmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlOyAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXG4gIC8vIG5vIHJ1bnRpbWUgcGVuYWx0eSBmb3IgdGhlc2UuXG4gIFxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBjb25zdFxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGNvbnN0XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAY29uc3RcbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xuICAvKipcbiAgICogU2lnbmVkIHplcm8uXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLlpFUk8gPSBaRVJPO1xuICAvKipcbiAgICogQHR5cGUgeyFMb25nfVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xuICAvKipcbiAgICogVW5zaWduZWQgemVyby5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuVVpFUk8gPSBVWkVSTztcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE9ORSA9IGZyb21JbnQoMSk7XG4gIC8qKlxuICAgKiBTaWduZWQgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5PTkUgPSBPTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcbiAgLyoqXG4gICAqIFVuc2lnbmVkIG9uZS5cbiAgICogQHR5cGUgeyFMb25nfVxuICAgKi9cbiAgXG4gIExvbmcuVU9ORSA9IFVPTkU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBORUdfT05FID0gZnJvbUludCgtMSk7XG4gIC8qKlxuICAgKiBTaWduZWQgbmVnYXRpdmUgb25lLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweDdGRkZGRkZGIHwgMCwgZmFsc2UpO1xuICAvKipcbiAgICogTWF4aW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1BWF9WQUxVRSA9IE1BWF9WQUxVRTtcbiAgLyoqXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICogQGlubmVyXG4gICAqL1xuICBcbiAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkYgfCAwLCAweEZGRkZGRkZGIHwgMCwgdHJ1ZSk7XG4gIC8qKlxuICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBNQVhfVU5TSUdORURfVkFMVUU7XG4gIC8qKlxuICAgKiBAdHlwZSB7IUxvbmd9XG4gICAqIEBpbm5lclxuICAgKi9cbiAgXG4gIHZhciBNSU5fVkFMVUUgPSBmcm9tQml0cygwLCAweDgwMDAwMDAwIHwgMCwgZmFsc2UpO1xuICAvKipcbiAgICogTWluaW11bSBzaWduZWQgdmFsdWUuXG4gICAqIEB0eXBlIHshTG9uZ31cbiAgICovXG4gIFxuICBMb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcbiAgLyoqXG4gICAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICAgKiBAaW5uZXJcbiAgICovXG4gIFxuICB2YXIgTG9uZ1Byb3RvdHlwZSA9IExvbmcucHJvdG90eXBlO1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IHRoaXMubG93ID4+PiAwIDogdGhpcy5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gdG9OdW1iZXIoKSB7XG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICByZXR1cm4gdGhpcy5oaWdoICogVFdPX1BXUl8zMl9EQkwgKyAodGhpcy5sb3cgPj4+IDApO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSBzdHJpbmcgd3JpdHRlbiBpbiB0aGUgc3BlY2lmaWVkIHJhZGl4LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKiBAb3ZlcnJpZGVcbiAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKHJhZGl4KSB7XG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoJ3JhZGl4Jyk7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAnMCc7XG4gIFxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgLy8gVW5zaWduZWQgTG9uZ3MgYXJlIG5ldmVyIG5lZ2F0aXZlXG4gICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cbiAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxuICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcbiAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xuICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICB9IGVsc2UgcmV0dXJuICctJyArIHRoaXMubmVnKCkudG9TdHJpbmcocmFkaXgpO1xuICAgIH0gLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgIC8vIG1pbmltaXplIHRoZSBjYWxscyB0byB0aGUgdmVyeSBleHBlbnNpdmUgZW11bGF0ZWQgZGl2LlxuICBcbiAgXG4gICAgdmFyIHJhZGl4VG9Qb3dlciA9IGZyb21OdW1iZXIocG93X2RibChyYWRpeCwgNiksIHRoaXMudW5zaWduZWQpLFxuICAgICAgICByZW0gPSB0aGlzO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXG4gICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgIHJlbSA9IHJlbURpdjtcbiAgICAgIGlmIChyZW0uaXNaZXJvKCkpIHJldHVybiBkaWdpdHMgKyByZXN1bHQ7ZWxzZSB7XG4gICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNikgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICBcbiAgICAgICAgcmVzdWx0ID0gJycgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaDtcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGhpZ2ggMzIgYml0cyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG4gIH07XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmxvdztcbiAgfTtcbiAgLyoqXG4gICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgbG93IGJpdHNcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICB9O1xuICAvKipcbiAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGJpdHMgbmVlZGVkIHRvIHJlcHJlc2VudCB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZ2V0TnVtQml0c0FicyA9IGZ1bmN0aW9uIGdldE51bUJpdHNBYnMoKSB7XG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgIHJldHVybiB0aGlzLmVxKE1JTl9WQUxVRSkgPyA2NCA6IHRoaXMubmVnKCkuZ2V0TnVtQml0c0FicygpO1xuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xuICBcbiAgICBmb3IgKHZhciBiaXQgPSAzMTsgYml0ID4gMDsgYml0LS0pIGlmICgodmFsICYgMSA8PCBiaXQpICE9IDApIGJyZWFrO1xuICBcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgemVyby5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5pc05lZ2F0aXZlID0gZnVuY3Rpb24gaXNOZWdhdGl2ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIHBvc2l0aXZlIG9yIHplcm8uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uIGlzUG9zaXRpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5zaWduZWQgfHwgdGhpcy5oaWdoID49IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBldmVuLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMudW5zaWduZWQgIT09IG90aGVyLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA+Pj4gMzEgPT09IDEgJiYgb3RoZXIuaGlnaCA+Pj4gMzEgPT09IDEpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gIH07XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2VxdWFsc30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHMgPSBmdW5jdGlvbiBub3RFcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gIXRoaXMuZXEoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNub3RFcXVhbHN9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpIDwgMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW59LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA8PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbGVzc1RoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW4gPSBmdW5jdGlvbiBncmVhdGVyVGhhbihvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXAoXG4gICAgLyogdmFsaWRhdGVzICovXG4gICAgb3RoZXIpID4gMDtcbiAgfTtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG4gIC8qKlxuICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ncmVhdGVyVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBncmVhdGVyVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wKFxuICAgIC8qIHZhbGlkYXRlcyAqL1xuICAgIG90aGVyKSA+PSAwO1xuICB9O1xuICAvKipcbiAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcbiAgLyoqXG4gICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xuICAvKipcbiAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgaWYgKHRoaXMuZXEob3RoZXIpKSByZXR1cm4gMDtcbiAgICB2YXIgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLFxuICAgICAgICBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHJldHVybiAtMTtcbiAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpIHJldHVybiAxOyAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gIFxuICAgIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7IC8vIEJvdGggYXJlIHBvc2l0aXZlIGlmIGF0IGxlYXN0IG9uZSBpcyB1bnNpZ25lZFxuICBcbiAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fCBvdGhlci5oaWdoID09PSB0aGlzLmhpZ2ggJiYgb3RoZXIubG93ID4+PiAwID4gdGhpcy5sb3cgPj4+IDAgPyAtMSA6IDE7XG4gIH07XG4gIC8qKlxuICAgKiBDb21wYXJlcyB0aGlzIExvbmcncyB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNjb21wYXJlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICogQHJldHVybnMge251bWJlcn0gMCBpZiB0aGV5IGFyZSB0aGUgc2FtZSwgMSBpZiB0aGUgdGhpcyBpcyBncmVhdGVyIGFuZCAtMVxuICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcbiAgLyoqXG4gICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uIG5lZ2F0ZSgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgIHJldHVybiB0aGlzLm5vdCgpLmFkZChPTkUpO1xuICB9O1xuICAvKipcbiAgICogTmVnYXRlcyB0aGlzIExvbmcncyB2YWx1ZS4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNuZWdhdGV9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHJldHVybnMgeyFMb25nfSBOZWdhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHN1bSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU3VtXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQoYWRkZW5kKSB7XG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSkgYWRkZW5kID0gZnJvbVZhbHVlKGFkZGVuZCk7IC8vIERpdmlkZSBlYWNoIG51bWJlciBpbnRvIDQgY2h1bmtzIG9mIDE2IGJpdHMsIGFuZCB0aGVuIHN1bSB0aGUgY2h1bmtzLlxuICBcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IGFkZGVuZC5oaWdoICYgMHhGRkZGO1xuICAgIHZhciBiMTYgPSBhZGRlbmQubG93ID4+PiAxNjtcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICsgYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiArIGIxNjtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMzIgKyBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICsgYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKSBzdWJ0cmFoZW5kID0gZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpZmZlcmVuY2Ugb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3N1YnRyYWN0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXG4gICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWlzTG9uZyhtdWx0aXBsaWVyKSkgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTsgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gIFxuICAgIGlmICh3YXNtKSB7XG4gICAgICB2YXIgbG93ID0gd2FzbVtcIm11bFwiXSh0aGlzLmxvdywgdGhpcy5oaWdoLCBtdWx0aXBsaWVyLmxvdywgbXVsdGlwbGllci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gbXVsdGlwbGllci5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtlbHNlIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcbiAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7IC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cbiAgXG4gIFxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpIHJldHVybiBmcm9tTnVtYmVyKHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSwgdGhpcy51bnNpZ25lZCk7IC8vIERpdmlkZSBlYWNoIGxvbmcgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBhZGQgdXAgNHg0IHByb2R1Y3RzLlxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG4gIFxuICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweEZGRkY7XG4gICAgdmFyIGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgdmFyIGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4RkZGRjtcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgIHZhciBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4RkZGRjtcbiAgICB2YXIgYzQ4ID0gMCxcbiAgICAgICAgYzMyID0gMCxcbiAgICAgICAgYzE2ID0gMCxcbiAgICAgICAgYzAwID0gMDtcbiAgICBjMDAgKz0gYTAwICogYjAwO1xuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgIGMwMCAmPSAweEZGRkY7XG4gICAgYzE2ICs9IGExNiAqIGIwMDtcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICBjMTYgJj0gMHhGRkZGO1xuICAgIGMxNiArPSBhMDAgKiBiMTY7XG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgYzE2ICY9IDB4RkZGRjtcbiAgICBjMzIgKz0gYTMyICogYjAwO1xuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgIGMzMiAmPSAweEZGRkY7XG4gICAgYzMyICs9IGExNiAqIGIxNjtcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICBjMzIgJj0gMHhGRkZGO1xuICAgIGMzMiArPSBhMDAgKiBiMzI7XG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgYzMyICY9IDB4RkZGRjtcbiAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICAgIGM0OCAmPSAweEZGRkY7XG4gICAgcmV0dXJuIGZyb21CaXRzKGMxNiA8PCAxNiB8IGMwMCwgYzQ4IDw8IDE2IHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI211bHRpcGx5fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm11bCA9IExvbmdQcm90b3R5cGUubXVsdGlwbHk7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcbiAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFF1b3RpZW50XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgIGlmIChkaXZpc29yLmlzWmVybygpKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxuICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxuICAgICAgLy8gcG9zaXRpdmUgbnVtYmVyLCBkdWUgdG8gdHdvJ3MgY29tcGxlbWVudC5cbiAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gIFxuICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc21bXCJnZXRfaGlnaFwiXSgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XG4gICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXG4gICAgICAvLyBjbG9zdXJlIGxpYnJhcnkgYXMgYSB3aG9sZS5cbiAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcbiAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKSByZXR1cm4gTUlOX1ZBTFVFOyAvLyByZWNhbGwgdGhhdCAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRVxuICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiBPTkU7ZWxzZSB7XG4gICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxuICAgICAgICAgIHZhciBoYWxmVGhpcyA9IHRoaXMuc2hyKDEpO1xuICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gIFxuICAgICAgICAgIGlmIChhcHByb3guZXEoWkVSTykpIHtcbiAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xuICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gIFxuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSkgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gIFxuICAgICAgcmVzID0gWkVSTztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGFsZ29yaXRobSBiZWxvdyBoYXMgbm90IGJlZW4gbWFkZSBmb3IgdW5zaWduZWQgbG9uZ3MuIEl0J3MgdGhlcmVmb3JlXG4gICAgICAvLyByZXF1aXJlZCB0byB0YWtlIHNwZWNpYWwgY2FyZSBvZiB0aGUgTVNCIHByaW9yIHRvIHJ1bm5pbmcgaXQuXG4gICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKSByZXR1cm4gVVpFUk87XG4gICAgICBpZiAoZGl2aXNvci5ndCh0aGlzLnNocnUoMSkpKSAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxuICAgICAgICByZXR1cm4gVU9ORTtcbiAgICAgIHJlcyA9IFVaRVJPO1xuICAgIH0gLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXG4gICAgLy8gaW50byB0aGUgcmVzdWx0LCBhbmQgc3VidHJhY3QgaXQgZnJvbSB0aGUgcmVtYWluZGVyLiAgSXQgaXMgY3JpdGljYWwgdGhhdFxuICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cbiAgXG4gIFxuICAgIHJlbSA9IHRoaXM7XG4gIFxuICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgICAvLyBBcHByb3hpbWF0ZSB0aGUgcmVzdWx0IG9mIGRpdmlzaW9uLiBUaGlzIG1heSBiZSBhIGxpdHRsZSBncmVhdGVyIG9yXG4gICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cbiAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTsgLy8gV2Ugd2lsbCB0d2VhayB0aGUgYXBwcm94aW1hdGUgcmVzdWx0IGJ5IGNoYW5naW5nIGl0IGluIHRoZSA0OC10aCBkaWdpdCBvclxuICAgICAgLy8gdGhlIHNtYWxsZXN0IG5vbi1mcmFjdGlvbmFsIGRpZ2l0LCB3aGljaGV2ZXIgaXMgbGFyZ2VyLlxuICBcbiAgICAgIHZhciBsb2cyID0gTWF0aC5jZWlsKE1hdGgubG9nKGFwcHJveCkgLyBNYXRoLkxOMiksXG4gICAgICAgICAgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IHBvd19kYmwoMiwgbG9nMiAtIDQ4KSxcbiAgICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcbiAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxuICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gIFxuICAgICAgd2hpbGUgKGFwcHJveFJlbS5pc05lZ2F0aXZlKCkgfHwgYXBwcm94UmVtLmd0KHJlbSkpIHtcbiAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICB9IC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXG4gIFxuICBcbiAgICAgIGlmIChhcHByb3hSZXMuaXNaZXJvKCkpIGFwcHJveFJlcyA9IE9ORTtcbiAgICAgIHJlcyA9IHJlcy5hZGQoYXBwcm94UmVzKTtcbiAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgICB9XG4gIFxuICAgIHJldHVybiByZXM7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5kaXYgPSBMb25nUHJvdG90eXBlLmRpdmlkZTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpOyAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcbiAgXG4gICAgaWYgKHdhc20pIHtcbiAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc21bXCJyZW1fdVwiXSA6IHdhc21bXCJyZW1fc1wiXSkodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5ub3QgPSBmdW5jdGlvbiBub3QoKSB7XG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRMZWFkaW5nWmVyb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlnaCA/IE1hdGguY2x6MzIodGhpcy5oaWdoKSA6IE1hdGguY2x6MzIodGhpcy5sb3cpICsgMzI7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRMZWFkaW5nWmVyb3N9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuY2x6ID0gTG9uZ1Byb3RvdHlwZS5jb3VudExlYWRpbmdaZXJvcztcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3Mgb2YgdGhpcyBMb25nLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICAgIHJldHVybiB0aGlzLmxvdyA/IGN0ejMyKHRoaXMubG93KSA6IGN0ejMyKHRoaXMuaGlnaCkgKyAzMjtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgY291bnQgdHJhaWxpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRUcmFpbGluZ1plcm9zfS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgYml0d2lzZSBPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBzcGVjaWZpZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcbiAgICogQHJldHVybnMgeyFMb25nfVxuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO2Vsc2UgaWYgKG51bUJpdHMgPCAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBudW1CaXRzIHwgdGhpcy5sb3cgPj4+IDMyIC0gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7ZWxzZSByZXR1cm4gZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgbnVtQml0cyAtIDMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUuc2hsID0gTG9uZ1Byb3RvdHlwZS5zaGlmdExlZnQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7ZWxzZSBpZiAobnVtQml0cyA8IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgPj4+IG51bUJpdHMgfCB0aGlzLmhpZ2ggPDwgMzIgLSBudW1CaXRzLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7ZWxzZSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+IG51bUJpdHMgLSAzMiwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGFyaXRobWV0aWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRSaWdodH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNociA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICogQHRoaXMgeyFMb25nfVxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgIGlmIChudW1CaXRzIDwgMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA+Pj4gbnVtQml0cyB8IHRoaXMuaGlnaCA8PCAzMiAtIG51bUJpdHMsIHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoID4+PiBudW1CaXRzIC0gMzIsIDAsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgKi9cbiAgXG4gIFxuICBMb25nUHJvdG90eXBlLnNocnUgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0VW5zaWduZWR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnNocl91ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAqIEByZXR1cm5zIHshTG9uZ30gUm90YXRlZCBMb25nXG4gICAqL1xuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0ID0gZnVuY3Rpb24gcm90YXRlTGVmdChudW1CaXRzKSB7XG4gICAgdmFyIGI7XG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICBpZiAobnVtQml0cyA9PT0gMzIpIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2gsIHRoaXMubG93LCB0aGlzLnVuc2lnbmVkKTtcbiAgXG4gICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyA8PCBudW1CaXRzIHwgdGhpcy5oaWdoID4+PiBiLCB0aGlzLmhpZ2ggPDwgbnVtQml0cyB8IHRoaXMubG93ID4+PiBiLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gIFxuICAgIG51bUJpdHMgLT0gMzI7XG4gICAgYiA9IDMyIC0gbnVtQml0cztcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IG51bUJpdHMgfCB0aGlzLmxvdyA+Pj4gYiwgdGhpcy5sb3cgPDwgbnVtQml0cyB8IHRoaXMuaGlnaCA+Pj4gYiwgdGhpcy51bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RsID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVMZWZ0O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0ID0gZnVuY3Rpb24gcm90YXRlUmlnaHQobnVtQml0cykge1xuICAgIHZhciBiO1xuICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gIFxuICAgIGlmIChudW1CaXRzIDwgMzIpIHtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoIDw8IGIgfCB0aGlzLmxvdyA+Pj4gbnVtQml0cywgdGhpcy5sb3cgPDwgYiB8IHRoaXMuaGlnaCA+Pj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICBcbiAgICBudW1CaXRzIC09IDMyO1xuICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IGIgfCB0aGlzLmhpZ2ggPj4+IG51bUJpdHMsIHRoaXMuaGlnaCA8PCBiIHwgdGhpcy5sb3cgPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICB9O1xuICAvKipcbiAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlUmlnaHR9LlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS5yb3RyID0gTG9uZ1Byb3RvdHlwZS5yb3RhdGVSaWdodDtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICAgKi9cbiAgXG4gIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XG4gIH07XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFMb25nfSBVbnNpZ25lZCBsb25nXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XG4gICAgaWYgKHRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzO1xuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcbiAgfTtcbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxuICAgKiBAdGhpcyB7IUxvbmd9XG4gICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICovXG4gIFxuICBcbiAgTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xuICAgIHJldHVybiBsZSA/IHRoaXMudG9CeXRlc0xFKCkgOiB0aGlzLnRvQnl0ZXNCRSgpO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW2xvICYgMHhmZiwgbG8gPj4+IDggJiAweGZmLCBsbyA+Pj4gMTYgJiAweGZmLCBsbyA+Pj4gMjQsIGhpICYgMHhmZiwgaGkgPj4+IDggJiAweGZmLCBoaSA+Pj4gMTYgJiAweGZmLCBoaSA+Pj4gMjRdO1xuICB9O1xuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEB0aGlzIHshTG9uZ31cbiAgICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAqL1xuICBcbiAgXG4gIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICAgIHZhciBoaSA9IHRoaXMuaGlnaCxcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcbiAgICByZXR1cm4gW2hpID4+PiAyNCwgaGkgPj4+IDE2ICYgMHhmZiwgaGkgPj4+IDggJiAweGZmLCBoaSAmIDB4ZmYsIGxvID4+PiAyNCwgbG8gPj4+IDE2ICYgMHhmZiwgbG8gPj4+IDggJiAweGZmLCBsbyAmIDB4ZmZdO1xuICB9O1xuICAvKipcbiAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzID0gZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCB1bnNpZ25lZCwgbGUpIHtcbiAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gIH07XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgTG9uZyBmcm9tIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBMaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgKi9cbiAgXG4gIFxuICBMb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XG4gICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgYnl0ZXNbMV0gPDwgOCB8IGJ5dGVzWzJdIDw8IDE2IHwgYnl0ZXNbM10gPDwgMjQsIGJ5dGVzWzRdIHwgYnl0ZXNbNV0gPDwgOCB8IGJ5dGVzWzZdIDw8IDE2IHwgYnl0ZXNbN10gPDwgMjQsIHVuc2lnbmVkKTtcbiAgfTtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAqL1xuICBcbiAgXG4gIExvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcbiAgICByZXR1cm4gbmV3IExvbmcoYnl0ZXNbNF0gPDwgMjQgfCBieXRlc1s1XSA8PCAxNiB8IGJ5dGVzWzZdIDw8IDggfCBieXRlc1s3XSwgYnl0ZXNbMF0gPDwgMjQgfCBieXRlc1sxXSA8PCAxNiB8IGJ5dGVzWzJdIDw8IDggfCBieXRlc1szXSwgdW5zaWduZWQpO1xuICB9O1xuICBcbiAgdmFyIF9kZWZhdWx0ID0gTG9uZztcbiAgZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4gIHJldHVybiBcImRlZmF1bHRcIiBpbiBleHBvcnRzID8gZXhwb3J0cy5kZWZhdWx0IDogZXhwb3J0cztcbn0pKHt9KTtcbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIGRlZmluZShbXSwgZnVuY3Rpb24oKSB7IHJldHVybiBMb25nOyB9KTtcbmVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JykgbW9kdWxlLmV4cG9ydHMgPSBMb25nO1xuIl0sIm5hbWVzIjpbIkxvbmciLCJleHBvcnRzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImRlZmF1bHQiLCJ3YXNtIiwiV2ViQXNzZW1ibHkiLCJJbnN0YW5jZSIsIk1vZHVsZSIsIlVpbnQ4QXJyYXkiLCJlIiwibG93IiwiaGlnaCIsInVuc2lnbmVkIiwicHJvdG90eXBlIiwiX19pc0xvbmdfXyIsImlzTG9uZyIsIm9iaiIsImN0ejMyIiwiYyIsIk1hdGgiLCJjbHozMiIsIklOVF9DQUNIRSIsIlVJTlRfQ0FDSEUiLCJmcm9tSW50IiwiY2FjaGVkT2JqIiwiY2FjaGUiLCJmcm9tQml0cyIsImZyb21OdW1iZXIiLCJpc05hTiIsIlVaRVJPIiwiWkVSTyIsIlRXT19QV1JfNjRfREJMIiwiTUFYX1VOU0lHTkVEX1ZBTFVFIiwiVFdPX1BXUl82M19EQkwiLCJNSU5fVkFMVUUiLCJNQVhfVkFMVUUiLCJuZWciLCJUV09fUFdSXzMyX0RCTCIsImxvd0JpdHMiLCJoaWdoQml0cyIsInBvd19kYmwiLCJwb3ciLCJmcm9tU3RyaW5nIiwic3RyIiwicmFkaXgiLCJsZW5ndGgiLCJFcnJvciIsIlJhbmdlRXJyb3IiLCJwIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInJhZGl4VG9Qb3dlciIsInJlc3VsdCIsImkiLCJzaXplIiwibWluIiwicGFyc2VJbnQiLCJwb3dlciIsIm11bCIsImFkZCIsImZyb21WYWx1ZSIsInZhbCIsIlRXT19QV1JfMTZfREJMIiwiVFdPX1BXUl8yNF9EQkwiLCJUV09fUFdSXzI0IiwiT05FIiwiVU9ORSIsIk5FR19PTkUiLCJMb25nUHJvdG90eXBlIiwidG9JbnQiLCJ0b051bWJlciIsInRvU3RyaW5nIiwiaXNaZXJvIiwiaXNOZWdhdGl2ZSIsImVxIiwicmFkaXhMb25nIiwiZGl2IiwicmVtMSIsInN1YiIsInJlbSIsInJlbURpdiIsImludHZhbCIsImRpZ2l0cyIsImdldEhpZ2hCaXRzIiwiZ2V0SGlnaEJpdHNVbnNpZ25lZCIsImdldExvd0JpdHMiLCJnZXRMb3dCaXRzVW5zaWduZWQiLCJnZXROdW1CaXRzQWJzIiwiYml0IiwiZXF6IiwiaXNQb3NpdGl2ZSIsImlzT2RkIiwiaXNFdmVuIiwiZXF1YWxzIiwib3RoZXIiLCJub3RFcXVhbHMiLCJuZXEiLCJuZSIsImxlc3NUaGFuIiwiY29tcCIsImx0IiwibGVzc1RoYW5PckVxdWFsIiwibHRlIiwibGUiLCJncmVhdGVyVGhhbiIsImd0IiwiZ3JlYXRlclRoYW5PckVxdWFsIiwiZ3RlIiwiZ2UiLCJjb21wYXJlIiwidGhpc05lZyIsIm90aGVyTmVnIiwibmVnYXRlIiwibm90IiwiYWRkZW5kIiwiYTQ4IiwiYTMyIiwiYTE2IiwiYTAwIiwiYjQ4IiwiYjMyIiwiYjE2IiwiYjAwIiwiYzQ4IiwiYzMyIiwiYzE2IiwiYzAwIiwic3VidHJhY3QiLCJzdWJ0cmFoZW5kIiwibXVsdGlwbHkiLCJtdWx0aXBsaWVyIiwiZGl2aWRlIiwiZGl2aXNvciIsImFwcHJveCIsInJlcyIsImhhbGZUaGlzIiwic2hyIiwic2hsIiwidG9VbnNpZ25lZCIsInNocnUiLCJtYXgiLCJmbG9vciIsImxvZzIiLCJjZWlsIiwibG9nIiwiTE4yIiwiZGVsdGEiLCJhcHByb3hSZXMiLCJhcHByb3hSZW0iLCJtb2R1bG8iLCJtb2QiLCJjb3VudExlYWRpbmdaZXJvcyIsImNseiIsImNvdW50VHJhaWxpbmdaZXJvcyIsImN0eiIsImFuZCIsIm9yIiwieG9yIiwic2hpZnRMZWZ0IiwibnVtQml0cyIsInNoaWZ0UmlnaHQiLCJzaGlmdFJpZ2h0VW5zaWduZWQiLCJzaHJfdSIsInJvdGF0ZUxlZnQiLCJiIiwicm90bCIsInJvdGF0ZVJpZ2h0Iiwicm90ciIsInRvU2lnbmVkIiwidG9CeXRlcyIsInRvQnl0ZXNMRSIsInRvQnl0ZXNCRSIsImhpIiwibG8iLCJmcm9tQnl0ZXMiLCJieXRlcyIsImZyb21CeXRlc0xFIiwiZnJvbUJ5dGVzQkUiLCJfZGVmYXVsdCIsImRlZmluZSIsImFtZCIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/long/umd/index.js\n");

/***/ })

};
;